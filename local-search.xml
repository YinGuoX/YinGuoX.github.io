<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习程序练习1:线性回归</title>
    <link href="/2020/06/20/ML_Andrew_Pex1_Linear_Regression/"/>
    <url>/2020/06/20/ML_Andrew_Pex1_Linear_Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习1-线性回归"><a href="#吴恩达机器学习程序练习1-线性回归" class="headerlink" title="吴恩达机器学习程序练习1:线性回归"></a>吴恩达机器学习程序练习1:线性回归</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex14179</p><pre><code class="lang-python"># 导入对应的第三方库import numpy as npimport pandas as pdimport matplotlib.pyplot as plt</code></pre><h2 id="1-简单练习"><a href="#1-简单练习" class="headerlink" title="1.简单练习"></a>1.简单练习</h2><pre><code class="lang-python">A = np.eye(6)A</code></pre><pre><code>array([[1., 0., 0., 0., 0., 0.],       [0., 1., 0., 0., 0., 0.],       [0., 0., 1., 0., 0., 0.],       [0., 0., 0., 1., 0., 0.],       [0., 0., 0., 0., 1., 0.],       [0., 0., 0., 0., 0., 1.]])</code></pre><h2 id="2-单变量的线性回归"><a href="#2-单变量的线性回归" class="headerlink" title="2.单变量的线性回归"></a>2.单变量的线性回归</h2><p>根据城市人口数量，预测开小吃店的利润。<br>数据在ex1data1.txt中，第一列是城市人口数量，第二列是该城市小吃店利润</p><h3 id="2-1-Plotting-the-data"><a href="#2-1-Plotting-the-data" class="headerlink" title="2.1 Plotting the data"></a>2.1 Plotting the data</h3><pre><code class="lang-python"># 读入数据并且显示path = &#39;./andrew_ml_ex14179/ex1data1.txt&#39;# header=1：以第一行数据作为列索引(列名)# names = [...]:给定列名# 返回DataFrame类型,Population：人口(万)data = pd.read_csv(path,header=None,names=[&#39;Population&#39;,&#39;Profit&#39;])# DataFrame.head([N]):返回前N行data.head(94)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Population</th>      <th>Profit</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>6.1101</td>      <td>17.5920</td>    </tr>    <tr>      <th>1</th>      <td>5.5277</td>      <td>9.1302</td>    </tr>    <tr>      <th>2</th>      <td>8.5186</td>      <td>13.6620</td>    </tr>    <tr>      <th>3</th>      <td>7.0032</td>      <td>11.8540</td>    </tr>    <tr>      <th>4</th>      <td>5.8598</td>      <td>6.8233</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>89</th>      <td>5.0594</td>      <td>2.8214</td>    </tr>    <tr>      <th>90</th>      <td>5.7077</td>      <td>1.8451</td>    </tr>    <tr>      <th>91</th>      <td>7.6366</td>      <td>4.2959</td>    </tr>    <tr>      <th>92</th>      <td>5.8707</td>      <td>7.2029</td>    </tr>    <tr>      <th>93</th>      <td>5.3054</td>      <td>1.9869</td>    </tr>  </tbody></table><p>94 rows × 2 columns</p></div><pre><code class="lang-python"># 将数据绘图成散点图data.plot(kind=&#39;scatter&#39;,x=&#39;Population&#39;,y=&#39;Profit&#39;,figsize=(12,8))plt.show()</code></pre><p><img src="/img/ML_Andrew/output_8_0.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-2-梯度下降"><a href="#2-2-梯度下降" class="headerlink" title="2.2 梯度下降"></a>2.2 梯度下降</h3><p>使用传统的线性回归的代价函数</p><h4 id="2-2-1-公式"><a href="#2-2-1-公式" class="headerlink" title="2.2.1 公式"></a>2.2.1 公式</h4><p><img src="attachment:1.1.png" srcset="/img/loading.gif" alt="1.1.png"></p><pre><code class="lang-python"># X是矩阵def computeCost(X,y,theta):    # *对应元素相乘    inner = np.power(((X*theta.T)-y),2)    return np.sum(inner)/(2*len(X))</code></pre><pre><code class="lang-python"># 验证矩阵间的乘法(*)是对应元素相乘x=np.array([[1,2],[3,4]])y=np.array([[1,2],[3,4]])print(x*y)# 这才是真正的矩阵的乘法print(x.dot(y))# 对应元素相减print(x-y)</code></pre><pre><code>[[ 1  4] [ 9 16]][[ 7 10] [15 22]][[0 0] [0 0]]</code></pre><h4 id="2-2-2-实现"><a href="#2-2-2-实现" class="headerlink" title="2.2.2 实现"></a>2.2.2 实现</h4><p>新加一列x，用于更新theta,并且将theta初始化为0，学习率初始化为0.01，迭代次数为1500次</p><pre><code class="lang-python"># 在第0列新增一列索引为Ones的全部为1的数据data.insert(0,&#39;Ones&#39;,1)# 删除某一列 要axis=1，因为默认是行# 并且要inplace=True,才是对原数据进行操作data.head(100)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Ones</th>      <th>Population</th>      <th>Profit</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>6.1101</td>      <td>17.59200</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>5.5277</td>      <td>9.13020</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>8.5186</td>      <td>13.66200</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>7.0032</td>      <td>11.85400</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>5.8598</td>      <td>6.82330</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>92</th>      <td>1</td>      <td>5.8707</td>      <td>7.20290</td>    </tr>    <tr>      <th>93</th>      <td>1</td>      <td>5.3054</td>      <td>1.98690</td>    </tr>    <tr>      <th>94</th>      <td>1</td>      <td>8.2934</td>      <td>0.14454</td>    </tr>    <tr>      <th>95</th>      <td>1</td>      <td>13.3940</td>      <td>9.05510</td>    </tr>    <tr>      <th>96</th>      <td>1</td>      <td>5.4369</td>      <td>0.61705</td>    </tr>  </tbody></table><p>97 rows × 3 columns</p></div><pre><code class="lang-python"># 初始化# 获得data的列数，0为行数cols=data.shape[1]print(cols)# [,]先行后列,获取对应行列对应区域的数据X = data.iloc[:,:-1]Y = data.iloc[:,cols-1:cols]# X训练集 Y目标集print(type(X))print(type(Y))</code></pre><pre><code>3&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><pre><code class="lang-python"># 因为代价函数使用的是numpy矩阵，所以要转换X和Y，并且初始化theta# X.values:获取X的值，没有索引了# print(type(X.values))# print(Y.values)print(type(X))# 将X，Y转换为对应的矩阵X=np.matrix(X)# print(X)print(X)print(type(Y))y=np.matrix(Y.values)print(type(y))theta = np.asmatrix(np.array([0,0]))print(theta)</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;[[ 1.      6.1101] [ 1.      5.5277] [ 1.      8.5186] [ 1.      7.0032] [ 1.      5.8598] [ 1.      8.3829] [ 1.      7.4764] [ 1.      8.5781] [ 1.      6.4862] [ 1.      5.0546] [ 1.      5.7107] [ 1.     14.164 ] [ 1.      5.734 ] [ 1.      8.4084] [ 1.      5.6407] [ 1.      5.3794] [ 1.      6.3654] [ 1.      5.1301] [ 1.      6.4296] [ 1.      7.0708] [ 1.      6.1891] [ 1.     20.27  ] [ 1.      5.4901] [ 1.      6.3261] [ 1.      5.5649] [ 1.     18.945 ] [ 1.     12.828 ] [ 1.     10.957 ] [ 1.     13.176 ] [ 1.     22.203 ] [ 1.      5.2524] [ 1.      6.5894] [ 1.      9.2482] [ 1.      5.8918] [ 1.      8.2111] [ 1.      7.9334] [ 1.      8.0959] [ 1.      5.6063] [ 1.     12.836 ] [ 1.      6.3534] [ 1.      5.4069] [ 1.      6.8825] [ 1.     11.708 ] [ 1.      5.7737] [ 1.      7.8247] [ 1.      7.0931] [ 1.      5.0702] [ 1.      5.8014] [ 1.     11.7   ] [ 1.      5.5416] [ 1.      7.5402] [ 1.      5.3077] [ 1.      7.4239] [ 1.      7.6031] [ 1.      6.3328] [ 1.      6.3589] [ 1.      6.2742] [ 1.      5.6397] [ 1.      9.3102] [ 1.      9.4536] [ 1.      8.8254] [ 1.      5.1793] [ 1.     21.279 ] [ 1.     14.908 ] [ 1.     18.959 ] [ 1.      7.2182] [ 1.      8.2951] [ 1.     10.236 ] [ 1.      5.4994] [ 1.     20.341 ] [ 1.     10.136 ] [ 1.      7.3345] [ 1.      6.0062] [ 1.      7.2259] [ 1.      5.0269] [ 1.      6.5479] [ 1.      7.5386] [ 1.      5.0365] [ 1.     10.274 ] [ 1.      5.1077] [ 1.      5.7292] [ 1.      5.1884] [ 1.      6.3557] [ 1.      9.7687] [ 1.      6.5159] [ 1.      8.5172] [ 1.      9.1802] [ 1.      6.002 ] [ 1.      5.5204] [ 1.      5.0594] [ 1.      5.7077] [ 1.      7.6366] [ 1.      5.8707] [ 1.      5.3054] [ 1.      8.2934] [ 1.     13.394 ] [ 1.      5.4369]]&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;numpy.matrix&#39;&gt;[[0 0]]</code></pre><pre><code class="lang-python"># 查看对应维度X.shape,theta.shape,y.shapeprint(theta.size)</code></pre><pre><code>2</code></pre><h4 id="2-2-3-计算代价函数"><a href="#2-2-3-计算代价函数" class="headerlink" title="2.2.3 计算代价函数"></a>2.2.3 计算代价函数</h4><p>theta初始为0<br>computeCost(X,y,theta)</p><pre><code class="lang-python">computeCost(X,y,theta)</code></pre><pre><code>32.072733877455676</code></pre><h4 id="2-2-4-梯度下降算法"><a href="#2-2-4-梯度下降算法" class="headerlink" title="2.2.4 梯度下降算法"></a>2.2.4 梯度下降算法</h4><p>目标是最小化代价函数J(theta)，变量是theta不是X和y,通过变换theta来变化代价函数，进而使代价函数最小。<br>检查梯度下降算法是否正确运行，可以打印J(theta)的值来判断是否在不断减小，并且最后收敛到一个稳定的值。</p><pre><code class="lang-python">def gradientDescent(X,y,theta,alpha,iters):    # 初始化参数矩阵    temp=np.matrix(np.zeros(theta.shape))    # ravel()将矩阵扁平化    # 获取参数theta的个数    parameters = int(theta.ravel().shape[1])    # 用来存储代价    cost = np.zeros(iters)    thetax = np.zeros((iters,theta.size))    # print(thetax)    for i in range(iters):        # 计算代价误差        # h_theta(x)-y        error = (X*theta.T)-y        for j in range(parameters):            # np.multiply()对应元素相乘            # 计算J(theta)的导数            term = np.multiply(error,X[:,j])            # 进行梯度下降            temp[0,j]=theta[0,j]-((alpha/len(X)))*np.sum(term)            thetax[i][j]=temp[0,j]        theta = temp        cost[i]=computeCost(X,y,theta)    return theta,cost,thetax</code></pre><pre><code class="lang-python"># 初始化alpha 和 itersalpha = 0.01iters = 1500# 运行梯度下降算法来找到适合训练集的thetag,cost,thetax = gradientDescent(X,y,theta,alpha,iters)g</code></pre><pre><code>matrix([[-3.63029144,  1.16636235]])</code></pre><pre><code class="lang-python"># 预测35000和70000城市规模的小吃利润predict1 = [1,3.5]*g.Tprint(&quot;predict1:&quot;,predict1)predict2=[1,7]*g.Tprint(&quot;predict2:&quot;,predict2)</code></pre><pre><code>predict1: [[0.45197679]]predict2: [[4.53424501]]</code></pre><pre><code class="lang-python"># 显示原始数据以及拟合的线性回归方程# numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 在[start,stop]返回num均匀分布的样本x = np.linspace(data.Population.min(),data.Population.max(),100)# print(x)f = g[0,0]+(g[0,1]*x)# plt.subplots(1,3,figsize=(12,8))设置一个1行3个12*8大小的子图# 返回一个figure图像和一个子图ax的列表fig ,ax =plt.subplots(figsize=(12,8))# ax.plot()绘制一条线ax.plot(x,f,&#39;r&#39;,label=&#39;Prediction&#39;)# ax.scatter()绘制一个散点图ax.scatter(data.Population,data.Profit,label=&#39;Training Data&#39;)# ax.legend(loc=1)显示图中的标签在第一象限ax.legend(loc=1)ax.set_xlabel(&quot;Population&quot;)ax.set_ylabel(&#39;Profit&#39;)ax.set_title(&quot;Predicted Profit vs. Population Size&quot;)plt.show()</code></pre><p><img src="/img/ML_Andrew/output_23_0.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-3可视化J-theta-未完待续"><a href="#2-3可视化J-theta-未完待续" class="headerlink" title="2.3可视化J(theta)(未完待续)"></a>2.3可视化J(theta)(未完待续)</h3><p>希望能够画出J(theta)与theta0,theta1之间的对应关系，应该是一个三维图像</p><pre><code class="lang-python">print(thetax.shape)print(cost.shape)print(X.shape)print(y.shape)print(cost)</code></pre><pre><code>(1500, 2)(1500,)(97, 2)(97, 1)[6.73719046 5.93159357 5.90115471 ... 4.48343473 4.48341145 4.48338826]</code></pre><pre><code class="lang-python"># 绘制3d图像# 直接根据theta0,theta1,costfunction对应的点来绘制出的散点图from mpl_toolkits.mplot3d import Axes3Dfrom matplotlib import cmfig=plt.figure()ax=fig.add_subplot(111,projection=&#39;3d&#39;)x=thetax[:,0]y1=thetax[:,1]ax.plot_trisurf(x,y1,cost,)plt.show()</code></pre><p><img src="/img/ML_Andrew/output_26_0.png" srcset="/img/loading.gif" alt="png"></p><h2 id="3-多变量线性回归"><a href="#3-多变量线性回归" class="headerlink" title="3 多变量线性回归"></a>3 多变量线性回归</h2><p>数据集:ex1data2.txt：<br>第一列：房屋大小<br>第二列：卧室数量<br>第三列：房屋售价<br>根据已有数据建立模型，预测房屋的售价</p><pre><code class="lang-python"># 读入数据并且显示path = &#39;./andrew_ml_ex14179/ex1data2.txt&#39;# header=1：以第一行数据作为列索引(列名)# names = [...]:给定列名# 返回DataFrame类型,Population：人口(万)data2 = pd.read_csv(path,header=None,names=[&#39;Size&#39;,&#39;Bedrooms&#39;,&#39;Price&#39;])# DataFrame.head([N]):返回前N行print(data2.head())print(data2.shape)</code></pre><pre><code>   Size  Bedrooms   Price0  2104         3  3999001  1600         3  3299002  2400         3  3690003  1416         2  2320004  3000         4  539900(47, 3)</code></pre><h3 id="3-1-特征缩放-Feature-Scaling"><a href="#3-1-特征缩放-Feature-Scaling" class="headerlink" title="3.1 特征缩放(Feature Scaling)"></a>3.1 特征缩放(Feature Scaling)</h3><p>根据数据得知，size变量的大小是bedrooms的1000倍，所以最好统一量级，可以使梯度下降收敛的更快</p><h4 id="3-1-1Mean-Normalization-均值归一化"><a href="#3-1-1Mean-Normalization-均值归一化" class="headerlink" title="3.1.1Mean Normalization(均值归一化)"></a>3.1.1Mean Normalization(均值归一化)</h4><p>特征减去平均值再除以标准差</p><pre><code class="lang-python">data2 = (data2-data2.mean())/data2.std()data2.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Size</th>      <th>Bedrooms</th>      <th>Price</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.130010</td>      <td>-0.223675</td>      <td>0.475747</td>    </tr>    <tr>      <th>1</th>      <td>-0.504190</td>      <td>-0.223675</td>      <td>-0.084074</td>    </tr>    <tr>      <th>2</th>      <td>0.502476</td>      <td>-0.223675</td>      <td>0.228626</td>    </tr>    <tr>      <th>3</th>      <td>-0.735723</td>      <td>-1.537767</td>      <td>-0.867025</td>    </tr>    <tr>      <th>4</th>      <td>1.257476</td>      <td>1.090417</td>      <td>1.595389</td>    </tr>  </tbody></table></div><h3 id="3-2-梯度下降算法"><a href="#3-2-梯度下降算法" class="headerlink" title="3.2 梯度下降算法"></a>3.2 梯度下降算法</h3><pre><code class="lang-python"># 为了能够根据矩阵运算，添加一列常数项# data2.drop(&#39;Ones&#39;,axis=1,inplace=True)data2.insert(0,&#39;Ones&#39;,1)# 初始化x,ycols = data2.shape[1]X2=data2.iloc[:,0:cols-1]y2=data2.iloc[:,cols-1:cols]# 转换为matrix格式并且初始化thetax2=np.matrix(X2)y2=np.matrix(y2)theta2 = np.matrix(np.array([0,0,0]))# 运行梯度下降算法print(&quot;开始运行梯度下降算法&quot;)g2,cost2,thetax=gradientDescent(x2,y2,theta2,alpha,iters)g2</code></pre><pre><code>开始运行梯度下降算法matrix([[-1.10898288e-16,  8.84042349e-01, -5.24551809e-02]])</code></pre><h3 id="3-3-Normal-Equation-正规方程算法"><a href="#3-3-Normal-Equation-正规方程算法" class="headerlink" title="3.3 Normal Equation(正规方程算法)"></a>3.3 Normal Equation(正规方程算法)</h3><p>正规方程是直接以theta为变量求解J(theta)的最小值，也即是直接求每个theta的偏导并且令其为0，求解方程即可<br>则利用正规方程解出向量：</p><script type="math/tex; mode=display">\theta = (X^TX)^{-1}X^Ty</script><p>梯度下降 VS 正规方程<br>梯度下降：需要选择学习率α，需要多次迭代，当特征数量n大时也能较好适用，适用于各种类型的模型<br>正规方程：不需要选择学习率α，一次计算得出，需要计算$(X^TX)^{-1}$，如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为O($n^3$)，通常来说当小于10000 时还是可以接受的，只适用于线性模型，不适合逻辑回归模型等其他模型</p><pre><code class="lang-python"># 正规方程def normalEqn(X,y):# numpy.linalg模块包含线性代数的函数。# 使用这个模块，可以计算逆矩阵、求特征值、解线性方程组以及求解行列式等# inv()求解矩阵的逆# pinv()求解矩阵的伪逆    theta = np.linalg.inv(X.T.dot(X))    theta = theta.dot(X.T)    theta = theta.dot(y)    return theta</code></pre><pre><code class="lang-python"># 使用data1数据进行验证final_theta2=normalEqn(X,y)final_theta2</code></pre><pre><code>matrix([[-3.89578088],        [ 1.19303364]])</code></pre><pre><code class="lang-python"># 使用梯度下降算法# 初始化alpha 和 itersalpha = 0.01iters = 1500# 运行梯度下降算法来找到适合训练集的thetag,cost,thetax = gradientDescent(X,y,theta,alpha,iters)g</code></pre><pre><code>matrix([[-3.63029144,  1.16636235]])</code></pre><p>```python</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T18</title>
    <link href="/2020/05/11/CprogrammingT18/"/>
    <url>/2020/05/11/CprogrammingT18/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T18"><a href="#C语言编程T18" class="headerlink" title="C语言编程T18"></a>C语言编程T18</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>空格处理要全面！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/211.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 80int CountWords(char str[]);int main(){    char str[N+1];    printf(&quot;Input a string:&quot;);    gets(str);    printf(&quot;Numbers of words = %d\n&quot;,CountWords(str));    return 0;}int CountWords(char str[]){    int i,j=0,k=0,count=0;    for(i=0;str[i]==&#39; &#39;;i++);    j=i-1;    for(i=0;str[i]!=&#39;\0&#39;;i++)    {        if(str[i]==&#39; &#39;)        {            for(k=i;str[k]==&#39; &#39;;k++);            i=k-1;            //printf(&quot;%c\n&quot;,str[i]);            if(i&gt;j)            {                count++;                j=i;            }        }    }    if(i&gt;j&amp;&amp;str[i-1]!=&#39; &#39;)    {        count++;        j=i;    }    return count;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T17</title>
    <link href="/2020/05/11/CprogrammingT17/"/>
    <url>/2020/05/11/CprogrammingT17/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T17"><a href="#C语言编程T17" class="headerlink" title="C语言编程T17"></a>C语言编程T17</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>注意边界</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/210.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int a[20]={2,4,6,8,10,12,14,16};    int i,j,x,len=8;    printf(&quot;Enter n:&quot;);    scanf(&quot;%d&quot;,&amp;x);    for(i=0;i&lt;len;i++)    {        if(a[0]&gt;x)        {            i=0;            break;        }        else if(a[i]&lt;x&amp;&amp;a[i+1]&gt;x)        {            i++;            break;        }        else if(a[len-1]&lt;x)        {            i=len-1;        }    }    for(j=len+1;j&gt;=i;j--)    {        a[j+1]=a[j];    }    a[i]=x;    for(i=0;i&lt;len+1;i++)    {        printf(&quot;%d &quot;,a[i]);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T7</title>
    <link href="/2020/04/27/CorrectionT7/"/>
    <url>/2020/04/27/CorrectionT7/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T7"><a href="#C语言改错T7" class="headerlink" title="C语言改错T7"></a>C语言改错T7</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p><strong>注意返回的是-1还是+1，是谁到谁的距离！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/171.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;int MyStrcmp(char s[], char t[], char bigger[]);int main(){    char  str1[20], str2[20], str3[20];    int diff;    printf(&quot;Input string:&quot;);    gets(str1);    printf(&quot;Input another string:&quot;);    gets(str2);    diff = MyStrcmp(str1, str2, str3);    printf(&quot;The bigger string is:%s\n&quot;, str3);    printf(&quot;The differ of the strings is:%d\n&quot;, diff);    return 0;}int MyStrcmp(char s[], char t[], char bigger[]){    int i, result = 0;    int len1 = 0, len2 = 0;    while (s[len1++] != &#39;\0&#39;);    while (t[len2++] != &#39;\0&#39;);    for (i = 0; s[i] == t[i]; i++);    if (i==0 || s[i - 1] != &#39;\0&#39; )    {        result = t[i] - s[i];        //printf(&quot;rst=%d\n&quot;,result);    }    if (result &gt;= 0)    {        for (i = 0; i &lt; len2; i++)            bigger[i] = t[i];        bigger[i]=&#39;\0&#39;;    }    else    {        for (i = 0; i &lt; len1; i++)            bigger[i] = s[i];        bigger[i]=&#39;\0&#39;;    }    return -result;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T16</title>
    <link href="/2020/04/27/CprogrammingT16/"/>
    <url>/2020/04/27/CprogrammingT16/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T16"><a href="#C语言编程T16" class="headerlink" title="C语言编程T16"></a>C语言编程T16</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>根据过程自己找规律</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/169.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//分酒int i;main(){    int a,y,z;    //共有a,分成i    printf(&quot;Input Full a,Empty b,c,Get i:&quot;);    scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;y,&amp;z,&amp;i);    getti(a,y,z);    getti(a,z,y);}getti(a,y,z)  int a,y,z;  {int b=0,c=0;  //a、b、c表示现在容器已装的容量大小  //a、y、z表示的是容器的最大容量    printf(&quot;  a%d  b%d  c%d\n%4d%4d%4d\n&quot;,a,y,z,a,b,c);    while((a!=i||b!=i)&amp;&amp;c!=i)    {        //b为空,即将a倒满b        if(!b)        {            a-=y;            b=y;        }        //c已满,将c全部倒入a        else if(c==z)        {           a+=z;           c=0;        }        //b的容量大于c中还可以装入的容量        //将b倒入c直到装满        else if(b&gt;z-c)        {            b-=(z-c);            c=z;        }        //倒空b        else        {            c+=b;            b=0;        }        printf(&quot;%4d%4d%4d\n&quot;,a,b,c);    }  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T15</title>
    <link href="/2020/04/26/CprogrammingT15/"/>
    <url>/2020/04/26/CprogrammingT15/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T15"><a href="#C语言编程T15" class="headerlink" title="C语言编程T15"></a>C语言编程T15</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>字符串遇到 多空格、结尾空格、开头空格如何解决</strong><br>if判断要全面！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/165.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 80//多空格和结尾如何解决int CountWords(char str[]);int main(){    char str[N+1];   printf(&quot;Input a string:\n&quot;);   gets(str);   printf(&quot;Number of words=%d\n&quot;,CountWords(str));    return 0;}int CountWords(char str[]){    int i,k,count=0;    for(i=0;str[i]!=&#39;\0&#39;;i++)    {        if(str[i]==&#39; &#39;)        {            for(k=i;str[k]==&#39; &#39;;k++);            i=k;            if(str[i]!=&#39;\0&#39;)            {                count++;            }        }    }    return count+1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T14</title>
    <link href="/2020/04/26/CprogrammingT14/"/>
    <url>/2020/04/26/CprogrammingT14/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T14"><a href="#C语言编程T14" class="headerlink" title="C语言编程T14"></a>C语言编程T14</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>相等情况？？？每行情况？？？</strong><br>所以要有两个标记量</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/163.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 6int main(){    int i,j,a[M][N],flag=0,flagz=0,max,min,row,col,k;    for(i=0;i&lt;M;i++)    {        for(j=0;j&lt;N;j++)        {            scanf(&quot;%d&quot;,&amp;a[i][j]);        }    }    for(i=0;i&lt;M;i++)    {        flag=1;        max=a[i][0];        for(j=0;j&lt;N;j++)        {            if(max&lt;a[i][j])            {                row=i;                col=j;                max=a[i][j];            }        }        //printf(&quot;max=%d\n&quot;,max);        for(k=0;k&lt;M;k++)        {            if(max&gt;=a[k][col]&amp;&amp;k!=row)            {                flag=0;                break;            }        }         //printf(&quot;min=%d\n&quot;,min);        if(flag)        {            flagz=1;            printf(&quot;%d\n&quot;,max);        }    }    if(!flagz)    {        printf(&quot;no saddle point\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T13</title>
    <link href="/2020/04/26/CprogrammingT13/"/>
    <url>/2020/04/26/CprogrammingT13/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T13"><a href="#C语言编程T13" class="headerlink" title="C语言编程T13"></a>C语言编程T13</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>四舍五入的函数是round()<br>向下取整的函数是floor()</strong><br>注意 : 题目要求</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/161.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define N 100int main(){    int saraly,houres,t,t1,i=0,g[N]={0};    float sh=0;    scanf(&quot;%d %d&quot;,&amp;saraly,&amp;houres);    sh=(float)saraly/houres;    printf(&quot;%.2f\n&quot;,sh);    t=round(sh);    printf( &quot;%d\n&quot;,t);    t1=t*t;    while(t1&gt;0)    {        g[i]=t1%10;        i++;        t1=t1/10;    }    printf(&quot;%d\n&quot;,i);    printf(&quot;%d %d %d\n&quot;,g[2],g[1],g[0]);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T12</title>
    <link href="/2020/04/25/CprogrammingT12/"/>
    <url>/2020/04/25/CprogrammingT12/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T12"><a href="#C语言编程T12" class="headerlink" title="C语言编程T12"></a>C语言编程T12</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>约束条件很重要，不要越界！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/149.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int Isprime(long x);int main(){    long int c,d,total=0,i;    printf(&quot;please input c,d(c&gt;2):\n&quot;);    scanf( &quot;%ld,%ld&quot;,&amp;c,&amp;d);    //这里可以约束    for(i=c;i&lt;=d-2;i++)    {        //这里也可以约束        if(Isprime(i)&amp;&amp;Isprime(i+2))        {            printf(&quot;(%ld,%ld)\n&quot;,i,i+2);            total++;            i=i+2;        }    }    printf(&quot;total=%d\n&quot;,total);    return 0;}int Isprime(long x){    int i=2;    for(i=2;i&lt;x;i++)    {        if(x%i==0)        {            return 0;        }    }    return 1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T11</title>
    <link href="/2020/04/24/CprogrammingT11/"/>
    <url>/2020/04/24/CprogrammingT11/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T11"><a href="#C语言编程T11" class="headerlink" title="C语言编程T11"></a>C语言编程T11</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><img src="/img/c_correction/141.1.png" srcset="/img/loading.gif" alt=""><br>定积分的几何意义！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/141.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;float Integral(float (*f)(float), float a, float b);float y1(float x);float y2(float x);int main(){    printf(&quot;y1=%f\ny2=%f\n&quot;,Integral(y1,0,1),Integral(y2,0,3));    return 0;}float y1(float x){    //printf(&quot;y1=%f\n&quot;,1+x*x);    return 1+x*x;}float y2(float x){    return x/(1+x*x);}float Integral(float (*f)(float), float a, float b){    int n=100;    int i=1;    double s=0;    for(i=1;i&lt;=100;i++)    {        s+=((b-a)/n)*f(i*(b-a)/n);        //printf(&quot;s=%f\n&quot;,s);    }    return s;}*/#include &lt;stdio.h&gt;float Fun1(float x);float Fun2(float x);float Integral(float (*f)(float), float a, float b);int main(){    float y1, y2;    y1 = Integral(Fun1, 0.0, 1.0);    y2 = Integral(Fun2, 0.0, 3.0);    printf(&quot;y1=%f\ny2=%f\n&quot;, y1, y2);    return 0;}/*  函数功能：计算函数1+x*x的函数值 */float Fun1(float x){    return  1 + x * x;}/*  函数功能：计算函数x/(1+x*x)的函数值 */float Fun2(float x){    return x / (1 + x * x);}/*    函数功能：用梯形法计算函数的定积分 */float Integral(float (*f)(float), float a, float b){    float s, h;    int n = 100, i;    s = ((*f)(a) + (*f)(b)) / 2;    h = (b - a) / n;    for (i = 1; i &lt; n; i++)    {        s += (*f)(a + i * h);    }    return s * h;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T10</title>
    <link href="/2020/04/23/CprogrammingT10/"/>
    <url>/2020/04/23/CprogrammingT10/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T10"><a href="#C语言编程T10" class="headerlink" title="C语言编程T10"></a>C语言编程T10</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>floor()函数的应用:向下取整函数！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/129.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;float a[5] = {2.33, 2.56, 2.65, 2.66, 2.30};float t(float x, int n);float t(float x, int n){    float x1, x2;    int i;    for (x1 = x, i = 0; i &lt; n - 1; i++)        x1 *= 10.0;    printf(&quot;x1=%f\n&quot;,x1);    x2 = floor((double)x1);     printf(&quot;x2=%f\n&quot;,x2);    x1 = floor((double)(x1 - x2) * 10);    if (x1 &gt;= 5)        x2 += 1;    for (i = 0; i &lt; n - 1; i++)        x2 /= 10.0;    return x2;}int main(){    int i;    printf(&quot;Old array:\n&quot;);    for (i = 0; i &lt; 5; i++)        printf(&quot;a[%d]=%.3f\t&quot;, i, a[i]);    printf(&quot;\nnew array:\n&quot;);    for (i = 0; i &lt; 5; i++)        printf(&quot;a[%d]=%.2f\t&quot;, i, t(a[i], 2));    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T9</title>
    <link href="/2020/04/21/CprogrammingT9/"/>
    <url>/2020/04/21/CprogrammingT9/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T9"><a href="#C语言编程T9" class="headerlink" title="C语言编程T9"></a>C语言编程T9</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>注意英语的语法规范，i have a apple….太难了，注意名称前可能有冠词！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/108.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>##include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int Length(char p[]);int IsAllDigit(char p[]);int main(){    char str[N];    int is;    printf(&quot;Please input a string:&quot;);    gets(str);    printf(&quot;The string has %d characters.\n&quot;,Length(str));    is=IsAllDigit(str);    if(is)    {        printf(&quot;The string is a digit string.&quot;);    }    else    {        printf(&quot;The string is not a digit string.&quot;);    }    return 0;}int Length(char p[]){    int i;    for(i=0;p[i]!=&#39;\0&#39;;i++);    return i;}int IsAllDigit(char p[]){    int i;    for(i=0;p[i]!=&#39;\0&#39;;i++)    {        if(p[i]&lt;&#39;0&#39;||p[i]&gt;&#39;9&#39;)        {            return 0;        }    }    return 1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T6</title>
    <link href="/2020/04/19/CorrectionT6/"/>
    <url>/2020/04/19/CorrectionT6/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T6"><a href="#C语言改错T6" class="headerlink" title="C语言改错T6"></a>C语言改错T6</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>字符串赋值:<strong>‘\0’也占字符数组一个字节</strong><br>char str[6]={‘C’\,’h’\,’i’\,’n’\,’a’\,’\0’};<br>char str[]={‘C’\,’h’\,’i’\,’n’\,’a’\,’\0’};<br>char str[]=”China”;<br>char *ptr=”China”;</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/92.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>strcpy()也可以用来字符串赋值</p><pre><code>#include &lt;stdio.h&gt;main(){    int i = 0;    char str[6] = {&#39;C&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;\0&#39;}, str1[6] , *ptr, *ptr1, *ptr2 ;    while (str[i] != &#39;\0&#39;)    {        putchar(str[i]);        i++;    }    ptr=str;    scanf(&quot;%s&quot;, ptr);    puts(ptr);    ptr1 = str;    puts(ptr1);    ptr2 = &quot;China&quot;;    puts(ptr2);    char str2[] = &quot;China&quot;;    printf(&quot;%s&quot;, str2);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T8</title>
    <link href="/2020/04/18/CprogrammingT8/"/>
    <url>/2020/04/18/CprogrammingT8/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T8"><a href="#C语言编程T8" class="headerlink" title="C语言编程T8"></a>C语言编程T8</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>注意英语的语法规范，1st,11th,21st…</strong><br>判断错误输入最好判断<strong>全面</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/87.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/87.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char month[13][20]={  &quot;none&quot;,&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,  &quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;};int main(){    int year,day,mon;    printf(&quot;Enter date (mm/dd/yy):&quot;);    scanf(&quot;%d/%d/%d&quot;,&amp;mon,&amp;day,&amp;year);    if(day&gt;31||day&lt;1||mon&gt;12||mon&lt;1)    {        printf(&quot;Input error!\n&quot;);    }    else    {        printf(&quot;Dated this %d&quot;,day);        switch(day)        {            case 1:            case 21:            case 31:                printf( &quot;st&quot;);                break;            case 2:            case 22:                printf( &quot;nd&quot;);                break;            case 3:            case 23:                printf( &quot;rd&quot;);                break;            default:                printf( &quot;th&quot;);        }        printf(&quot; day of %s&quot;,month[mon]);        printf(&quot;, 19%.2d.\n&quot;,year);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T7</title>
    <link href="/2020/04/18/CprogrammingT7/"/>
    <url>/2020/04/18/CprogrammingT7/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T7"><a href="#C语言编程T7" class="headerlink" title="C语言编程T7"></a>C语言编程T7</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>看清题目要求和计算公式</strong><br>求对角线之和,注意可能会重叠</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/82.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5int main(){    int a[N][N],i,j,s=0,t;    printf(&quot;Input a 5*5 matrix\n&quot;);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            scanf(&quot;%d&quot;,&amp;a[i][j]);        }        s+=a[i][i]+a[i][N-i-1];    }    /*for(i=0;i&lt;N;i++)    {    }*/    printf(&quot;sum=%5d\n&quot;,s-a[2][2]);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T5</title>
    <link href="/2020/04/17/CorrectionT5/"/>
    <url>/2020/04/17/CorrectionT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T5"><a href="#C语言改错T5" class="headerlink" title="C语言改错T5"></a>C语言改错T5</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>分清:<br>dstStr是目的，即要输出的<br>srcStr是源<br>故字符串是dstStr+srcStr,即srcStr在dstStr后面<br><strong>指针地址的变化与指针指向值的变化！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/79.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 80void MyStrcat(char *dstStr, char *srcStr);main() {    char s[N], t[N];    printf(&quot;Input a string:\n&quot;);    gets(s);    printf(&quot;Input another string:\n&quot;);    gets(t);    MyStrcat(s, t);    printf(&quot;Concatenate results:%s\n&quot;, s);}void MyStrcat(char *dstStr, char *srcStr) {    while (*dstStr != &#39;\0&#39;)    {        dstStr++;    }    while (*srcStr != &#39;\0&#39;)    {        *dstStr = *srcStr;        srcStr++;        dstStr++;    }    //分清楚指针改变地址和改变其指向的值    *dstStr=&#39;\0&#39;;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T6</title>
    <link href="/2020/04/17/CprogrammingT6/"/>
    <url>/2020/04/17/CprogrammingT6/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T6"><a href="#C语言编程T6" class="headerlink" title="C语言编程T6"></a>C语言编程T6</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>变量迭代，阶乘计算int型可能会溢出，最好使用double。<br><strong>注:考虑到各种情况，包括:取0、-1等边界测试时，其余输出是否会有矛盾!!!</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/77.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;//考虑为0的情况int main(){    double x,t,t1=1,sum=0,t2,esp;    int n=3,count=1;    printf(&quot;Enter x &amp; eps:&quot;);    scanf(&quot;%lf%lf&quot;,&amp;x,&amp;esp);    if(x!=0)    {        t2=sum=x;        do        {            t1=-t1*n*(n-1);            n+=2;            t2=t2*x*x;            t=t2/t1;            sum+=t;            count++;        }while(fabs(t)&gt;=esp);    }    printf(&quot;sin(%f)=%f\n&quot;,x,sin(x));    printf(&quot;%d,sin(%f)=%f\n&quot;,count,x,sum);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inspiration1.0</title>
    <link href="/2020/04/15/Whimsy1/"/>
    <url>/2020/04/15/Whimsy1/</url>
    
    <content type="html"><![CDATA[<h1 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h1><p><strong>This is my idea,I hope one day i can fulfil it.</strong></p><hr><h2 id="Project-And-Description"><a href="#Project-And-Description" class="headerlink" title="Project And Description"></a>Project And Description</h2><p>过年前后金价会上升 : 可建立对应信息库+求解最大子序列<br>背诵提醒 : 根据记忆曲线(艾宾浩斯遗忘曲线)提醒用户背诵对应内容<br>云网盘 : 通过云服务器构建一个类似属于自己的网盘<br>高校图表 : 面对高考生的高校报考信息推荐，Python爬虫+大数据(高校分数线+报录比)+Python可视化(生成对应的报表+不同维度)<br>彩虹屁生成器 : 花式夸人+英语夸人，自然语言处理</p>]]></content>
    
    
    <categories>
      
      <category>Whimsy</category>
      
      <category>Procject</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Project</tag>
      
      <tag>Inspiration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T5</title>
    <link href="/2020/04/15/CprogrammingT5/"/>
    <url>/2020/04/15/CprogrammingT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T5"><a href="#C语言编程T5" class="headerlink" title="C语言编程T5"></a>C语言编程T5</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>找规律，一一列举即可<br><strong>注:是否满足所有情况!!!</strong><br>要从最小值开始列举<br>不然有可能运算不了全部解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/60.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找最小、才能求解全部情况</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100//要从最小的开始计算int IsInArray(int a[],int n,int x);void ClearArray(int a[],int n,int x);int GetMinArray(int a[],int n);int main(){    int i,n,a[N]={-1},change=0,j,m=0;    printf(&quot;Input n:&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;Input card numbers:&quot;);    for(i=0;i&lt;n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);    }    for(i=0;i&lt;n;i++)    {        m=GetMinArray(a,n);        //printf(&quot;a[m]=%d\n&quot;,m);        if(m!=-1&amp;&amp;IsInArray(a,n,m+1)&amp;&amp;IsInArray(a,n,m+2))        {            ClearArray(a,n,m+2);            ClearArray(a,n,m+1);            ClearArray(a,n,m);            /*for(j=0;j&lt;n;j++)            {                printf(&quot;%d &quot;,a[j]);            }            printf(&quot;\n&quot;);*/            change++;        }    }    printf(&quot;Exchanged:%d\n&quot;,change);    return 0;}int IsInArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            return 1;        }    }    return 0;}void ClearArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            a[i]=-1;            break;        }    }}int GetMinArray(int a[],int n){    int i,j,min=-1;    for(i=0;i&lt;n;i++)    {        if(a[i]!=-1)        {            min=a[i];           // printf(&quot;min=%d\n&quot;,min);            for(j=0;j&lt;n;j++)            {                if(a[j]!=-1&amp;&amp;min&gt;a[j])                {                    min=a[j];                }            }        }        else        {            i++;        }    }    return min;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T4</title>
    <link href="/2020/04/13/CorrectionT4/"/>
    <url>/2020/04/13/CorrectionT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T4"><a href="#C语言改错T4" class="headerlink" title="C语言改错T4"></a>C语言改错T4</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>指针数组要初始化<br><strong>指针都要初始化</strong><br>认真检查代码正确性:for(里面),数组交换位置,while();</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/39.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include  &lt;stdio.h&gt;#include &lt;string.h&gt;#define   MAX_LEN  10#define   N         150void SortString(char *ptr[], int n);main(){    int    i, n;    char   str[N][MAX_LEN],*pStr[N];    printf(&quot;How many countries?\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    getchar();    printf(&quot;Input their names:\n&quot;);    for (i=0; i&lt;n; i++)    {        pStr[i]=str[i];        gets(pStr[i]);        //printf(&quot;sr=%s\n&quot;,pStr[i]);    }    SortString(pStr,n);    printf(&quot;Sorted results:\n&quot;);    for (i=0; i&lt;n; i++)    {        puts(pStr[i]);    }}void SortString(char *ptr[], int n){    int    i, j;    char  *temp;    for (i=0; i&lt;n-1; i++)    {        for (j = i+1; j&lt;n; j++)        {            if (strcmp(ptr[i],ptr[j])&gt;0)            {                temp = ptr[i];                ptr[i] = ptr[j];                ptr[j] = temp;            }        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T4(妙)</title>
    <link href="/2020/04/13/CprogrammingT4/"/>
    <url>/2020/04/13/CprogrammingT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T4-妙"><a href="#C语言编程T4-妙" class="headerlink" title="C语言编程T4(妙)"></a>C语言编程T4(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>知规律，且有限，可迭代暴力破解</p><h3 id="思路一-回溯"><a href="#思路一-回溯" class="headerlink" title="思路一:回溯"></a>思路一:回溯</h3><p>只要将2、3、4、5放在不同位置,满足约束条件即可<br>又因2,3,4,5有规律,可递增尝试，递减回溯<br>所以找到回溯判定条件以及相应操作即可<br>此法较复杂</p><h3 id="思路二-穷举-正向思维"><a href="#思路二-穷举-正向思维" class="headerlink" title="思路二:穷举(正向思维)"></a>思路二:穷举(正向思维)</h3><p>因为只要将2、3、4、5放在四个不同位置，且其有规律<br>故采用四层或者三层for循环即可遍历所有可能解<br>所有只要输出满足约束条件的解即可<br><img src="/img/c_correction/45.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>何时回溯、何时穷举！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//强行穷举!!!#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6int main(){    int i, j, k, m, n, num;    int a[N];    a[0] = 1;    a[5] = 6;    num = 0;    printf(&quot;The possible table satisfied above conditions are:\n&quot;);    for (i = 2; i &lt;= 5; i++)        for (j = 2; j &lt;= 5; j++)            for (n = 2; n &lt;= 5; n++)                for (m = 2; m &lt;= 5; m++)                {                    a[1] = i;                    a[2] = j;                    a[3] = n;                    a[4] = m;                    if (a[2] &gt; a[1] &amp;&amp; a[4] &gt; a[3] &amp;&amp; a[4] &gt; a[1] &amp;&amp; a[1] != a[3] &amp;&amp; a[2] != a[3] &amp;&amp; a[2] != a[4])                    {                        num++;                        printf(&quot;\nNo.:%d&quot;, num);                        for (k = 0; k &lt; 6; k++)                        {                            if (k % 3 == 0)                                printf(&quot;\n&quot;);                            printf(&quot;%3d&quot;, a[k]);                        }                    }                }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T3(妙)</title>
    <link href="/2020/04/13/CprogrammingT3/"/>
    <url>/2020/04/13/CprogrammingT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T3-妙"><a href="#C语言编程T3-妙" class="headerlink" title="C语言编程T3(妙)"></a>C语言编程T3(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一-暴力破解-正向思维"><a href="#思路一-暴力破解-正向思维" class="headerlink" title="思路一:暴力破解(正向思维)"></a>思路一:暴力破解(正向思维)</h3><p>不断尝试各种数字,逐一尝试<br>但是由于n不确定,所以不知道要嵌套多少for和准备多少临时变量<br>故不可使用穷举法</p><h3 id="思路二-回溯-逆向思维"><a href="#思路二-回溯-逆向思维" class="headerlink" title="思路二:回溯(逆向思维)"></a>思路二:回溯(逆向思维)</h3><p><strong>从后往前观察思考，找到其规律</strong><br>采用数组,从后往前,逐一尝试,不符或者满足则采用不同的回溯，直至得出所有解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/42.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找规律 : 正向、逆向、解中有规律</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 10int main(){    int i[N];    int sum,n,total,k,flag=0,count=0;    printf(&quot;Please enter requried terms (&lt;=10):&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf( &quot;                             their sum:&quot;);    scanf(&quot;%d&quot;,&amp;total);    sum=0;    k=n;    //从后往前推导    i[n]=1;    printf(&quot;There are following possible series:\n&quot;);    while(1)    {        if(sum+i[k]&lt;total)        {            if(k&lt;=1)            {                i[1]=total-sum;                flag=1;            }            else            {                sum+=i[k];                k--;                //从最小值开始往前赋值                i[k]=i[k+1];                continue;                //继续while循环判断            }        }        //sum在中间已经大于可total        else if(sum+i[k]&gt;total||k!=1)        {            //想办法回溯            //减去上一个sum加的i[k]            sum-=i[++k];            flag=0;        }        else//sum+i[k]==total&amp;&amp;k==1        {            flag=1;        }        if(flag)        {             printf(&quot;[%d]:&quot;,++count);            for(flag=1;flag&lt;=n;++flag)                printf(&quot;%d&quot;,i[flag]);            printf(&quot;\n&quot;);        }        //判断i[n]是否已经变化到极致        if(++k&gt;n)        {            break;        }        //往后回溯        sum-=i[k];        //不断试探        i[k]++;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T2</title>
    <link href="/2020/04/12/CprogrammingT2/"/>
    <url>/2020/04/12/CprogrammingT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T2"><a href="#C语言编程T2" class="headerlink" title="C语言编程T2"></a>C语言编程T2</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="判断素数可以通过sqrt-或者x-2来降低循环次数"><a href="#判断素数可以通过sqrt-或者x-2来降低循环次数" class="headerlink" title="判断素数可以通过sqrt()或者x/2来降低循环次数"></a>判断素数可以通过sqrt()或者x/2来降低循环次数</h3><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用long long或者unsigned long 来存储2的i次幂<br>计算2的i次幂可以迭代计算,节省时间</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用double来存储2的i次幂<br>注 :</p><ol><li><p>pow()返回的double型，所以将其转换为int型时容易有精度误差，容易出错！！！<br>所以常使用while循环迭代计算<br>2.浮点型(float,double)不可以进行取余运算<br>故判断是否整除可以通过整型的除法特性计算(1/2==0)<br>即:x/i == (long long)(x/i)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/33.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>切记 : pow()的精度误差，一般在int型中不用！！！<br>``` </p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdlib.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <math.h></h1><p>int IsPrime(double x);<br>int main()<br>{<br> int i,count=0,n;<br> double s=0;<br> printf(“Input n:\n”);<br> scanf(“%d”,&amp;n);<br> for(i=2;i&lt;=n;i++)<br> {</p><pre><code> s=pow(2,i)-1; if(IsPrime(s)==1) {     printf(&quot;2^%d-1=%.0f\n&quot;,i,s);     count++; }</code></pre><p> }</p><p> printf(“count=%d\n”,count);<br> return 0;<br>}<br>int IsPrime(double x)<br>{<br> int i;<br> for(i=2;i&lt;sqrt(x);i++)<br> {</p><pre><code> if(x/i == (long long)(x/i)) {     return 0; }</code></pre><p> }<br> return 1;<br>}</p></li></ol><p>```</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T3</title>
    <link href="/2020/04/11/CorrectionT3/"/>
    <url>/2020/04/11/CorrectionT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T3"><a href="#C语言改错T3" class="headerlink" title="C语言改错T3"></a>C语言改错T3</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><h3 id="分清"><a href="#分清" class="headerlink" title="分清:"></a>分清:</h3><p>1.指针数组:  int *p[4]<br><strong>常用于字符串交换,因为相比strcpy()更加节省时间和空间</strong><br><strong>故使用指针数组进行交换效率更高索引技术、索引排序</strong></p><blockquote><p>函数中使用:<br>void Fun(int *p[M]);<br>Fun(p);</p></blockquote><p>2.二维数组的 行指针 :  int (*p)[4] </p><blockquote><p>p[i]==*(p+i):也就是p[i]的地址！！！<br>p[i][j] == *(p[i]+j) == *(*(p+i)+j) == (*(a+i))[j]<br>&amp;p[i][j] == p[i]+j == *(p+i)+j<br>函数中使用:<br>void Fun(int (*p)[M]);<br>Fun(p);//p == p[0] == p[0]的地址</p></blockquote><p>3.二维数组的列指针 :  int *p; p=*a</p><blockquote><p>p=*a &lt;==&gt; p=a[0] &lt;==&gt; p=&amp;a[0][0]<br>a[i][j]=*(p+i*n+j)<br>&amp;a[i][j]=p+i*n+j<br>函数中使用:<br>void Fun(int *p);<br>Fun(*p);</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/28.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:指针数组的妙用！！！</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;void Input(char *p[], int n);void Sort(char *p[], int n);void Print(char *p[], int n);int main(){                    char str[20][40];    char *pstr[20];    int i, n;    printf(&quot;Input n(n&lt;=20):\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    //注意要清空缓冲区里的空格    getchar();    for (i = 0; i &lt; n; i++)    {                  //指针数组要初始化        pstr[i] = str[i];           //2    }    Input(pstr, n);    Sort(pstr, n);    printf(&quot;Results:\n&quot;);    Print(pstr, n);    return 0;}                void Input(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        gets(p[i]);    }}                void Sort(char *p[], int n){                    char *t;                              //1    int i, j;    for (i = 0; i &lt; n - 1; i++)    {                        //注:j=i+1而不是1        for (j = i + 1; j &lt; n; j++)        {                            if (strcmp(p[j], p[i]) &lt; 0)    //2            {                       //直接用指针数组来简化strcpy()                t = p[i];                p[i] = p[j];                p[j] = t;            }        }    }}                void Print(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        printf(&quot;%s\n&quot;, p[i]);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T2</title>
    <link href="/2020/04/11/CorrectionT2/"/>
    <url>/2020/04/11/CorrectionT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T2"><a href="#C语言改错T2" class="headerlink" title="C语言改错T2"></a>C语言改错T2</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br><strong>换行、空格到底要不要???</strong>(没有特殊提示应该不用吧~now)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/27.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>多了一个换行~</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int mon[][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},    {0,31,29,31,30,31,30,31,31,30,31,30,31},};int  DayofYear(int year, int month, int day);void  MonthDay(int year, int yearDay, int *pMonth, int *pDay);int main(){    int choice,year,month,day,yearday,pmonth,pday;    printf(&quot;1. year/month/day -&gt; yearDay\n&quot;);    printf(&quot;2. yearDay -&gt; year/month/day\n&quot;);    printf(&quot;3. Exit\n&quot;);    //这里不用换行了！！！    printf(&quot;Please enter your choice:&quot;);    scanf(&quot;%d&quot;,&amp;choice);    switch(choice)    {    case 1:        printf(&quot;Please enter year, month, day:&quot;);        scanf(&quot;%d,%d,%d&quot;,&amp;year,&amp;month,&amp;day);        yearday=DayofYear(year,month,day);        printf(&quot;yearDay = %d\n&quot;,yearday);        break;    case 2:        printf(&quot;Please enter year, yearDay:&quot;);        scanf(&quot;%d,%d&quot;,&amp;year,&amp;yearday);        MonthDay(year,yearday,&amp;pmonth,&amp;pday);        printf(&quot;month = %d,day = %d\n&quot;,pmonth,pday);        break;    case 3:        return 0;    }    return 0;}int  DayofYear(int year, int month, int day){    int i,leap,d=day;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    for(i=0;i&lt;month;i++)    {        d+=mon[leap][i];    }    return d;}void  MonthDay(int year, int yearDay, int *pMonth, int *pDay){    int i=0,leap;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    while(1)    {        yearDay-=mon[leap][i];        i++;        if(yearDay&lt;mon[leap][i])        {            break;        }    }    *pMonth=i;    *pDay=yearDay;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T1</title>
    <link href="/2020/04/11/CprogrammingT1/"/>
    <url>/2020/04/11/CprogrammingT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T1"><a href="#C语言编程T1" class="headerlink" title="C语言编程T1"></a>C语言编程T1</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用gets()/scanf()直接输入字符串<br>1.考虑符号和数字的分离、判断输入是否正确<br>2.采用栈或者队列来进行运算<br>综上所述:较为复杂！！！</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用getchar()直接输入字符<br>1.一个一个字符输入，故要进行分类计算(if),判断何时计算、何时停止<br>2.通过代码顺序实现类似栈的操作<br>可以一试！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/24.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心 : 在得到第二个运算符时，计算前一个运算符!!!</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    int num, num1, op;    char ch;    //用来计算最先输入的数    num = 0;//第一个数    num1 = 0;//第二个数    op = &#39;+&#39;;    do    {        ch = getchar();        if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        {        //将输入的字符12转换成数字12            num1 = num1 * 10 + (ch - &#39;0&#39;);        }        else        {        //计算前一个运算符!!!            if (op == &#39;+&#39;)            {                num = num + num1;            }            else if (op == &#39;-&#39;)            {                num = num - num1;            }            else if (op == &#39;*&#39;)            {                num = num * num1;            }            else if (op == &#39;/&#39;)            {                num = num / num1;            }            else            {                printf(&quot;错误的运算符：%c&quot;, op);                exit(0);            }         //不得不说...神奇         op = ch;         //初始化         num1 = 0;        }    }while (ch != &#39;=&#39;);    printf(&quot;%d&quot;, num);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T1</title>
    <link href="/2020/04/10/CorrectionT1/"/>
    <url>/2020/04/10/CorrectionT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T1"><a href="#C语言改错T1" class="headerlink" title="C语言改错T1"></a>C语言改错T1</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br>2.严格根据题目约束条件、<strong>理论结合实际</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/23.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/23.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int main(){    char str1[N],str2[N];    int i,j;    printf(&quot;\n输入字符串：&quot;  );    gets(str1);    i=j=0;    for(i=0;str1[i]!=&#39;\0&#39;;i++)    {    //什么叫元音字母！！！        if(str1[i]==&#39;e&#39;||str1[i]==&#39;o&#39;||str1[i]==&#39;a&#39;||str1[i]==&#39;i&#39;||str1[i]==&#39;u&#39;)        {            str2[j]=str1[i];            j++;        }    }    str2[j]=&#39;\0&#39;;    //还要输出这个！！！    printf(&quot;%s&quot;,str1);    printf(&quot;\n字符串中的元音字母是%s&quot;,str2);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用网站</title>
    <link href="/2020/04/10/web1.0/"/>
    <url>/2020/04/10/web1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Practical-websites"><a href="#Practical-websites" class="headerlink" title="Practical websites"></a>Practical websites</h1><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="图片海报"><a href="#图片海报" class="headerlink" title="图片海报 :"></a>图片海报 :</h4><p>创客贴 : <a href="https://www.chuangkit.com/templatecenter" target="_blank" rel="noopener">https://www.chuangkit.com/templatecenter</a></p><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩 :"></a>图片压缩 :</h4><p>Recompressor : <a href="https://recompressor.com/" target="_blank" rel="noopener">https://recompressor.com/</a><br>Squoosh : <a href="https://squoosh.app/" target="_blank" rel="noopener">https://squoosh.app/</a><br>Tingpng : <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><h4 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历 :"></a>个人简历 :</h4><p>超级简历 :  <a href="https://www.wondercv.com/" target="_blank" rel="noopener">https://www.wondercv.com/</a></p><h4 id="写作"><a href="#写作" class="headerlink" title="写作 :"></a>写作 :</h4><p>Get写作 : <a href="https://getgetai.com/" target="_blank" rel="noopener">https://getgetai.com/</a><br>Markdown编辑器 : <a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a><br>英语写作 : <a href="http://www.1checker.com/" target="_blank" rel="noopener">http://www.1checker.com/</a></p><h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图 :"></a>绘图 :</h4><p>Processon 支持流程图、思维导图\UML、网络拓扑图、组织结构图等 : <a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></p><h3 id="Study"><a href="#Study" class="headerlink" title="Study"></a>Study</h3><h4 id="论文"><a href="#论文" class="headerlink" title="论文 :"></a>论文 :</h4><p>Communications of the ACM : <a href="https://cacm.acm.org/" target="_blank" rel="noopener">https://cacm.acm.org/</a><br>中国知网 : <a href="https://www.cnki.net/" target="_blank" rel="noopener">https://www.cnki.net/</a><br>笔杆查重 : <a href="https://www.bigan.net/" target="_blank" rel="noopener">https://www.bigan.net/</a><br>Paperpass : <a href="https://www.paperpass.com/" target="_blank" rel="noopener">https://www.paperpass.com/</a></p><h4 id="视频"><a href="#视频" class="headerlink" title="视频 :"></a>视频 :</h4><p>中国大学MOOC : <a href="https://www.icourse163.org/" target="_blank" rel="noopener">https://www.icourse163.org/</a><br>慕课网-程序员 :  <a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com/</a><br>网易云课堂 : <a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a><br>网易公开课 : <a href="https://open.163.com/" target="_blank" rel="noopener">https://open.163.com/</a><br>爱课程 : <a href="https://sso.icourses.cn" target="_blank" rel="noopener">https://sso.icourses.cn</a><br>Coursera : <a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org/</a><br>盗盗盗 : <a href="https://ctokey.com/" target="_blank" rel="noopener">https://ctokey.com/</a></p><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网:"></a>科学上网:</h4><p>DogCould : <a href="https://www.ggjs.xyz/" target="_blank" rel="noopener">https://www.ggjs.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>Gadgets</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马3.0</title>
    <link href="/2020/04/10/Chess3.0/"/>
    <url>/2020/04/10/Chess3.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马3-0"><a href="#跳跳马3-0" class="headerlink" title="跳跳马3.0"></a>跳跳马3.0</h1><hr><p>进一步对跳跳马2.0程序输入和输出界面的优化:<br>1.添加了一些界面提示语句<br>2.进行了代码局部优化</p><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现:"></a>1.代码实现:</h2><hr><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 64int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col,n;    printf(&quot;输入顶点数目:\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;n=%d\n&quot;,n);    for(i=0;i&lt;n;i++)    {        b[i]=-1;        c[i]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            a[i][j]=0;        }    }    do    {        printf(&quot;请输入对应的边(x y 1)(输入一半即可,-1表示结束):\n&quot;);        scanf(&quot;%d%d&quot;,&amp;i,&amp;j);        scanf(&quot;%d&quot;,&amp;a[i][j]);        //printf(&quot;(%d,%d)=%d\n&quot;,i,j,a[i][j]);        //printf(&quot;res=%d\n&quot;,res);        a[j][i]=a[i][j];    }while(i!=-1);    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;n)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,n))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;n-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=n);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;n;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>只是完成了最基本的可视化界面。<br>查询理论上可以继续优化:<br>主要思路:<br>1.可以尝试使用邻接表来存储，节约存储空间，但是回溯是一个问题。<br>2.可以尝试使用动态规划，理论上应该满足优化子结构和重叠子问题。<br>3.可以进一步优化输入输出，目标:上传图片，使其自动化处理棋盘和生成对应的图:</p><blockquote><p>Think:<br>图像处理、模式识别、数据可视化</p><h4 id="未完待续-2020-4-10—-gt"><a href="#未完待续-2020-4-10—-gt" class="headerlink" title="未完待续(2020.4.10—&gt;)"></a>未完待续(2020.4.10—&gt;)</h4></blockquote>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马2.0</title>
    <link href="/2020/04/09/Chess2.0/"/>
    <url>/2020/04/09/Chess2.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马2-0"><a href="#跳跳马2-0" class="headerlink" title="跳跳马2.0"></a>跳跳马2.0</h1><hr><p>依旧是采用跳跳马1.0的思想；将棋盘中的马与小兵抽象成结点，结点的可达关系作为对应结点的边。</p><h2 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1.解决方法:"></a>1.解决方法:</h2><hr><h3 id="1-1-主要思想"><a href="#1-1-主要思想" class="headerlink" title="1.1 主要思想:"></a>1.1 主要思想:</h3><p>2.0用邻接矩阵来存储图，使用BFS(Breadth First Search)策略，并且采用数组来存储上一步经过的结点，故只要不满足约束条件时，利用此数组即可回溯到上一结点</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现:"></a>2.代码实现:</h2><hr><p>可以正确执行！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 14int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col;    for(i=0;i&lt;N;i++)    {        b[i]=-1;        c[N]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            a[i][j]=0;        }    }    do    {        scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;a[i][j]);    }while(i!=-1);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;N)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,N))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;N-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=N);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;N;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>对应的界面还未完善，只是实现了最核心的功能<br>代码的时间复杂度和空间复杂度应该可以进一步优化。</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马1.0</title>
    <link href="/2020/04/08/Chess1.0/"/>
    <url>/2020/04/08/Chess1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马1-0"><a href="#跳跳马1-0" class="headerlink" title="跳跳马1.0"></a>跳跳马1.0</h1><h2 id="1-游戏介绍"><a href="#1-游戏介绍" class="headerlink" title="1.游戏介绍:"></a>1.游戏介绍:</h2><hr><p>根据国际象棋的规则和棋盘大小，并且遵守马的行走规则，使用马将棋盘中的所有小兵都吃完，即通关计分。<br>具体游戏界面如下图:<br><img src="/img/Chessimg/chess1.jpg" srcset="/img/loading.gif" alt=""></p><center>游戏界面 </center><h2 id="2-实际问题"><a href="#2-实际问题" class="headerlink" title="2.实际问题:"></a>2.实际问题:</h2><hr><p>随着通过的关卡越多，小兵的数量也越多，而马只要走错一步就直接结束游戏，因此在每一步都必须十分正确，所以有必要使用程序来辅助玩家选择最恰当的路径，进而通关</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法:"></a>3.解决方法:</h2><hr><h3 id="3-1使用到的相关知识"><a href="#3-1使用到的相关知识" class="headerlink" title="3.1使用到的相关知识:"></a>3.1使用到的相关知识:</h3><p>关键词 : 抽象、图、DFS、BFS、栈、回溯、哈密顿图</p><blockquote><p>《离散数学引论》:<br>哈密顿图 : 存在一条哈密顿圈<br>哈密顿路 : 图中存在一条经过所有节点并且不重复的路</p><h3 id="3-2-主要思想"><a href="#3-2-主要思想" class="headerlink" title="3.2 主要思想:"></a>3.2 主要思想:</h3><p>将马和小兵抽象成图上的结点，如果小兵与小兵之间或者小兵与马之间满足马的行走规则,则将其连线，从而形成一张图，进而转换成求图上的哈密顿路问题。<br>如下图:<br><img src="/img/Chessimg/chess2.jpg" srcset="/img/loading.gif" alt=""><br>寻找一条哈密顿路:<br><img src="/img/Chessimg/chess3.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现:"></a>4.代码实现:</h2><p>使用邻接矩阵来存储图，采用BFS策略来进行路径的选择，通过节点间的度的关系来进行回溯约束，并且采用栈来存储之前遍历过的结点。<br>``` </p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<stdlib.h></h1><p>//邻接矩阵结构<br>typedef int VertexType;<br>typedef int EdgeType;</p></blockquote><h1 id="define-MAX-20"><a href="#define-MAX-20" class="headerlink" title="define MAX 20"></a>define MAX 20</h1><h1 id="define-INFINITY-65535"><a href="#define-INFINITY-65535" class="headerlink" title="define INFINITY 65535"></a>define INFINITY 65535</h1><h1 id="define-TRUE-1"><a href="#define-TRUE-1" class="headerlink" title="define TRUE 1"></a>define TRUE 1</h1><h1 id="define-FALSE-0"><a href="#define-FALSE-0" class="headerlink" title="define FALSE 0"></a>define FALSE 0</h1><p>typedef int Boole;  //布尔类型 存储TRUE FALSE<br>Boole visited[MAX];    //访问标志数组<br>Boole Svisited[MAX];   //已经入栈标志<br>int Stack[MAX];//用来存放图的顶点<br>    int top=0;//栈顶<br>typedef struct<br>{<br>    VertexType vexs[MAX];   //顶点表<br>    EdgeType arc[MAX][MAX];   //邻接矩阵 可看作边表<br>    int numVertexes,numEdges;<br>    //int GraphType;  //图的类型  无向0,有向1<br>}MGraph;<br>//循环队列<br>typedef struct{<br>int data[10];<br>int rear,front;<br>}Quene,*pQueue;</p><p>void init(pQueue q){<br>    q-&gt;front=0;<br>    q-&gt;rear=0;<br>}</p><p>void destroyQueue(pQueue q){<br>    free(q);<br>    q=NULL;<br>}<br>void add(pQueue q,int x){<br>    if((q-&gt;rear+1)%10==q-&gt;front){<br>        printf(“overflow”);<br>        return ;<br>    }else{<br>        q-&gt;rear=(q-&gt;rear+1)%10;<br>        q-&gt;data[q-&gt;rear]=x;<br>        printf(“入队成功\n”);<br>    }<br>}<br>int  DeQueue(pQueue q){<br>    int e=0;<br>    if(q-&gt;front==q-&gt;rear){<br>        printf(“null”);<br>        return e;<br>    }else{<br>        q-&gt;front=(q-&gt;front+1)%10;<br>       // printf(“q-&gt;front=%d\n”,q-&gt;front);<br>        printf(“删除的元素是:%d\n”,q-&gt;data[q-&gt;front]);<br>        e=q-&gt;data[q-&gt;front];</p><pre><code>}return e;</code></pre><p>}</p><p>void traverseQuene(pQueue q){<br>    int i=q-&gt;front;<br>    while(i!=q-&gt;rear){<br>        i=(i+1)%10;<br>        printf(“%d “,q-&gt;data[i]);<br>    }<br>    printf(“\n”);<br>}</p><p>//队长度<br>int QueueLength(pQueue q){<br>    return (q-&gt;rear)-(q-&gt;front)+10%10;<br>}<br>//构造图   有向图和无向图<br>void create(MGraph *G)<br>{<br>    int i,j,k,w;<br>    printf(“请输入顶点数,边数:\n”);<br>    scanf(“%d,%d”,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<br>    fflush(stdin);<br>    for(i=0;i<G->numVertexes;i++)     //建立顶点表<br>    {<br>        //printf(“\n第%d个顶点”,i);<br>        //scanf(“%c”,&amp;G-&gt;vexs[i]);<br>        //getchar();<br>        G-&gt;vexs[i]=i;<br>    }</p><pre><code>for(i=0;i&lt;G-&gt;numVertexes;i++)   //矩阵初始化    for(j=0;j&lt;G-&gt;numVertexes;j++)        G-&gt;arc[i][j]=INFINITY;for(k=0;k&lt;G-&gt;numEdges;k++){    printf(&quot;输入边（Vi,Vj）的上下标i,j：&quot;);    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    G-&gt;arc[i][j]=1;    //if(G-&gt;GraphType==0)      //此时为无向图   有向图与无向的区别就只是这一行代码的有无    G-&gt;arc[j][i]=G-&gt;arc[i][j];}</code></pre><p>}</p><p>void Output(MGraph *G)     //输出邻接矩阵<br>{<br>    int i,j,count=0;<br>    for(i=0;i<G->numVertexes;i++)<br>        printf(“\t%d”,G-&gt;vexs[i]);<br>    printf(“\n”);<br>    for(i=0;i<G->numVertexes;i++)<br>    {<br>        printf(“%4d”,G-&gt;vexs[i]);<br>        for(j=0;j<G->numVertexes;j++)<br>        {</p><pre><code>            printf(&quot;\t%d&quot;,G-&gt;arc[i][j]);            count++;            if(count%G-&gt;numVertexes==0)            printf(&quot;\n&quot;);    }}</code></pre><p> }</p><p>/*<br>//一次遍历全部顶点<br>void OneS(MGraph G){<br>    int i,j;<br>    //所有点标记为新点<br>    for(i=0;i&lt;G.numVertexes;i++){<br>        visited[i]=FALSE;<br>        Svisited[i]=FALSE;<br>        Stack[i]=-1;<br>    }<br>    Stack[0]=G.vexs[0];<br>    visited[0]=TRUE;//已经在栈中<br>    top=0;<br>    while(top!=G.numVertexes-1){<br>        for(i=1;i&lt;G.numVertexes;i++){<br>            printf(“i=%d G.arc[Stack[top]][i]=%d !visited[i]=%d !Svisited[i]=%d\n “,i,G.arc[Stack[top]][i],!visited[i],!Svisited[i]);<br>            if(G.arc[Stack[top]][i]!=INFINITY&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){//找邻接点<br>                PrintStack();<br>                top++;<br>                Stack[top]=G.vexs[i];<br>                visited[i]=TRUE;//此点已经入栈<br>            }<br>        }</p><pre><code>    if(i==G.numVertexes){        //退栈,表示此点不可达        Svisited[Stack[top]]=TRUE;        visited[Stack[top]]=FALSE;        Queue[rear]=Stack[top];//入队        rear++;        Stack[top]=-1;        top--;    }    printf(&quot;top=%d,G.numVertexes-1=%d\n&quot;,top,G.numVertexes-1);    if(rear-front==2){//出队        Svisited[Queue[front]]=FALSE;        front++;    }    printf(&quot;rear=%d\n&quot;,rear);}</code></pre><p>}*/</p><p>//打印栈<br>void PrintStack(){<br>    for(int i=0;i&lt;=top;i++){<br>        printf(“%d-&gt;”,Stack[i]);<br>    }<br>    printf(“&lt;\n”);<br>}</p><p>void PrintQueue(Queue Q){<br>    for(int i=0;i&lt;=top;i++){<br>            printf(“%d-&gt;”,Q-&gt;data[i]);<br>        }<br>        printf(“&lt;\n”);<br>}</p><p>//返回结点n的度<br>int NodeDu(MGraph G,int n){<br>    int count=0;<br>    for(int i=0;i&lt;G.numVertexes;i++){<br>        if(G.arc[n][i]==1){<br>            count ++;<br>        }<br>    }<br>    return count;<br>}<br>void PrintNodeDu(MGraph G){<br>    for(int i=0;i&lt;G.numVertexes;i++){<br>        printf(“顶点%d的度:%d”,i,NodeDu(G,i));<br>    }<br>}<br>void OnceSearch(MGraph G){<br>    int i,e;<br>    pQueue q=(pQueue)malloc(sizeof(Quene));//用来存放已经出栈的顶点<br>    //打印顶点<br>    for(i=0;i&lt;G.numVertexes;i++){<br>        printf(“顶点:%d\n”,G.vexs[i]);<br>        visited[i]=FALSE;//标记所有顶点都未被访问<br>        Svisited[i]=FALSE;//标记所有顶点都未被退栈<br>    }<br>    //栈,队初始化<br>    init(q);<br>    Stack[top]=G.vexs[0];<br>    //如果栈里元素=顶点数,则找到路径<br>    int Stop=0;//判断栈顶第二元素是否变化<br>    while((top+1)!=G.numVertexes){<br>        //找相邻结点<br>        for(i=1;i&lt;G.numVertexes;i++){<br>            if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){<br>                //记录栈顶第二元素</p><pre><code>            top++;            Stack[top]=G.vexs[i];            visited[i]=TRUE;        }    }     Stop=Stack[top-1];    printf(&quot;second STop=%d\n&quot;,Stop);     PrintStack();    //如果遍历所有相邻结点都没有找到合适结点,则退栈入队重新再找    if(0&lt;(top)&amp;&amp;(top+1)!=G.numVertexes){        //如果栈顶第二元素变化,说明已经退出第二层,则需要出队        add(q,Stack[top]);        Svisited[Stack[top]]=TRUE;        visited[Stack[top]]=FALSE;        printf(&quot;退栈结点:%d\n&quot;,Stack[top]);        top--;        traverseQuene(q);//打印队列        printf(&quot;此时队列元素个数为:%d\n&quot;,QueueLength(q));        printf(&quot;此时栈顶元素Stack[%d]=%d的度为:%d\n&quot;,top,Stack[top],NodeDu(G,Stack[top]));        if(QueueLength(q)==NodeDu(G,Stack[top])){            printf(&quot;进入删除队列:&quot;);            for(i=0;i&lt;NodeDu(G,Stack[top])-1;i++){                e=DeQueue(q);                Svisited[e]=FALSE;                visited[e]=FALSE;            }            /*add(q,Stack[top]);            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            printf(&quot;退栈结点:%d\n&quot;,Stack[top]);            top--;*/        }        printf(&quot;打印队列:&quot;);            traverseQuene(q);//打印队列            printf(&quot;此时可入栈结点:&quot;);            for(i=0;i&lt;G.numVertexes;i++){                if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                    printf(&quot; %d &quot;,G.vexs[i]);                }            }        printf(&quot;\ntop=%d\n&quot;,top);    }}</code></pre><p>}</p><p>int main()<br>{<br>    MGraph G;<br>    int i,j;<br>    //printf(“输入生成图的类型(无向图0/有向图1)：”);<br>    //scanf(“%d”,&amp;G.GraphType);<br>    create(&amp;G);<br>    printf(“邻接矩阵数据如下：\n”);<br>    Output(&amp;G);<br>    printf(“\n”);<br>    //PrintNodeDu(G);<br>    OnceSearch(G);<br>    printf(“\n图遍历完毕\n”);<br>    PrintStack();<br>    return 0;<br>}</p><p>```</p><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>代码功能没有实现，应该是回溯栈的选择和约束条件的问题，以后有机会在实现~</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TestMarkdown</title>
    <link href="/2020/04/07/first/"/>
    <url>/2020/04/07/first/</url>
    
    <content type="html"><![CDATA[<h1 id="这是H1标题"><a href="#这是H1标题" class="headerlink" title="这是H1标题"></a>这是H1标题</h1><p>&nbsp;&nbsp;如何缩进,这是空格….<br>以下可写内容<br>分割线</p><hr><h2 id="这是H2标题"><a href="#这是H2标题" class="headerlink" title="这是H2标题"></a>这是H2标题</h2><p>直接写？？？</p><h3 id="这是H3标题-故标题以此类推"><a href="#这是H3标题-故标题以此类推" class="headerlink" title="这是H3标题(故标题以此类推)"></a>这是H3标题(故标题以此类推)</h3><pre><code>$ hexo new &quot;My New Post&quot;代码部分这样写?</code></pre><p>添加链接<br>More info: <a href="https://github.com/YinGuoX" target="_blank" rel="noopener">MyGitHub</a><br>添加图片<br><img src="/img/avatar.png" srcset="/img/loading.gif" alt=""></p><center>如何居中</center><p>记得&lt;/center&gt;后要空一行</p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
      <category>Markdown基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
