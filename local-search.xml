<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习程序练习2:逻辑回归和正则化</title>
    <link href="/2020/07/08/ML_Andrew_Pex2_Logistic_Regression/"/>
    <url>/2020/07/08/ML_Andrew_Pex2_Logistic_Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习2-逻辑回归与正则化"><a href="#吴恩达机器学习程序练习2-逻辑回归与正则化" class="headerlink" title="吴恩达机器学习程序练习2:逻辑回归与正则化"></a>吴恩达机器学习程序练习2:逻辑回归与正则化</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex22391</p><h2 id="1-逻辑回归"><a href="#1-逻辑回归" class="headerlink" title="1.逻辑回归"></a>1.逻辑回归</h2><p>构建一个逻辑回归模型来预测学生是否被大学录取<br>假设你是大学相关的管理者，想通过申请学生两次测试的评分，来决定是否被录取，现在你拥有申请学生的可用于训练逻辑回归的训练样本集。<br>对于每一个样本：两次测试的评分与最后是否被录取结果</p><h3 id="1-1-数据可视化"><a href="#1-1-数据可视化" class="headerlink" title="1.1 数据可视化"></a>1.1 数据可视化</h3><pre><code class="lang-python">import numpy as npimport pandas as pdimport matplotlib.pyplot as plt</code></pre><pre><code class="lang-python">path = &#39;./andrew_ml_ex22391/ex2data1.txt&#39;data = pd.read_csv(path,header=None,names=[&#39;Exam 1&#39;,&#39;Exam 2&#39;,&#39;Admitted&#39;])data.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Exam 1</th>      <th>Exam 2</th>      <th>Admitted</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>34.623660</td>      <td>78.024693</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>30.286711</td>      <td>43.894998</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>35.847409</td>      <td>72.902198</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>60.182599</td>      <td>86.308552</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>79.032736</td>      <td>75.344376</td>      <td>1</td>    </tr>  </tbody></table></div><pre><code class="lang-python"># 获取Admitted为1的data所有的数据# pandas库中的isin()用于数据筛选# isin()接收一个列表，判断该列中元素是否在列表中positive = data[data[&#39;Admitted&#39;].isin([1])]negative = data[data[&#39;Admitted&#39;].isin([0])]# print(positive)fig,ax = plt.subplots(figsize=(12,8))ax.scatter(positive[&#39;Exam 1&#39;],positive[&#39;Exam 2&#39;],s = 50,c=&#39;b&#39;,marker=&#39;o&#39;,label=&#39;Admitted&#39;)ax.scatter(negative[&#39;Exam 1&#39;],negative[&#39;Exam 2&#39;],s=50,c=&#39;r&#39;,marker=&#39;x&#39;,label=&#39;Nor Admitted&#39;)ax.legend()ax.set_xlabel(&#39;Exam 1 Score&#39;)ax.set_ylabel(&#39;Exam 2 Score&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/lg6.png" srcset="/img/loading.gif" alt="png"></p><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h3><h4 id="1-2-1-sigmoid函数"><a href="#1-2-1-sigmoid函数" class="headerlink" title="1.2.1 sigmoid函数"></a>1.2.1 sigmoid函数</h4><p>逻辑回归函数 (选择的模型) (hypothesis函数) 为</p><script type="math/tex; mode=display">h_\theta=g(\theta^Tx)</script><p>g()代表一个常用的逻辑函数(logistic function) ，即 Sigmoid 函数(Sigmoid function)(Logistic function),公式为:</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}</script><p>所以合起来，得到的逻辑回归模型的假设函数为：</p><script type="math/tex; mode=display">h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}</script><pre><code class="lang-python"># 实现sigmoid函数def sigmoid(z):    return 1/(1+np.exp(-z))</code></pre><h4 id="1-2-2-代价函数和梯度"><a href="#1-2-2-代价函数和梯度" class="headerlink" title="1.2.2 代价函数和梯度"></a>1.2.2 代价函数和梯度</h4><p>代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)})log(1-h_\theta(x^{(i)}))]</script><p>梯度：</p><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial \theta_j}=\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>虽然这个梯度与线性回归的梯度一模一样，但是$h_\theta(x)$是不一样的！</p><pre><code class="lang-python"># 实现代价函数def cost(theta,X,y):    theta = np.matrix(theta)    X=np.matrix(X)    y = np.matrix(y)    first = np.multiply(-y,np.log(sigmoid(X*theta.T)))    second = np.multiply((1-y),np.log(1-sigmoid(X*theta.T)))    return np.sum(first-second)/(len(X))</code></pre><p>初始化X,y,$\theta$</p><pre><code class="lang-python"># 添加一列常数列data.insert(0,&#39;Ones&#39;,1)# 初始化X,y,thetacols = data.shape[1]X = data.iloc[:,0:cols-1]y = data.iloc[:,cols-1:cols]theta = np.zeros(3)# 转换类型X = np.array(X.values)y = np.array(y.values)# print(&quot;X为：&quot;)# print(X)# print(&quot;y为：&quot;)# print(y)</code></pre><pre><code class="lang-python"># 检查矩阵的维度X.shape,theta.shape,y.shape</code></pre><pre><code>((100, 3), (3,), (100, 1))</code></pre><pre><code class="lang-python"># 用初始theta来计算代价(验证正确性)cost(theta,X,y)</code></pre><pre><code>0.6931471805599453</code></pre><pre><code class="lang-python"># 实现梯度计算的函数(由于使用第三方库来计算theta，故不进行梯度下降)def gradient(theta,X,y):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    parameters = int(theta.ravel().shape[1])    grad = np.zeros(parameters)    # 迭代计算-------------------------------    error = sigmoid(X*theta.T)-y    for i in range(parameters):        term = np.multiply(error,X[:,i])        # 求解梯度        grad[i] = np.sum(term)/len(X)        # 梯度下降        # theta[0][i]=theta[0][i]-alpha*grad[i]    # ----------------------------------------    return grad</code></pre><h4 id="1-2-3-用工具库计算-theta-的值"><a href="#1-2-3-用工具库计算-theta-的值" class="headerlink" title="1.2.3 用工具库计算$\theta$的值"></a>1.2.3 用工具库计算$\theta$的值</h4><p>在之前的线性回归中，我们自己写代码实现梯度下降：代价函数、计算梯度、梯度下降。<br><br>此次，我们通过调用已有的库来进行梯度下降（即：不用自己定义迭代次数和步长，功能会直接告诉我们最优解。正如：Andrew Ng介绍的Octave的’fminunc’函数）。<br><br>在python中，可以使用scipy.optimize.fmin_tnc做同样的事情</p><pre><code class="lang-python">import scipy.optimize as optresult = opt.fmin_tnc(func=cost,x0=theta,fprime=gradient,args=(X,y))result</code></pre><pre><code>(array([-25.16131872,   0.20623159,   0.20147149]), 36, 0)</code></pre><pre><code class="lang-python"># 使用第三方库计算的结果带回代价函数计算cost(result[0],X,y)</code></pre><pre><code>0.20349770158947425</code></pre><pre><code class="lang-python"># 画出决策曲线plotting_x1 = np.linspace(30,100,100)plotting_h1 = ( - result[0][0]-result[0][1]*plotting_x1)/result[0][2]fig,ax = plt.subplots(figsize=(12,8))ax.plot(plotting_x1,plotting_h1,&#39;y&#39;,label = &#39;Prediction&#39;)ax.scatter(positive[&#39;Exam 1&#39;], positive[&#39;Exam 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Admitted&#39;)ax.scatter(negative[&#39;Exam 1&#39;], negative[&#39;Exam 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Not Admitted&#39;)ax.legend()ax.set_xlabel(&#39;Exam 1 Score&#39;)ax.set_ylabel(&#39;Exam 2 Score&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/lg26.png" srcset="/img/loading.gif" alt="png"></p><h4 id="1-2-4-评价逻辑回归模型"><a href="#1-2-4-评价逻辑回归模型" class="headerlink" title="1.2.4 评价逻辑回归模型"></a>1.2.4 评价逻辑回归模型</h4><p>在确定参数之后，可以使用这个模型来预测一个学生是否被录取</p><pre><code class="lang-python"># 实现h(x)def hfunc1(theta,X):    return sigmoid(np.dot(theta.T,X))hfunc1(result[0],[1,45,85])</code></pre><pre><code>0.776290625526598</code></pre><h5 id="评价-theta"><a href="#评价-theta" class="headerlink" title="评价$\theta$"></a>评价$\theta$</h5><p>看模型在训练集上的正确率怎么样。写一个predict的函数，给出数据以及参数后，会返回0或者1.然后在把这个priedict函数用于训练集上，看准确率怎样</p><pre><code class="lang-python"># 定义预测函数def predict(theta,X):    probability = sigmoid(X*theta.T)    return [1 if x &gt;= 0.5 else 0 for x in probability]</code></pre><pre><code class="lang-python"># 添加预测准确率theta_min = np.matrix(result[0])predictions = predict(theta_min,X)# zip()，打包成一个一个的元组correct = [1 if ((a==1 and b == 1) or (a == 0 and b==0)) else 0 for (a,b) in zip(predictions,y)]accuracy = (sum(map(int,correct))% len(correct))print(&#39;accuracy = {0}%&#39;.format(accuracy))</code></pre><pre><code>accuracy = 89%</code></pre><p>画出对应曲线(有缘再续)</p><h2 id="2-逻辑回归-正则化"><a href="#2-逻辑回归-正则化" class="headerlink" title="2.逻辑回归+正则化"></a>2.逻辑回归+正则化</h2><p>实现加入正则项来提升逻辑回归算法。<br><br>假设你是工厂的生产主管，你有一些芯片在两次测试中的测试结果，测试结果决定芯片是否接受或抛弃。有一些历史数据，可以帮助构建一个逻辑回归模型。</p><h3 id="2-1-数据可视化"><a href="#2-1-数据可视化" class="headerlink" title="2.1 数据可视化"></a>2.1 数据可视化</h3><pre><code class="lang-python">path = &#39;./andrew_ml_ex22391/ex2data2.txt&#39;data_init = pd.read_csv(path,header=None,names = [&#39;Test 1&#39;,&#39;Test 2&#39;,&#39;Accepted&#39;])data_init.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Test 1</th>      <th>Test 2</th>      <th>Accepted</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.051267</td>      <td>0.69956</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>-0.092742</td>      <td>0.68494</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>-0.213710</td>      <td>0.69225</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>-0.375000</td>      <td>0.50219</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>-0.513250</td>      <td>0.46564</td>      <td>1</td>    </tr>  </tbody></table></div><pre><code class="lang-python">positive2 = data_init[data_init[&#39;Accepted&#39;].isin([1])]negative2 = data_init[data_init[&#39;Accepted&#39;].isin([0])]fig,ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;],positive2[&#39;Test 2&#39;],s=50,c=&#39;b&#39;,marker=&#39;o&#39;,label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;],negative2[&#39;Test 2&#39;],s=50,c=&#39;r&#39;,marker=&#39;x&#39;,label=&#39;Rejected&#39;)ax.legend()ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/lg37.png" srcset="/img/loading.gif" alt="png"></p><p>如上图所示，这个数据集不可使用直线进行分割，而之前的逻辑回归只适用于线性的分割，故另想它法</p><h3 id="2-2-特征映射"><a href="#2-2-特征映射" class="headerlink" title="2.2 特征映射"></a>2.2 特征映射</h3><p>一种更好的使用数据集的方式是为每组数据创造更多的特征。所以我们为每一组$x_1,x_2$添加了最高到6次幂的特征</p><pre><code class="lang-python">degree = 6data2 = data_initx1 = data2[&#39;Test 1&#39;]x2 = data2[&#39;Test 2&#39;]data2.insert(3,&#39;Ones&#39;,1)for i in range(1,degree+1):    for j in range(0,i+1):        data2[&#39;F&#39;+str(i-j)+str(j)]=np.power(x1,i-j)*np.power(x2,j)data2.drop(&#39;Test 1&#39;,axis=1,inplace=True)data2.drop(&#39;Test 2&#39;,axis = 1,inplace=True)data2.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Accepted</th>      <th>Ones</th>      <th>F10</th>      <th>F01</th>      <th>F20</th>      <th>F11</th>      <th>F02</th>      <th>F30</th>      <th>F21</th>      <th>F12</th>      <th>...</th>      <th>F23</th>      <th>F14</th>      <th>F05</th>      <th>F60</th>      <th>F51</th>      <th>F42</th>      <th>F33</th>      <th>F24</th>      <th>F15</th>      <th>F06</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>1</td>      <td>0.051267</td>      <td>0.69956</td>      <td>0.002628</td>      <td>0.035864</td>      <td>0.489384</td>      <td>0.000135</td>      <td>0.001839</td>      <td>0.025089</td>      <td>...</td>      <td>0.000900</td>      <td>0.012278</td>      <td>0.167542</td>      <td>1.815630e-08</td>      <td>2.477505e-07</td>      <td>0.000003</td>      <td>0.000046</td>      <td>0.000629</td>      <td>0.008589</td>      <td>0.117206</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>1</td>      <td>-0.092742</td>      <td>0.68494</td>      <td>0.008601</td>      <td>-0.063523</td>      <td>0.469143</td>      <td>-0.000798</td>      <td>0.005891</td>      <td>-0.043509</td>      <td>...</td>      <td>0.002764</td>      <td>-0.020412</td>      <td>0.150752</td>      <td>6.362953e-07</td>      <td>-4.699318e-06</td>      <td>0.000035</td>      <td>-0.000256</td>      <td>0.001893</td>      <td>-0.013981</td>      <td>0.103256</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>1</td>      <td>-0.213710</td>      <td>0.69225</td>      <td>0.045672</td>      <td>-0.147941</td>      <td>0.479210</td>      <td>-0.009761</td>      <td>0.031616</td>      <td>-0.102412</td>      <td>...</td>      <td>0.015151</td>      <td>-0.049077</td>      <td>0.158970</td>      <td>9.526844e-05</td>      <td>-3.085938e-04</td>      <td>0.001000</td>      <td>-0.003238</td>      <td>0.010488</td>      <td>-0.033973</td>      <td>0.110047</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>1</td>      <td>-0.375000</td>      <td>0.50219</td>      <td>0.140625</td>      <td>-0.188321</td>      <td>0.252195</td>      <td>-0.052734</td>      <td>0.070620</td>      <td>-0.094573</td>      <td>...</td>      <td>0.017810</td>      <td>-0.023851</td>      <td>0.031940</td>      <td>2.780914e-03</td>      <td>-3.724126e-03</td>      <td>0.004987</td>      <td>-0.006679</td>      <td>0.008944</td>      <td>-0.011978</td>      <td>0.016040</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>1</td>      <td>-0.513250</td>      <td>0.46564</td>      <td>0.263426</td>      <td>-0.238990</td>      <td>0.216821</td>      <td>-0.135203</td>      <td>0.122661</td>      <td>-0.111283</td>      <td>...</td>      <td>0.026596</td>      <td>-0.024128</td>      <td>0.021890</td>      <td>1.827990e-02</td>      <td>-1.658422e-02</td>      <td>0.015046</td>      <td>-0.013650</td>      <td>0.012384</td>      <td>-0.011235</td>      <td>0.010193</td>    </tr>  </tbody></table><p>5 rows × 29 columns</p></div><h3 id="2-3-代价函数和梯度"><a href="#2-3-代价函数和梯度" class="headerlink" title="2.3 代价函数和梯度"></a>2.3 代价函数和梯度</h3><p>代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)})log(1-h_\theta(x^{(i)}))]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^{2}</script><p>注：$\theta_0$是不需要正则化，故下标从1开始</p><p>梯度的第j个元素的更新公式：</p><script type="math/tex; mode=display">\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]x_0^{(i)}</script><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]x_j^{(i)}+\frac{\lambda}{m}\theta_j</script><p>对j=1,2,…….n时的式子重新调整：</p><script type="math/tex; mode=display">\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]x_j^{(i)}</script><pre><code class="lang-python"># 实现正则化的代价函数def costReg(theta,X,y,learningRate):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    first = np.multiply(-y,np.log(sigmoid(X*theta.T)))    second = np.multiply((1-y),np.log(1-sigmoid(X*theta.T)))    reg = (learningRate/(2*len(X)))*np.sum(np.power(theta[:,1:theta.shape[1]],2))    return np.sum(first-second)/len(X)+reg</code></pre><pre><code class="lang-python"># 实现正则化的梯度函数def gradientReg(theta,X,y,learningRate):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    patameters = int(theta.ravel().shape[1])    grad = np.zeros(patameters)    error = sigmoid(X*theta.T)-y    for i in range(patameters):        term = np.multiply(error,X[:,i])        if i==0 :            grad[i] = np.sum(term)/len(X)        else :            grad[i] = (np.sum(term)/len(X))+((learningRate/len(X))*theta[:,i])    return grad</code></pre><pre><code class="lang-python"># 初始化X,y.thetacols = data2.shape[1]X2 = data2.iloc[:,1:cols]y2 = data2.iloc[:,0:1]theta2 = np.zeros(cols-1)# 类型转换X2 = np.array(X2.values)y2 = np.array(y2.values)# lambda设为1learningRate = 1</code></pre><pre><code class="lang-python"># 计算初始代价costReg(theta2,X2,y2,learningRate)</code></pre><pre><code>0.6931471805599454</code></pre><h4 id="2-3-1-使用工具库求解-theta-等参数"><a href="#2-3-1-使用工具库求解-theta-等参数" class="headerlink" title="2.3.1 使用工具库求解$\theta$等参数"></a>2.3.1 使用工具库求解$\theta$等参数</h4><pre><code class="lang-python">result2 = opt.fmin_tnc(func=costReg,x0=theta2,fprime=gradientReg,args=(X2,y2,learningRate))result2</code></pre><pre><code>(array([ 1.27271027,  0.62529965,  1.18111687, -2.01987399, -0.91743189,        -1.43166928,  0.12393228, -0.36553118, -0.35725403, -0.17516292,        -1.45817009, -0.05098418, -0.61558554, -0.27469165, -1.19271298,        -0.2421784 , -0.20603299, -0.04466178, -0.27778951, -0.29539513,        -0.45645982, -1.04319155,  0.02779373, -0.2924487 ,  0.0155576 ,        -0.32742405, -0.1438915 , -0.92467487]), 32, 1)</code></pre><p>最后，我们可以使用第1部分中的预测函数来查看我们的方案在训练数据上的准确度。</p><pre><code class="lang-python">theta_min = np.matrix(result2[0])predictions = predict(theta_min, X2)correct = [1 if ((a == 1 and b == 1) or (a == 0 and b == 0)) else 0 for (a, b) in zip(predictions, y2)]accuracy = (sum(map(int, correct)) % len(correct))print (&#39;accuracy = {0}%&#39;.format(accuracy))</code></pre><pre><code>accuracy = 98%</code></pre><h3 id="2-4-画出决策曲线"><a href="#2-4-画出决策曲线" class="headerlink" title="2.4 画出决策曲线"></a>2.4 画出决策曲线</h3><pre><code class="lang-python"># 预测函数h(x)def hfunc2(theta, x1, x2):    temp = theta[0][0]    place = 0    for i in range(1, degree+1):        for j in range(0, i+1):            temp+= np.power(x1, i-j) * np.power(x2, j) * theta[0][place+1]            place+=1    return temp</code></pre><pre><code class="lang-python"># 找出边界def find_decision_boundary(theta):    t1 = np.linspace(-1,1.5,1000)    t2 = np.linspace(-1,1.5,1000)    # 获取(t1,t2)这样的数组对    cordinates=[(x,y) for x in t1 for y in t2]    # print(&quot;cordinates是：\n{}&quot;.format(cordinates))    # 一个一个抽取(x.y)的数组对    x_cord,y_cord = zip(*cordinates)    # print(&quot;cx_cord,y_cord是：\n{}，{}&quot;.format(x_cord,y_cord))    h_val = pd.DataFrame({&#39;x1&#39;:x_cord,&#39;x2&#39;:y_cord})    print(&quot;h_val是：\n{}&quot;.format(h_val))    h_val[&#39;hval&#39;]=hfunc2(theta,h_val[&#39;x1&#39;],h_val[&#39;x2&#39;])    decision=h_val[np.abs(h_val[&#39;hval&#39;])&lt;2*10**-3]    return decision.x1, decision.x2</code></pre><pre><code class="lang-python"># 画图fig,ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;], positive2[&#39;Test 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;], negative2[&#39;Test 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Rejected&#39;)ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)x,y =find_decision_boundary(result2)plt.scatter(x, y, c=&#39;y&#39;, s=10, label=&#39;Prediction&#39;)ax.legend()plt.show()</code></pre><pre><code>h_val是：         x1        x20      -1.0 -1.0000001      -1.0 -0.9974972      -1.0 -0.9949953      -1.0 -0.9924924      -1.0 -0.989990...     ...       ...999995  1.5  1.489990999996  1.5  1.492492999997  1.5  1.494995999998  1.5  1.497497999999  1.5  1.500000[1000000 rows x 2 columns]</code></pre><p><img src="/img/ML_Andrew/lg55.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-5-改变-lambda-，观察决策曲线"><a href="#2-5-改变-lambda-，观察决策曲线" class="headerlink" title="2.5 改变$\lambda$，观察决策曲线"></a>2.5 改变$\lambda$，观察决策曲线</h3><h4 id="2-5-1-过拟合"><a href="#2-5-1-过拟合" class="headerlink" title="2.5.1 过拟合"></a>2.5.1 过拟合</h4><p>当$\lambda=0$可以得出，使正则化项为0，使得$\theta$值不受$\lambda$影响，从而特征过多，方差过高，出现过拟合(对每一个训练集样本都尽可能拟合)</p><pre><code class="lang-python">learningRate2 = 0result3 = opt.fmin_tnc(func=costReg, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate2))result3</code></pre><pre><code>(array([  13.21662791,   17.63904891,    5.27881592, -136.13732177,         -67.12242042,  -52.94668399, -147.43086589,  -91.68410686,         -38.38361129,    6.59822331,  495.35657992,  402.46736709,         511.3069028 ,  206.24695325,   66.55863181,  273.9167483 ,         304.90920777,  318.45935938,  157.30786853,   54.95286981,           1.80807367, -601.66243281, -692.5740057 , -962.14314287,        -654.83889729, -639.88930817, -262.03506162,  -50.59000875]), 280, 3)</code></pre><pre><code class="lang-python">fig, ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;], positive2[&#39;Test 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;], negative2[&#39;Test 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Rejected&#39;)ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)x, y = find_decision_boundary(result3)plt.scatter(x, y, c=&#39;y&#39;, s=10, label=&#39;Prediction&#39;)ax.legend()plt.show()</code></pre><pre><code>h_val是：         x1        x20      -1.0 -1.0000001      -1.0 -0.9974972      -1.0 -0.9949953      -1.0 -0.9924924      -1.0 -0.989990...     ...       ...999995  1.5  1.489990999996  1.5  1.492492999997  1.5  1.494995999998  1.5  1.497497999999  1.5  1.500000[1000000 rows x 2 columns]</code></pre><p><img src="/img/ML_Andrew/lg59.png" srcset="/img/loading.gif" alt="png"></p><h4 id="2-5-2-欠拟合"><a href="#2-5-2-欠拟合" class="headerlink" title="2.5.2 欠拟合"></a>2.5.2 欠拟合</h4><p>当$\lambda=100$可以得出，使得$\theta$值更容易受$\lambda$影响，从而使$\theta$过小，偏差过高，出现欠拟合(对整个一个训练集样本都勉强拟合)</p><pre><code class="lang-python">learningRate3 = 100result4 = opt.fmin_tnc(func=costReg, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate3))result4</code></pre><pre><code>(array([ 0.02187847, -0.0174817 ,  0.00571065, -0.05516901, -0.01314874,        -0.03859873, -0.01846356, -0.00773219, -0.00892429, -0.02280461,        -0.04343846, -0.00235623, -0.01415612, -0.00349507, -0.04143595,        -0.02100593, -0.00471917, -0.00359131, -0.00632226, -0.0050244 ,        -0.03197683, -0.03416334, -0.00107629, -0.00702615, -0.00038507,        -0.0079823 , -0.00154779, -0.04108683]), 11, 1)</code></pre><pre><code class="lang-python">fig, ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;], positive2[&#39;Test 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;], negative2[&#39;Test 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Rejected&#39;)ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)x, y = find_decision_boundary(result4)plt.scatter(x, y, c=&#39;y&#39;, s=10, label=&#39;Prediction&#39;)ax.legend()plt.show()</code></pre><pre><code>h_val是：         x1        x20      -1.0 -1.0000001      -1.0 -0.9974972      -1.0 -0.9949953      -1.0 -0.9924924      -1.0 -0.989990...     ...       ...999995  1.5  1.489990999996  1.5  1.492492999997  1.5  1.494995999998  1.5  1.497497999999  1.5  1.500000[1000000 rows x 2 columns]</code></pre><p><img src="/img/ML_Andrew/lg62.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Numpy-Base</title>
    <link href="/2020/06/27/Code_One_Hour1/"/>
    <url>/2020/06/27/Code_One_Hour1/</url>
    
    <content type="html"><![CDATA[<h1 id="Numpy使用-基础篇"><a href="#Numpy使用-基础篇" class="headerlink" title="Numpy使用-基础篇"></a>Numpy使用-基础篇</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Numpy的主要对象是相同类型的多维数组，也即：所有元素都是一种类型、通过整数索引对应元素。<br>在Numpy中维度(Dimensions)称为轴(axes、axis)<br>轴的个数称为秩(rank)</p><p>eg:[1,2,3]是一个一维(轴)数组，秩为1，轴的长度为3<br>  [[1,2,3],[4,5,6]]是一个二维数组，轴为2，秩为2，第一维度长度为2，第二维度长度为3</p><p>Numpy的数组类型称为ndarray，通常被称为数组。(numpy.array与标准python库中的array.array不同，后者只处理一维数组和提供一些功能)</p><h3 id="1-1-ndarray对象属性"><a href="#1-1-ndarray对象属性" class="headerlink" title="1.1 ndarray对象属性"></a>1.1 ndarray对象属性</h3><p>ndarray.ndim :获取ndarray的轴的个数，也即是秩<br><br>ndarray.shape:获取ndarray的维度<br><br>ndarray.size:获取ndarray的元素总个数=ndarray.shape的乘积<br><br>ndarray.dtype:描述ndarray中元素的类型<br><br>ndarray.itemsize:获取ndarray中每个元素的字节大小<br><br>ndarray.data:包含实际ndarray元素的缓冲区<br></p><pre><code class="lang-python">from numpy import *a = arange(15).reshape(3,5)print(a)print(a.shape)print(a.ndim)print(a.dtype.name)print(a.itemsize)print(a.size)print(type(a))b = array([6,7,8])print(b)print(type(b))</code></pre><pre><code>[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]](3, 5)2int32415&lt;class &#39;numpy.ndarray&#39;&gt;[6 7 8]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h2 id="2-创建ndarray"><a href="#2-创建ndarray" class="headerlink" title="2.创建ndarray"></a>2.创建ndarray</h2><p>有几种方式创建ndarray</p><pre><code class="lang-python">import numpy# 1.通过numpy.array()创建print(&quot;法一创建ndarray&quot;)a = numpy.array([1,2,3,4])print(a)print(a.dtype)print(type(a))# 类型可以创建时显示指定b = numpy.array([[1,2],[3,4]],dtype=complex)print(b)# 2.numpy.zeros()创建一个全是0的ndarrayprint(&quot;法二创建ndarray&quot;)c = numpy.zeros((3,4))print(c)print(type(c))# 3.numpy.ones()创建一个全是1的ndarrayd = numpy.ones((1,2,3),dtype=int16)print(&quot;法三创建&quot;)print(d)print(d.dtype)print(type(d))# 4.numpy.empty()创建一个内容随机并且依赖内存状态的ndarrayprint(&quot;法四创建&quot;)e = numpy.empty((3,1))print(e)print(e.dtype)print(type(e))print(&quot;法五创建&quot;)# 10-30的公差为5的ndarray# 结果不包含终值f = numpy.arange(10,30,5)print(f)print(f.dtype)print(type(f))# 结果可包含终值# 0-20的等差数列，一共6个g = numpy.linspace(0,20,6)print(g)print(type(g))</code></pre><pre><code>法一创建ndarray[1 2 3 4]int32&lt;class &#39;numpy.ndarray&#39;&gt;[[1.+0.j 2.+0.j] [3.+0.j 4.+0.j]]法二创建ndarray[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]&lt;class &#39;numpy.ndarray&#39;&gt;法三创建[[[1 1 1]  [1 1 1]]]int16&lt;class &#39;numpy.ndarray&#39;&gt;法四创建[[2.28386032e+242] [6.01346953e-154] [6.01347002e-154]]float64&lt;class &#39;numpy.ndarray&#39;&gt;法五创建[10 15 20 25]int32&lt;class &#39;numpy.ndarray&#39;&gt;[ 0.  4.  8. 12. 16. 20.]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h2 id="3-打印Ndarray"><a href="#3-打印Ndarray" class="headerlink" title="3.打印Ndarray"></a>3.打印Ndarray</h2><p>当打印一个数组时,Numpy是以类似嵌套列表的形式显示，<br><br>布局如下：<br><br>最后的轴从左到右打印<br><br>次后的轴从顶向下打印<br><br>剩下的轴从顶向下打印，每个切片通过一个空行与下一个隔开<br></p><pre><code class="lang-python">a = arange(6)print(a)b = arange(12).reshape(4,3)print(b)c = arange(24).reshape(2,3,4)print(c)# 太大会自动省略print(arange(100000))print(arange(10000).reshape(100,100))# 禁用NumPy的这种行为并强制打印整个数组，# 你可以设置printoptions参数来更改打印选项。set_printoptions(threshold=0)# print(arange(100000))</code></pre><pre><code>[0 1 2 3 4 5][[ 0  1  2] [ 3  4  5] [ 6  7  8] [ 9 10 11]][[[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] [[12 13 14 15]  [16 17 18 19]  [20 21 22 23]]][    0     1     2 ... 99997 99998 99999][[   0    1    2 ...   97   98   99] [ 100  101  102 ...  197  198  199] [ 200  201  202 ...  297  298  299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]]</code></pre><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><p>ndarray的算术运算是按元素计算，新的数组被创建并且被结果填充</p><pre><code class="lang-python">import numpya = numpy.array([20,30,40,50])b = numpy.arange(4)c = a - bprint(&quot;a-b的结果是{}&quot;.format(c))print(&quot;b**2的结果是{}&quot;.format(b**2))print(&quot;10*sin(a)的结果是{}&quot;.format(10*sin(a)))print(&quot;a&lt;35的结果是{}&quot;.format(a&lt;35))</code></pre><pre><code>a-b的结果是[20 29 38 47]b**2的结果是[0 1 4 9]10*sin(a)的结果是[ 9.12945251 -9.88031624  7.4511316  -2.62374854]a&lt;35的结果是[ True  True False False]</code></pre><p>Numpy中的乘法运算符*是按元素进行计算<br>dot()才是真正数学上的矩阵的乘法</p><pre><code class="lang-python">A = numpy.array([[1,1],[0,1]])B = numpy.array([[2,0],[3,4]])print(&quot;A*b的结果是\n{}&quot;.format(A*B))# 真正的矩阵乘法print(&quot;AXB={}\n&quot;.format(dot(A,B)))</code></pre><pre><code>A*b的结果是[[2 0] [0 4]]AXB=[[5 4] [3 4]]</code></pre><p>一些操作符eg:+=,*=是用来改变已存在的数组，而不是重新创建一个新的数组</p><pre><code class="lang-python">a = numpy.ones((2,3),dtype=int)b =numpy.random.random((2,3))a *= 3print(&quot;改变a为a *= 3 :{}&quot;.format(a))print(&quot;之前的b:{}&quot;.format(b))b += aprint(&quot;b += a之后的b:{}&quot;.format(b))# 报错 a += b，因为类型不匹配，并且小类型不可以加大类型</code></pre><pre><code>改变a为a *= 3 :[[3 3 3] [3 3 3]]之前的b:[[0.48206941 0.82075551 0.20677084] [0.40972474 0.1612522  0.40600564]]b += a之后的b:[[3.48206941 3.82075551 3.20677084] [3.40972474 3.1612522  3.40600564]]</code></pre><p>找最值、求和</p><pre><code class="lang-python">a = numpy.random.random((3,3))print(a)print(&quot;a的全部和:{}&quot;.format(a.sum()))print(&quot;a的全部元素里的最小值:{}&quot;.format(a.min()))print(&quot;a的全部元素里的最大值:{}&quot;.format(a.max()))</code></pre><pre><code>[[0.3284271  0.14197324 0.7038814 ] [0.65741107 0.14568861 0.60085068] [0.62157778 0.60594248 0.19610351]]a的全部和:4.0018558644883155a的全部元素里的最小值:0.1419732429134546a的全部元素里的最大值:0.703881395273379</code></pre><p>指定轴的找最值，求和，使用axis来指定</p><pre><code class="lang-python">b = numpy.arange(9).reshape(3,3)print(b)print(&quot;指定每列求和{}&quot;.format(b.sum(axis=0)))print(&quot;指定每行求最小值{}&quot;.format(b.min(axis=1)))# 看成数组，前项累加print(&quot;指定行累加\n{}&quot;.format(b.cumsum(axis=1)))</code></pre><pre><code>[[0 1 2] [3 4 5] [6 7 8]]指定每列求和[ 9 12 15]指定每行求最小值[0 3 6]指定行累加[[ 0  1  3] [ 3  7 12] [ 6 13 21]]</code></pre><h2 id="5-通用函数ufunc"><a href="#5-通用函数ufunc" class="headerlink" title="5.通用函数ufunc"></a>5.通用函数ufunc</h2><p>Numpy提供常见的数学函数如：sin,cos和exp。在Numpy中，这些叫<strong>通用函数ufunc</strong>。在Numpy里这些函数作用按数组元素运算，产生一个数组作为输出。</p><pre><code class="lang-python">B = numpy.arange(3)print(B)</code></pre><pre><code>[0 1 2]</code></pre><pre><code class="lang-python">exp(B)</code></pre><pre><code>array([1.        , 2.71828183, 7.3890561 ])</code></pre><pre><code class="lang-python">sqrt(B)</code></pre><pre><code>array([0.        , 1.        , 1.41421356])</code></pre><pre><code class="lang-python">C = array([2.,-1.,4.])add(B,C)</code></pre><pre><code>array([2., 0., 6.])</code></pre><p>更多函数：<br><br>all, alltrue, any, apply along axis, argmax, argmin, argsort, average,<br>bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum,<br>diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum,<br>nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose,<br>var, vdot, vectorize, where</p><p><strong>索引、切片、迭代</strong></p><pre><code class="lang-python">a = arange(10)**3a</code></pre><pre><code>array([  0,   1,   8, ..., 343, 512, 729], dtype=int32)</code></pre><pre><code class="lang-python">a[2]</code></pre><pre><code>8</code></pre><pre><code class="lang-python">a[2:5]</code></pre><pre><code>array([ 8, 27, 64], dtype=int32)</code></pre><pre><code class="lang-python"># 从头(:)到索引7，间隔为2赋值a[:7:2]=-1000print(a)print(a[2],a[4],a[6])</code></pre><pre><code>[-1000     1 -1000 ...   343   512   729]-1000 -1000 -1000</code></pre><pre><code class="lang-python"># 逆序索引a[::-1]</code></pre><pre><code>array([  729,   512,   343, ..., -1000,     1, -1000], dtype=int32)</code></pre><pre><code class="lang-python">for i in a:    print(i**(1/3.),end=&quot;,&quot;)</code></pre><pre><code>nan,1.0,nan,3.0,nan,5.0,nan,6.999999999999999,7.999999999999999,8.999999999999998,d:\dl\minconda3\envs\ml_andrewng\lib\site-packages\ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power</code></pre><p>多维数组每个轴有一个索引。这些索引由一个逗号分割的元组给出</p><pre><code class="lang-python">def f(x,y):    return 10*x+y# 从函数规则创建数组（使用索引与元素的对应关系(自定义的function)进行创建）b = fromfunction(f,(5,4),dtype=int)b</code></pre><pre><code>array([[ 0,  1,  2,  3],       [10, 11, 12, 13],       [20, 21, 22, 23],       [30, 31, 32, 33],       [40, 41, 42, 43]])</code></pre><pre><code class="lang-python">b[0:5,1]</code></pre><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><pre><code class="lang-python">b[:,1]</code></pre><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><pre><code class="lang-python">b[1:3,:]</code></pre><pre><code>array([[10, 11, 12, 13],       [20, 21, 22, 23]])</code></pre><pre><code class="lang-python"># 当少于轴数的索引被提供时，确失的索引被认为是整个切片：b[-1]</code></pre><pre><code>array([40, 41, 42, 43])</code></pre><p>b[i]中括号中的表达式被当作i和一系列:，来代表剩下的轴。NumPy也允许你使用“点”像b[i,…]。</p><p>点(…)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴)，那么:</p><pre><code>x[1,2,…] 等同于 x[1,2,:,:,:]x[…,3] 等同于 x[:,:,:,:,3]x[4,…,5,:] 等同于 x[4,:,:,5,:]</code></pre><pre><code class="lang-python"># c = array( [ [[  0,  1,  2],  # a 3D array (two stacked 2D arrays) ... [ 10, 12, 13]]... # [[100,101,102], ... [110,112,113]] ] ) # c.shape (2, 2, 3) # c[1,...]    # same as c[1,:,:] or c[1] array([[100, 101, 102], [110, 112, 113]]) # c[...,2]      # same as c[:,:,2] array([[  2,  13], [102, 113]])</code></pre><p>迭代多维数组是就第一个轴而言的</p><pre><code class="lang-python">for row in b:    print (row)</code></pre><pre><code>[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]</code></pre><p>如果想对每个数组中元素进行运算，我们可以使用flat属性，该属性是数组元素的一个迭代器:</p><pre><code class="lang-python">for element in b.flat:    print (element,end=&quot;,&quot;)</code></pre><pre><code>0,1,2,3,10,11,12,13,20,21,22,23,30,31,32,33,40,41,42,43,</code></pre><p>更多newaxis, ndenumerate, indices, index exp 可以参考Numpy示例</p><h2 id="6-形状操作"><a href="#6-形状操作" class="headerlink" title="6.形状操作"></a>6.形状操作</h2><p><strong>改变数组的形状</strong></p><pre><code class="lang-python">a = floor(10*random.random((3,4)))a</code></pre><pre><code>array([[7., 4., 5., 7.],       [7., 8., 7., 4.],       [2., 5., 3., 4.]])</code></pre><pre><code class="lang-python">a.shape</code></pre><pre><code>(3, 4)</code></pre><pre><code class="lang-python"># 矩阵扁平化a.ravel()</code></pre><pre><code>array([7., 4., 5., ..., 5., 3., 4.])</code></pre><pre><code class="lang-python"># 改变形状a.shape=(6,2)print(a)# 矩阵转置a.transpose()print(a)</code></pre><pre><code>[[7. 4.] [5. 7.] [7. 8.] [7. 4.] [2. 5.] [3. 4.]][[7. 4.] [5. 7.] [7. 8.] [7. 4.] [2. 5.] [3. 4.]]</code></pre><p>reshape()根据参数改变形状并返回<br><br>resize()根据参数改变自身形状</p><pre><code class="lang-python">aprint(a)a.resize((2,6))print(a)</code></pre><pre><code>[[7. 4.] [5. 7.] [7. 8.] [7. 4.] [2. 5.] [3. 4.]][[7. 4. 5. 7. 7. 8.] [7. 4. 2. 5. 3. 4.]]</code></pre><p>如果在改变形状操作中一个维度被给做-1，其维度将自动被计算<br>更多 shape, reshape, resize, ravel 参考Numpy示例</p><p><strong>组合不同的数组(stack)</strong></p><pre><code class="lang-python">a = floor(10*random.random((2,2)))b = floor(10*random.random((2,2)))print(a)print(b)</code></pre><pre><code>[[5. 1.] [1. 6.]][[4. 9.] [3. 6.]]</code></pre><pre><code class="lang-python"># 一行一行的合并，矩阵变化方向是按vertical的方向vstack((a,b))</code></pre><pre><code>array([[5., 1.],       [1., 6.],       [4., 9.],       [3., 6.]])</code></pre><pre><code class="lang-python"># 一列一列的合并，矩阵变化方向是按horizontal的方向hstack((a,b))</code></pre><pre><code>array([[5., 1., 4., 9.],       [1., 6., 3., 6.]])</code></pre><pre><code class="lang-python"># 以列将一维数组合成二维数组,类似hstack()column_stack((a,b))</code></pre><pre><code>array([[5., 1., 4., 9.],       [1., 6., 3., 6.]])</code></pre><pre><code class="lang-python">a = array([4.,3.])b = array([2.,8.])# np.newaxis==newaxis：增加一个维度a[:,newaxis]column_stack((a[:,newaxis],b[:,newaxis]))</code></pre><pre><code>array([[4., 2.],       [3., 8.]])</code></pre><p>row<em>stack()将一维数组以行组合成二维数组。<br>对那些维度比二维更高的数组，hstack沿着第二个轴组合，vstack沿着第一个轴组合,concatenate允许可选参数给出组合时沿着的轴。<br>在复杂情况下，r</em>[]和c_[]对创建沿着一个方向组合的数很有用，它们允许范围符号(“:”):</p><pre><code class="lang-python">r_[1:4,0,4]</code></pre><pre><code>array([1, 2, 3, 0, 4])</code></pre><pre><code class="lang-python">c_[1,2,3,4,5]</code></pre><pre><code>array([[1, 2, 3, 4, 5]], dtype=int32)</code></pre><p>当使用数组作为参数时，r<em>和c</em>的默认行为和vstack和hstack很像，但是允许可选的参数给出组合所沿着的轴的代号。<br><br>更多函数hstack, vstack, column<em>stack, row_stack, concatenate, c</em>, r_ 参见Numpy示例.</p><p><strong>将一个数组分割(split)成几个小数组</strong><br><br>使用hsplit你能将数组沿着它的水平轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割:</p><pre><code class="lang-python">a = floor(10*random.random((2,12)))print(a)</code></pre><pre><code>[[1. 4. 9. ... 8. 9. 4.] [1. 5. 7. ... 2. 6. 8.]]</code></pre><pre><code class="lang-python">hsplit(a,3)</code></pre><pre><code>[array([[1., 4., 9., 6.],        [1., 5., 7., 5.]]), array([[4., 6., 3., 4.],        [4., 7., 2., 7.]]), array([[0., 8., 9., 4.],        [5., 2., 6., 8.]])]</code></pre><pre><code class="lang-python"># 水平分割从第3列到第五列(不包括)hsplit(a,(3,5))</code></pre><pre><code>[array([[1., 4., 9.],        [1., 5., 7.]]), array([[6., 4.],        [5., 4.]]), array([[6., 3., 4., ..., 8., 9., 4.],        [7., 2., 7., ..., 2., 6., 8.]])]</code></pre><p>vsplit沿着纵向的轴分割，array split允许指定沿哪个轴分割。</p><p><strong>复制和视图</strong></p><p><strong>完全不拷贝</strong><br><br>简单的复制(=)并不会拷贝数据，即只是不同指针指向同一个地方</p><pre><code class="lang-python">a = arange(12)b = ab is a</code></pre><pre><code>True</code></pre><pre><code class="lang-python">b.shape=(3,4)print(a.shape)</code></pre><pre><code>(3, 4)</code></pre><p>Python 传递不定对象作为参考，所以函数调用不拷贝数组。</p><pre><code class="lang-python">def f(x):    print (id(x))print(id(a))     f(a)</code></pre><pre><code>101697936101697936</code></pre><p><strong>视图(view)和浅复制</strong><br><br>不同的数组对象共享一个数据，视图方法创造一个新的数组对象指向同一数据</p><pre><code class="lang-python">c = a.view()c is a</code></pre><pre><code>False</code></pre><pre><code class="lang-python">c.base is a</code></pre><pre><code>True</code></pre><pre><code class="lang-python">c.flags.owndata</code></pre><pre><code>False</code></pre><pre><code class="lang-python"># view_c的形状改变不会影响a的形状c.shape = 2,6print(c)print(a)</code></pre><pre><code>[[ 0  1  2  3  4  5] [ 6  7  8  9 10 11]][[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]</code></pre><pre><code class="lang-python"># view_c的数据改变会改变ac[0,4]=11111a</code></pre><pre><code>array([[    0,     1,     2,     3],       [11111,     5,     6,     7],       [    8,     9,    10,    11]])</code></pre><pre><code class="lang-python"># 切片数组返回它的一个视图：s = a[:,1:3]print(s)s[:]=10print(a)</code></pre><pre><code>[[ 1  2] [ 5  6] [ 9 10]][[    0    10    10     3] [11111    10    10     7] [    8    10    10    11]]</code></pre><p><strong>深复制</strong><br><br>这个方法完全复制数组和它的数据</p><pre><code class="lang-python">d = a.copy()d is a</code></pre><pre><code>False</code></pre><pre><code class="lang-python">d.base is a</code></pre><pre><code>False</code></pre><pre><code class="lang-python">d[0,0]=9999a</code></pre><pre><code>array([[    0,    10,    10,     3],       [11111,    10,    10,     7],       [    8,    10,    10,    11]])</code></pre><h2 id="7-函数和方法-method-总览"><a href="#7-函数和方法-method-总览" class="headerlink" title="7.函数和方法(method)总览"></a>7.函数和方法(method)总览</h2><p>这是个Numpy函数和方法分类排列目录。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity,<br>linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like</p><h3 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h3><p>astype, atleast 1d, atleast 2d, atleast 3d, mat</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item,<br>newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</p><h3 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h3><p>all, any, nonzero, where</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>argmax, argmin, argsort, max, min, ptp, searchsorted, sort</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum</p><h3 id="基本统计"><a href="#基本统计" class="headerlink" title="基本统计"></a>基本统计</h3><p>cov, mean, std, var</p><h3 id="基本线性代数"><a href="#基本线性代数" class="headerlink" title="基本线性代数"></a>基本线性代数</h3><p>cross, dot, outer, svd, vdot</p>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Numpy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习1:线性回归</title>
    <link href="/2020/06/20/ML_Andrew_Pex1_Linear_Regression%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2020/06/20/ML_Andrew_Pex1_Linear_Regression%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习1-线性回归"><a href="#吴恩达机器学习程序练习1-线性回归" class="headerlink" title="吴恩达机器学习程序练习1:线性回归"></a>吴恩达机器学习程序练习1:线性回归</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex14179</p><pre><code class="lang-python"># 导入对应的第三方库import numpy as npimport pandas as pdimport matplotlib.pyplot as plt</code></pre><h2 id="1-简单练习"><a href="#1-简单练习" class="headerlink" title="1.简单练习"></a>1.简单练习</h2><pre><code class="lang-python">A = np.eye(6)A</code></pre><pre><code>array([[1., 0., 0., 0., 0., 0.],       [0., 1., 0., 0., 0., 0.],       [0., 0., 1., 0., 0., 0.],       [0., 0., 0., 1., 0., 0.],       [0., 0., 0., 0., 1., 0.],       [0., 0., 0., 0., 0., 1.]])</code></pre><h2 id="2-单变量的线性回归"><a href="#2-单变量的线性回归" class="headerlink" title="2.单变量的线性回归"></a>2.单变量的线性回归</h2><p>根据城市人口数量，预测开小吃店的利润。<br>数据在ex1data1.txt中，第一列是城市人口数量，第二列是该城市小吃店利润</p><h3 id="2-1-Plotting-the-data"><a href="#2-1-Plotting-the-data" class="headerlink" title="2.1 Plotting the data"></a>2.1 Plotting the data</h3><pre><code class="lang-python"># 读入数据并且显示path = &#39;./andrew_ml_ex14179/ex1data1.txt&#39;# header=1：以第一行数据作为列索引(列名)# names = [...]:给定列名# 返回DataFrame类型,Population：人口(万)data = pd.read_csv(path,header=None,names=[&#39;Population&#39;,&#39;Profit&#39;])# DataFrame.head([N]):返回前N行data.head(94)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Population</th>      <th>Profit</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>6.1101</td>      <td>17.5920</td>    </tr>    <tr>      <th>1</th>      <td>5.5277</td>      <td>9.1302</td>    </tr>    <tr>      <th>2</th>      <td>8.5186</td>      <td>13.6620</td>    </tr>    <tr>      <th>3</th>      <td>7.0032</td>      <td>11.8540</td>    </tr>    <tr>      <th>4</th>      <td>5.8598</td>      <td>6.8233</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>89</th>      <td>5.0594</td>      <td>2.8214</td>    </tr>    <tr>      <th>90</th>      <td>5.7077</td>      <td>1.8451</td>    </tr>    <tr>      <th>91</th>      <td>7.6366</td>      <td>4.2959</td>    </tr>    <tr>      <th>92</th>      <td>5.8707</td>      <td>7.2029</td>    </tr>    <tr>      <th>93</th>      <td>5.3054</td>      <td>1.9869</td>    </tr>  </tbody></table><p>94 rows × 2 columns</p></div><pre><code class="lang-python"># 将数据绘图成散点图data.plot(kind=&#39;scatter&#39;,x=&#39;Population&#39;,y=&#39;Profit&#39;,figsize=(12,8))plt.show()</code></pre><p><img src="/img/ML_Andrew/output_8_0.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-2-梯度下降"><a href="#2-2-梯度下降" class="headerlink" title="2.2 梯度下降"></a>2.2 梯度下降</h3><p>使用传统的线性回归的代价函数</p><h4 id="2-2-1-公式"><a href="#2-2-1-公式" class="headerlink" title="2.2.1 公式"></a>2.2.1 公式</h4><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m{(h_{\theta}(x^{(i)})-y^{(i)})^2}</script><pre><code class="lang-python"># X是矩阵def computeCost(X,y,theta):    # *对应元素相乘    inner = np.power(((X*theta.T)-y),2)    return np.sum(inner)/(2*len(X))</code></pre><pre><code class="lang-python"># 验证矩阵间的乘法(*)是对应元素相乘x=np.array([[1,2],[3,4]])y=np.array([[1,2],[3,4]])print(x*y)# 这才是真正的矩阵的乘法print(x.dot(y))# 对应元素相减print(x-y)</code></pre><pre><code>[[ 1  4] [ 9 16]][[ 7 10] [15 22]][[0 0] [0 0]]</code></pre><h4 id="2-2-2-实现"><a href="#2-2-2-实现" class="headerlink" title="2.2.2 实现"></a>2.2.2 实现</h4><p>新加一列x，用于更新theta,并且将theta初始化为0，学习率初始化为0.01，迭代次数为1500次</p><pre><code class="lang-python"># 在第0列新增一列索引为Ones的全部为1的数据data.insert(0,&#39;Ones&#39;,1)# 删除某一列 要axis=1，因为默认是行# 并且要inplace=True,才是对原数据进行操作data.head(100)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Ones</th>      <th>Population</th>      <th>Profit</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>6.1101</td>      <td>17.59200</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>5.5277</td>      <td>9.13020</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>8.5186</td>      <td>13.66200</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>7.0032</td>      <td>11.85400</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>5.8598</td>      <td>6.82330</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>92</th>      <td>1</td>      <td>5.8707</td>      <td>7.20290</td>    </tr>    <tr>      <th>93</th>      <td>1</td>      <td>5.3054</td>      <td>1.98690</td>    </tr>    <tr>      <th>94</th>      <td>1</td>      <td>8.2934</td>      <td>0.14454</td>    </tr>    <tr>      <th>95</th>      <td>1</td>      <td>13.3940</td>      <td>9.05510</td>    </tr>    <tr>      <th>96</th>      <td>1</td>      <td>5.4369</td>      <td>0.61705</td>    </tr>  </tbody></table><p>97 rows × 3 columns</p></div><pre><code class="lang-python"># 初始化# 获得data的列数，0为行数cols=data.shape[1]print(cols)# [,]先行后列,获取对应行列对应区域的数据X = data.iloc[:,:-1]Y = data.iloc[:,cols-1:cols]# X训练集 Y目标集print(type(X))print(type(Y))</code></pre><pre><code>3&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><pre><code class="lang-python"># 因为代价函数使用的是numpy矩阵，所以要转换X和Y，并且初始化theta# X.values:获取X的值，没有索引了# print(type(X.values))# print(Y.values)print(type(X))# 将X，Y转换为对应的矩阵X=np.matrix(X)# print(X)# print(X)print(type(Y))y=np.matrix(Y.values)print(type(y))theta = np.asmatrix(np.array([0,0]))print(theta)</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;numpy.matrix&#39;&gt;[[0 0]]</code></pre><pre><code class="lang-python"># 查看对应维度X.shape,theta.shape,y.shapeprint(theta.size)</code></pre><pre><code>2</code></pre><h4 id="2-2-3-计算代价函数"><a href="#2-2-3-计算代价函数" class="headerlink" title="2.2.3 计算代价函数"></a>2.2.3 计算代价函数</h4><p>theta初始为0<br>computeCost(X,y,theta)</p><pre><code class="lang-python">computeCost(X,y,theta)</code></pre><pre><code>32.072733877455676</code></pre><h4 id="2-2-4-梯度下降算法"><a href="#2-2-4-梯度下降算法" class="headerlink" title="2.2.4 梯度下降算法"></a>2.2.4 梯度下降算法</h4><p>目标是最小化代价函数J(theta)，变量是theta不是X和y,通过变换theta来变化代价函数，进而使代价函数最小。<br>检查梯度下降算法是否正确运行，可以打印J(theta)的值来判断是否在不断减小，并且最后收敛到一个稳定的值。</p><pre><code class="lang-python">def gradientDescent(X,y,theta,alpha,iters):    # 初始化参数矩阵    temp=np.matrix(np.zeros(theta.shape))    # ravel()将矩阵扁平化    # 获取参数theta的个数    parameters = int(theta.ravel().shape[1])    # 用来存储代价    cost = np.zeros(iters)    thetax = np.zeros((iters,theta.size))    # print(thetax)    for i in range(iters):        # 计算代价误差        # h_theta(x)-y        error = (X*theta.T)-y        for j in range(parameters):            # np.multiply()对应元素相乘            # 计算J(theta)的导数            term = np.multiply(error,X[:,j])            # 进行梯度下降            temp[0,j]=theta[0,j]-((alpha/len(X)))*np.sum(term)            thetax[i][j]=temp[0,j]        theta = temp        cost[i]=computeCost(X,y,theta)    return theta,cost,thetax</code></pre><pre><code class="lang-python"># 初始化alpha 和 itersalpha = 0.01iters = 1500# 运行梯度下降算法来找到适合训练集的thetag,cost,thetax = gradientDescent(X,y,theta,alpha,iters)g</code></pre><pre><code>matrix([[-3.63029144,  1.16636235]])</code></pre><pre><code class="lang-python"># 预测35000和70000城市规模的小吃利润predict1 = [1,3.5]*g.Tprint(&quot;predict1:&quot;,predict1)predict2=[1,7]*g.Tprint(&quot;predict2:&quot;,predict2)</code></pre><pre><code>predict1: [[0.45197679]]predict2: [[4.53424501]]</code></pre><pre><code class="lang-python"># 显示原始数据以及拟合的线性回归方程# numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 在[start,stop]返回num均匀分布的样本x = np.linspace(data.Population.min(),data.Population.max(),100)# print(x)f = g[0,0]+(g[0,1]*x)# plt.subplots(1,3,figsize=(12,8))设置一个1行3个12*8大小的子图# 返回一个figure图像和一个子图ax的列表fig ,ax =plt.subplots(figsize=(12,8))# ax.plot()绘制一条线ax.plot(x,f,&#39;r&#39;,label=&#39;Prediction&#39;)# ax.scatter()绘制一个散点图ax.scatter(data.Population,data.Profit,label=&#39;Training Data&#39;)# ax.legend(loc=1)显示图中的标签在第一象限ax.legend(loc=1)ax.set_xlabel(&quot;Population&quot;)ax.set_ylabel(&#39;Profit&#39;)ax.set_title(&quot;Predicted Profit vs. Population Size&quot;)plt.show()</code></pre><p><img src="/img/ML_Andrew/output_23_0.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-3可视化J-theta-未完待续"><a href="#2-3可视化J-theta-未完待续" class="headerlink" title="2.3可视化J(theta)(未完待续)"></a>2.3可视化J(theta)(未完待续)</h3><p>希望能够画出J(theta)与theta0,theta1之间的对应关系，应该是一个三维图像</p><pre><code class="lang-python">print(thetax.shape)print(cost.shape)print(X.shape)print(y.shape)print(cost)</code></pre><pre><code>(1500, 2)(1500,)(97, 2)(97, 1)[6.73719046 5.93159357 5.90115471 ... 4.48343473 4.48341145 4.48338826]</code></pre><pre><code class="lang-python"># 绘制3d图像# 直接根据theta0,theta1,costfunction对应的点来绘制出的散点图from mpl_toolkits.mplot3d import Axes3Dfrom matplotlib import cmfig=plt.figure()ax=fig.add_subplot(111,projection=&#39;3d&#39;)x=thetax[:,0]y1=thetax[:,1]ax.plot_trisurf(x,y1,cost,)plt.show()</code></pre><p><img src="/img/ML_Andrew/output_26_0.png" srcset="/img/loading.gif" alt="png"></p><h2 id="3-多变量线性回归"><a href="#3-多变量线性回归" class="headerlink" title="3.多变量线性回归"></a>3.多变量线性回归</h2><p>数据集:ex1data2.txt：<br>第一列：房屋大小<br>第二列：卧室数量<br>第三列：房屋售价<br>根据已有数据建立模型，预测房屋的售价</p><pre><code class="lang-python"># 读入数据并且显示path = &#39;./andrew_ml_ex14179/ex1data2.txt&#39;# header=1：以第一行数据作为列索引(列名)# names = [...]:给定列名# 返回DataFrame类型,Population：人口(万)data2 = pd.read_csv(path,header=None,names=[&#39;Size&#39;,&#39;Bedrooms&#39;,&#39;Price&#39;])# DataFrame.head([N]):返回前N行print(data2.head())print(data2.shape)</code></pre><pre><code>   Size  Bedrooms   Price0  2104         3  3999001  1600         3  3299002  2400         3  3690003  1416         2  2320004  3000         4  539900(47, 3)</code></pre><h3 id="3-1-特征缩放-Feature-Scaling"><a href="#3-1-特征缩放-Feature-Scaling" class="headerlink" title="3.1 特征缩放(Feature Scaling)"></a>3.1 特征缩放(Feature Scaling)</h3><p>根据数据得知，size变量的大小是bedrooms的1000倍，所以最好统一量级，可以使梯度下降收敛的更快</p><h4 id="3-1-1Mean-Normalization-均值归一化"><a href="#3-1-1Mean-Normalization-均值归一化" class="headerlink" title="3.1.1Mean Normalization(均值归一化)"></a>3.1.1Mean Normalization(均值归一化)</h4><p>特征减去平均值再除以标准差</p><pre><code class="lang-python">data2 = (data2-data2.mean())/data2.std()data2.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Size</th>      <th>Bedrooms</th>      <th>Price</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.130010</td>      <td>-0.223675</td>      <td>0.475747</td>    </tr>    <tr>      <th>1</th>      <td>-0.504190</td>      <td>-0.223675</td>      <td>-0.084074</td>    </tr>    <tr>      <th>2</th>      <td>0.502476</td>      <td>-0.223675</td>      <td>0.228626</td>    </tr>    <tr>      <th>3</th>      <td>-0.735723</td>      <td>-1.537767</td>      <td>-0.867025</td>    </tr>    <tr>      <th>4</th>      <td>1.257476</td>      <td>1.090417</td>      <td>1.595389</td>    </tr>  </tbody></table></div><h3 id="3-2-梯度下降算法"><a href="#3-2-梯度下降算法" class="headerlink" title="3.2 梯度下降算法"></a>3.2 梯度下降算法</h3><pre><code class="lang-python"># 为了能够根据矩阵运算，添加一列常数项# data2.drop(&#39;Ones&#39;,axis=1,inplace=True)data2.insert(0,&#39;Ones&#39;,1)# 初始化x,ycols = data2.shape[1]X2=data2.iloc[:,0:cols-1]y2=data2.iloc[:,cols-1:cols]# 转换为matrix格式并且初始化thetax2=np.matrix(X2)y2=np.matrix(y2)theta2 = np.matrix(np.array([0,0,0]))# 运行梯度下降算法print(&quot;开始运行梯度下降算法&quot;)g2,cost2,thetax=gradientDescent(x2,y2,theta2,alpha,iters)g2</code></pre><pre><code>开始运行梯度下降算法matrix([[-1.10898288e-16,  8.84042349e-01, -5.24551809e-02]])</code></pre><h3 id="3-3-Normal-Equation-正规方程算法"><a href="#3-3-Normal-Equation-正规方程算法" class="headerlink" title="3.3 Normal Equation(正规方程算法)"></a>3.3 Normal Equation(正规方程算法)</h3><p>正规方程是直接以theta为变量求解J(theta)的最小值，也即是直接求每个theta的偏导并且令其为0，求解方程即可<br>则利用正规方程解出向量：</p><script type="math/tex; mode=display">\theta = (X^TX)^{-1}X^Ty</script><p>梯度下降 VS 正规方程<br>梯度下降：需要选择学习率α，需要多次迭代，当特征数量n大时也能较好适用，适用于各种类型的模型<br>正规方程：不需要选择学习率α，一次计算得出，需要计算$(X^TX)^{-1}$，如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为O($n^3$)，通常来说当小于10000 时还是可以接受的，只适用于线性模型，不适合逻辑回归模型等其他模型</p><pre><code class="lang-python"># 正规方程def normalEqn(X,y):# numpy.linalg模块包含线性代数的函数。# 使用这个模块，可以计算逆矩阵、求特征值、解线性方程组以及求解行列式等# inv()求解矩阵的逆# pinv()求解矩阵的伪逆    theta = np.linalg.inv(X.T.dot(X))    theta = theta.dot(X.T)    theta = theta.dot(y)    return theta</code></pre><pre><code class="lang-python"># 使用data1数据进行验证final_theta2=normalEqn(X,y)final_theta2</code></pre><pre><code>matrix([[-3.89578088],        [ 1.19303364]])</code></pre><pre><code class="lang-python"># 使用梯度下降算法# 初始化alpha 和 itersalpha = 0.01iters = 1500# 运行梯度下降算法来找到适合训练集的thetag,cost,thetax = gradientDescent(X,y,theta,alpha,iters)g</code></pre><pre><code>matrix([[-3.63029144,  1.16636235]])</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T18</title>
    <link href="/2020/05/11/CprogrammingT18/"/>
    <url>/2020/05/11/CprogrammingT18/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T18"><a href="#C语言编程T18" class="headerlink" title="C语言编程T18"></a>C语言编程T18</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>空格处理要全面！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/211.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 80int CountWords(char str[]);int main(){    char str[N+1];    printf(&quot;Input a string:&quot;);    gets(str);    printf(&quot;Numbers of words = %d\n&quot;,CountWords(str));    return 0;}int CountWords(char str[]){    int i,j=0,k=0,count=0;    for(i=0;str[i]==&#39; &#39;;i++);    j=i-1;    for(i=0;str[i]!=&#39;\0&#39;;i++)    {        if(str[i]==&#39; &#39;)        {            for(k=i;str[k]==&#39; &#39;;k++);            i=k-1;            //printf(&quot;%c\n&quot;,str[i]);            if(i&gt;j)            {                count++;                j=i;            }        }    }    if(i&gt;j&amp;&amp;str[i-1]!=&#39; &#39;)    {        count++;        j=i;    }    return count;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T17</title>
    <link href="/2020/05/11/CprogrammingT17/"/>
    <url>/2020/05/11/CprogrammingT17/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T17"><a href="#C语言编程T17" class="headerlink" title="C语言编程T17"></a>C语言编程T17</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>注意边界</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/210.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int a[20]={2,4,6,8,10,12,14,16};    int i,j,x,len=8;    printf(&quot;Enter n:&quot;);    scanf(&quot;%d&quot;,&amp;x);    for(i=0;i&lt;len;i++)    {        if(a[0]&gt;x)        {            i=0;            break;        }        else if(a[i]&lt;x&amp;&amp;a[i+1]&gt;x)        {            i++;            break;        }        else if(a[len-1]&lt;x)        {            i=len-1;        }    }    for(j=len+1;j&gt;=i;j--)    {        a[j+1]=a[j];    }    a[i]=x;    for(i=0;i&lt;len+1;i++)    {        printf(&quot;%d &quot;,a[i]);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T7</title>
    <link href="/2020/04/27/CorrectionT7/"/>
    <url>/2020/04/27/CorrectionT7/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T7"><a href="#C语言改错T7" class="headerlink" title="C语言改错T7"></a>C语言改错T7</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p><strong>注意返回的是-1还是+1，是谁到谁的距离！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/171.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;int MyStrcmp(char s[], char t[], char bigger[]);int main(){    char  str1[20], str2[20], str3[20];    int diff;    printf(&quot;Input string:&quot;);    gets(str1);    printf(&quot;Input another string:&quot;);    gets(str2);    diff = MyStrcmp(str1, str2, str3);    printf(&quot;The bigger string is:%s\n&quot;, str3);    printf(&quot;The differ of the strings is:%d\n&quot;, diff);    return 0;}int MyStrcmp(char s[], char t[], char bigger[]){    int i, result = 0;    int len1 = 0, len2 = 0;    while (s[len1++] != &#39;\0&#39;);    while (t[len2++] != &#39;\0&#39;);    for (i = 0; s[i] == t[i]; i++);    if (i==0 || s[i - 1] != &#39;\0&#39; )    {        result = t[i] - s[i];        //printf(&quot;rst=%d\n&quot;,result);    }    if (result &gt;= 0)    {        for (i = 0; i &lt; len2; i++)            bigger[i] = t[i];        bigger[i]=&#39;\0&#39;;    }    else    {        for (i = 0; i &lt; len1; i++)            bigger[i] = s[i];        bigger[i]=&#39;\0&#39;;    }    return -result;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T16</title>
    <link href="/2020/04/27/CprogrammingT16/"/>
    <url>/2020/04/27/CprogrammingT16/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T16"><a href="#C语言编程T16" class="headerlink" title="C语言编程T16"></a>C语言编程T16</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>根据过程自己找规律</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/169.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//分酒int i;main(){    int a,y,z;    //共有a,分成i    printf(&quot;Input Full a,Empty b,c,Get i:&quot;);    scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;y,&amp;z,&amp;i);    getti(a,y,z);    getti(a,z,y);}getti(a,y,z)  int a,y,z;  {int b=0,c=0;  //a、b、c表示现在容器已装的容量大小  //a、y、z表示的是容器的最大容量    printf(&quot;  a%d  b%d  c%d\n%4d%4d%4d\n&quot;,a,y,z,a,b,c);    while((a!=i||b!=i)&amp;&amp;c!=i)    {        //b为空,即将a倒满b        if(!b)        {            a-=y;            b=y;        }        //c已满,将c全部倒入a        else if(c==z)        {           a+=z;           c=0;        }        //b的容量大于c中还可以装入的容量        //将b倒入c直到装满        else if(b&gt;z-c)        {            b-=(z-c);            c=z;        }        //倒空b        else        {            c+=b;            b=0;        }        printf(&quot;%4d%4d%4d\n&quot;,a,b,c);    }  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T15</title>
    <link href="/2020/04/26/CprogrammingT15/"/>
    <url>/2020/04/26/CprogrammingT15/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T15"><a href="#C语言编程T15" class="headerlink" title="C语言编程T15"></a>C语言编程T15</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>字符串遇到 多空格、结尾空格、开头空格如何解决</strong><br>if判断要全面！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/165.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 80//多空格和结尾如何解决int CountWords(char str[]);int main(){    char str[N+1];   printf(&quot;Input a string:\n&quot;);   gets(str);   printf(&quot;Number of words=%d\n&quot;,CountWords(str));    return 0;}int CountWords(char str[]){    int i,k,count=0;    for(i=0;str[i]!=&#39;\0&#39;;i++)    {        if(str[i]==&#39; &#39;)        {            for(k=i;str[k]==&#39; &#39;;k++);            i=k;            if(str[i]!=&#39;\0&#39;)            {                count++;            }        }    }    return count+1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T14</title>
    <link href="/2020/04/26/CprogrammingT14/"/>
    <url>/2020/04/26/CprogrammingT14/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T14"><a href="#C语言编程T14" class="headerlink" title="C语言编程T14"></a>C语言编程T14</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>相等情况？？？每行情况？？？</strong><br>所以要有两个标记量</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/163.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 6int main(){    int i,j,a[M][N],flag=0,flagz=0,max,min,row,col,k;    for(i=0;i&lt;M;i++)    {        for(j=0;j&lt;N;j++)        {            scanf(&quot;%d&quot;,&amp;a[i][j]);        }    }    for(i=0;i&lt;M;i++)    {        flag=1;        max=a[i][0];        for(j=0;j&lt;N;j++)        {            if(max&lt;a[i][j])            {                row=i;                col=j;                max=a[i][j];            }        }        //printf(&quot;max=%d\n&quot;,max);        for(k=0;k&lt;M;k++)        {            if(max&gt;=a[k][col]&amp;&amp;k!=row)            {                flag=0;                break;            }        }         //printf(&quot;min=%d\n&quot;,min);        if(flag)        {            flagz=1;            printf(&quot;%d\n&quot;,max);        }    }    if(!flagz)    {        printf(&quot;no saddle point\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T13</title>
    <link href="/2020/04/26/CprogrammingT13/"/>
    <url>/2020/04/26/CprogrammingT13/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T13"><a href="#C语言编程T13" class="headerlink" title="C语言编程T13"></a>C语言编程T13</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>四舍五入的函数是round()<br>向下取整的函数是floor()</strong><br>注意 : 题目要求</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/161.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define N 100int main(){    int saraly,houres,t,t1,i=0,g[N]={0};    float sh=0;    scanf(&quot;%d %d&quot;,&amp;saraly,&amp;houres);    sh=(float)saraly/houres;    printf(&quot;%.2f\n&quot;,sh);    t=round(sh);    printf( &quot;%d\n&quot;,t);    t1=t*t;    while(t1&gt;0)    {        g[i]=t1%10;        i++;        t1=t1/10;    }    printf(&quot;%d\n&quot;,i);    printf(&quot;%d %d %d\n&quot;,g[2],g[1],g[0]);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T12</title>
    <link href="/2020/04/25/CprogrammingT12/"/>
    <url>/2020/04/25/CprogrammingT12/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T12"><a href="#C语言编程T12" class="headerlink" title="C语言编程T12"></a>C语言编程T12</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>约束条件很重要，不要越界！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/149.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int Isprime(long x);int main(){    long int c,d,total=0,i;    printf(&quot;please input c,d(c&gt;2):\n&quot;);    scanf( &quot;%ld,%ld&quot;,&amp;c,&amp;d);    //这里可以约束    for(i=c;i&lt;=d-2;i++)    {        //这里也可以约束        if(Isprime(i)&amp;&amp;Isprime(i+2))        {            printf(&quot;(%ld,%ld)\n&quot;,i,i+2);            total++;            i=i+2;        }    }    printf(&quot;total=%d\n&quot;,total);    return 0;}int Isprime(long x){    int i=2;    for(i=2;i&lt;x;i++)    {        if(x%i==0)        {            return 0;        }    }    return 1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T11</title>
    <link href="/2020/04/24/CprogrammingT11/"/>
    <url>/2020/04/24/CprogrammingT11/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T11"><a href="#C语言编程T11" class="headerlink" title="C语言编程T11"></a>C语言编程T11</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><img src="/img/c_correction/141.1.png" srcset="/img/loading.gif" alt=""><br>定积分的几何意义！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/141.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;float Integral(float (*f)(float), float a, float b);float y1(float x);float y2(float x);int main(){    printf(&quot;y1=%f\ny2=%f\n&quot;,Integral(y1,0,1),Integral(y2,0,3));    return 0;}float y1(float x){    //printf(&quot;y1=%f\n&quot;,1+x*x);    return 1+x*x;}float y2(float x){    return x/(1+x*x);}float Integral(float (*f)(float), float a, float b){    int n=100;    int i=1;    double s=0;    for(i=1;i&lt;=100;i++)    {        s+=((b-a)/n)*f(i*(b-a)/n);        //printf(&quot;s=%f\n&quot;,s);    }    return s;}*/#include &lt;stdio.h&gt;float Fun1(float x);float Fun2(float x);float Integral(float (*f)(float), float a, float b);int main(){    float y1, y2;    y1 = Integral(Fun1, 0.0, 1.0);    y2 = Integral(Fun2, 0.0, 3.0);    printf(&quot;y1=%f\ny2=%f\n&quot;, y1, y2);    return 0;}/*  函数功能：计算函数1+x*x的函数值 */float Fun1(float x){    return  1 + x * x;}/*  函数功能：计算函数x/(1+x*x)的函数值 */float Fun2(float x){    return x / (1 + x * x);}/*    函数功能：用梯形法计算函数的定积分 */float Integral(float (*f)(float), float a, float b){    float s, h;    int n = 100, i;    s = ((*f)(a) + (*f)(b)) / 2;    h = (b - a) / n;    for (i = 1; i &lt; n; i++)    {        s += (*f)(a + i * h);    }    return s * h;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T10</title>
    <link href="/2020/04/23/CprogrammingT10/"/>
    <url>/2020/04/23/CprogrammingT10/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T10"><a href="#C语言编程T10" class="headerlink" title="C语言编程T10"></a>C语言编程T10</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>floor()函数的应用:向下取整函数！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/129.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;float a[5] = {2.33, 2.56, 2.65, 2.66, 2.30};float t(float x, int n);float t(float x, int n){    float x1, x2;    int i;    for (x1 = x, i = 0; i &lt; n - 1; i++)        x1 *= 10.0;    printf(&quot;x1=%f\n&quot;,x1);    x2 = floor((double)x1);     printf(&quot;x2=%f\n&quot;,x2);    x1 = floor((double)(x1 - x2) * 10);    if (x1 &gt;= 5)        x2 += 1;    for (i = 0; i &lt; n - 1; i++)        x2 /= 10.0;    return x2;}int main(){    int i;    printf(&quot;Old array:\n&quot;);    for (i = 0; i &lt; 5; i++)        printf(&quot;a[%d]=%.3f\t&quot;, i, a[i]);    printf(&quot;\nnew array:\n&quot;);    for (i = 0; i &lt; 5; i++)        printf(&quot;a[%d]=%.2f\t&quot;, i, t(a[i], 2));    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T9</title>
    <link href="/2020/04/21/CprogrammingT9/"/>
    <url>/2020/04/21/CprogrammingT9/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T9"><a href="#C语言编程T9" class="headerlink" title="C语言编程T9"></a>C语言编程T9</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>注意英语的语法规范，i have a apple….太难了，注意名称前可能有冠词！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/108.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>##include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int Length(char p[]);int IsAllDigit(char p[]);int main(){    char str[N];    int is;    printf(&quot;Please input a string:&quot;);    gets(str);    printf(&quot;The string has %d characters.\n&quot;,Length(str));    is=IsAllDigit(str);    if(is)    {        printf(&quot;The string is a digit string.&quot;);    }    else    {        printf(&quot;The string is not a digit string.&quot;);    }    return 0;}int Length(char p[]){    int i;    for(i=0;p[i]!=&#39;\0&#39;;i++);    return i;}int IsAllDigit(char p[]){    int i;    for(i=0;p[i]!=&#39;\0&#39;;i++)    {        if(p[i]&lt;&#39;0&#39;||p[i]&gt;&#39;9&#39;)        {            return 0;        }    }    return 1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T6</title>
    <link href="/2020/04/19/CorrectionT6/"/>
    <url>/2020/04/19/CorrectionT6/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T6"><a href="#C语言改错T6" class="headerlink" title="C语言改错T6"></a>C语言改错T6</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>字符串赋值:<strong>‘\0’也占字符数组一个字节</strong><br>char str[6]={‘C’\,’h’\,’i’\,’n’\,’a’\,’\0’};<br>char str[]={‘C’\,’h’\,’i’\,’n’\,’a’\,’\0’};<br>char str[]=”China”;<br>char *ptr=”China”;</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/92.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>strcpy()也可以用来字符串赋值</p><pre><code>#include &lt;stdio.h&gt;main(){    int i = 0;    char str[6] = {&#39;C&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;\0&#39;}, str1[6] , *ptr, *ptr1, *ptr2 ;    while (str[i] != &#39;\0&#39;)    {        putchar(str[i]);        i++;    }    ptr=str;    scanf(&quot;%s&quot;, ptr);    puts(ptr);    ptr1 = str;    puts(ptr1);    ptr2 = &quot;China&quot;;    puts(ptr2);    char str2[] = &quot;China&quot;;    printf(&quot;%s&quot;, str2);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T8</title>
    <link href="/2020/04/18/CprogrammingT8/"/>
    <url>/2020/04/18/CprogrammingT8/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T8"><a href="#C语言编程T8" class="headerlink" title="C语言编程T8"></a>C语言编程T8</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>注意英语的语法规范，1st,11th,21st…</strong><br>判断错误输入最好判断<strong>全面</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/87.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/87.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char month[13][20]={  &quot;none&quot;,&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,  &quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;};int main(){    int year,day,mon;    printf(&quot;Enter date (mm/dd/yy):&quot;);    scanf(&quot;%d/%d/%d&quot;,&amp;mon,&amp;day,&amp;year);    if(day&gt;31||day&lt;1||mon&gt;12||mon&lt;1)    {        printf(&quot;Input error!\n&quot;);    }    else    {        printf(&quot;Dated this %d&quot;,day);        switch(day)        {            case 1:            case 21:            case 31:                printf( &quot;st&quot;);                break;            case 2:            case 22:                printf( &quot;nd&quot;);                break;            case 3:            case 23:                printf( &quot;rd&quot;);                break;            default:                printf( &quot;th&quot;);        }        printf(&quot; day of %s&quot;,month[mon]);        printf(&quot;, 19%.2d.\n&quot;,year);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T7</title>
    <link href="/2020/04/18/CprogrammingT7/"/>
    <url>/2020/04/18/CprogrammingT7/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T7"><a href="#C语言编程T7" class="headerlink" title="C语言编程T7"></a>C语言编程T7</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>看清题目要求和计算公式</strong><br>求对角线之和,注意可能会重叠</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/82.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5int main(){    int a[N][N],i,j,s=0,t;    printf(&quot;Input a 5*5 matrix\n&quot;);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            scanf(&quot;%d&quot;,&amp;a[i][j]);        }        s+=a[i][i]+a[i][N-i-1];    }    /*for(i=0;i&lt;N;i++)    {    }*/    printf(&quot;sum=%5d\n&quot;,s-a[2][2]);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T5</title>
    <link href="/2020/04/17/CorrectionT5/"/>
    <url>/2020/04/17/CorrectionT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T5"><a href="#C语言改错T5" class="headerlink" title="C语言改错T5"></a>C语言改错T5</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>分清:<br>dstStr是目的，即要输出的<br>srcStr是源<br>故字符串是dstStr+srcStr,即srcStr在dstStr后面<br><strong>指针地址的变化与指针指向值的变化！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/79.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 80void MyStrcat(char *dstStr, char *srcStr);main() {    char s[N], t[N];    printf(&quot;Input a string:\n&quot;);    gets(s);    printf(&quot;Input another string:\n&quot;);    gets(t);    MyStrcat(s, t);    printf(&quot;Concatenate results:%s\n&quot;, s);}void MyStrcat(char *dstStr, char *srcStr) {    while (*dstStr != &#39;\0&#39;)    {        dstStr++;    }    while (*srcStr != &#39;\0&#39;)    {        *dstStr = *srcStr;        srcStr++;        dstStr++;    }    //分清楚指针改变地址和改变其指向的值    *dstStr=&#39;\0&#39;;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T6</title>
    <link href="/2020/04/17/CprogrammingT6/"/>
    <url>/2020/04/17/CprogrammingT6/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T6"><a href="#C语言编程T6" class="headerlink" title="C语言编程T6"></a>C语言编程T6</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>变量迭代，阶乘计算int型可能会溢出，最好使用double。<br><strong>注:考虑到各种情况，包括:取0、-1等边界测试时，其余输出是否会有矛盾!!!</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/77.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;//考虑为0的情况int main(){    double x,t,t1=1,sum=0,t2,esp;    int n=3,count=1;    printf(&quot;Enter x &amp; eps:&quot;);    scanf(&quot;%lf%lf&quot;,&amp;x,&amp;esp);    if(x!=0)    {        t2=sum=x;        do        {            t1=-t1*n*(n-1);            n+=2;            t2=t2*x*x;            t=t2/t1;            sum+=t;            count++;        }while(fabs(t)&gt;=esp);    }    printf(&quot;sin(%f)=%f\n&quot;,x,sin(x));    printf(&quot;%d,sin(%f)=%f\n&quot;,count,x,sum);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inspiration1.0</title>
    <link href="/2020/04/15/Whimsy1/"/>
    <url>/2020/04/15/Whimsy1/</url>
    
    <content type="html"><![CDATA[<h1 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h1><p><strong>This is my idea,I hope one day i can fulfil it.</strong></p><hr><h2 id="Project-And-Description"><a href="#Project-And-Description" class="headerlink" title="Project And Description"></a>Project And Description</h2><p>过年前后金价会上升 : 可建立对应信息库+求解最大子序列<br>背诵提醒 : 根据记忆曲线(艾宾浩斯遗忘曲线)提醒用户背诵对应内容<br>云网盘 : 通过云服务器构建一个类似属于自己的网盘<br>高校图表 : 面对高考生的高校报考信息推荐，Python爬虫+大数据(高校分数线+报录比)+Python可视化(生成对应的报表+不同维度)<br>彩虹屁生成器 : 花式夸人+英语夸人，自然语言处理</p>]]></content>
    
    
    <categories>
      
      <category>Whimsy</category>
      
      <category>Procject</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Project</tag>
      
      <tag>Inspiration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T5</title>
    <link href="/2020/04/15/CprogrammingT5/"/>
    <url>/2020/04/15/CprogrammingT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T5"><a href="#C语言编程T5" class="headerlink" title="C语言编程T5"></a>C语言编程T5</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>找规律，一一列举即可<br><strong>注:是否满足所有情况!!!</strong><br>要从最小值开始列举<br>不然有可能运算不了全部解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/60.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找最小、才能求解全部情况</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100//要从最小的开始计算int IsInArray(int a[],int n,int x);void ClearArray(int a[],int n,int x);int GetMinArray(int a[],int n);int main(){    int i,n,a[N]={-1},change=0,j,m=0;    printf(&quot;Input n:&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;Input card numbers:&quot;);    for(i=0;i&lt;n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);    }    for(i=0;i&lt;n;i++)    {        m=GetMinArray(a,n);        //printf(&quot;a[m]=%d\n&quot;,m);        if(m!=-1&amp;&amp;IsInArray(a,n,m+1)&amp;&amp;IsInArray(a,n,m+2))        {            ClearArray(a,n,m+2);            ClearArray(a,n,m+1);            ClearArray(a,n,m);            /*for(j=0;j&lt;n;j++)            {                printf(&quot;%d &quot;,a[j]);            }            printf(&quot;\n&quot;);*/            change++;        }    }    printf(&quot;Exchanged:%d\n&quot;,change);    return 0;}int IsInArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            return 1;        }    }    return 0;}void ClearArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            a[i]=-1;            break;        }    }}int GetMinArray(int a[],int n){    int i,j,min=-1;    for(i=0;i&lt;n;i++)    {        if(a[i]!=-1)        {            min=a[i];           // printf(&quot;min=%d\n&quot;,min);            for(j=0;j&lt;n;j++)            {                if(a[j]!=-1&amp;&amp;min&gt;a[j])                {                    min=a[j];                }            }        }        else        {            i++;        }    }    return min;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T4</title>
    <link href="/2020/04/13/CorrectionT4/"/>
    <url>/2020/04/13/CorrectionT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T4"><a href="#C语言改错T4" class="headerlink" title="C语言改错T4"></a>C语言改错T4</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>指针数组要初始化<br><strong>指针都要初始化</strong><br>认真检查代码正确性:for(里面),数组交换位置,while();</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/39.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include  &lt;stdio.h&gt;#include &lt;string.h&gt;#define   MAX_LEN  10#define   N         150void SortString(char *ptr[], int n);main(){    int    i, n;    char   str[N][MAX_LEN],*pStr[N];    printf(&quot;How many countries?\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    getchar();    printf(&quot;Input their names:\n&quot;);    for (i=0; i&lt;n; i++)    {        pStr[i]=str[i];        gets(pStr[i]);        //printf(&quot;sr=%s\n&quot;,pStr[i]);    }    SortString(pStr,n);    printf(&quot;Sorted results:\n&quot;);    for (i=0; i&lt;n; i++)    {        puts(pStr[i]);    }}void SortString(char *ptr[], int n){    int    i, j;    char  *temp;    for (i=0; i&lt;n-1; i++)    {        for (j = i+1; j&lt;n; j++)        {            if (strcmp(ptr[i],ptr[j])&gt;0)            {                temp = ptr[i];                ptr[i] = ptr[j];                ptr[j] = temp;            }        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T4(妙)</title>
    <link href="/2020/04/13/CprogrammingT4/"/>
    <url>/2020/04/13/CprogrammingT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T4-妙"><a href="#C语言编程T4-妙" class="headerlink" title="C语言编程T4(妙)"></a>C语言编程T4(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>知规律，且有限，可迭代暴力破解</p><h3 id="思路一-回溯"><a href="#思路一-回溯" class="headerlink" title="思路一:回溯"></a>思路一:回溯</h3><p>只要将2、3、4、5放在不同位置,满足约束条件即可<br>又因2,3,4,5有规律,可递增尝试，递减回溯<br>所以找到回溯判定条件以及相应操作即可<br>此法较复杂</p><h3 id="思路二-穷举-正向思维"><a href="#思路二-穷举-正向思维" class="headerlink" title="思路二:穷举(正向思维)"></a>思路二:穷举(正向思维)</h3><p>因为只要将2、3、4、5放在四个不同位置，且其有规律<br>故采用四层或者三层for循环即可遍历所有可能解<br>所有只要输出满足约束条件的解即可<br><img src="/img/c_correction/45.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>何时回溯、何时穷举！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//强行穷举!!!#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6int main(){    int i, j, k, m, n, num;    int a[N];    a[0] = 1;    a[5] = 6;    num = 0;    printf(&quot;The possible table satisfied above conditions are:\n&quot;);    for (i = 2; i &lt;= 5; i++)        for (j = 2; j &lt;= 5; j++)            for (n = 2; n &lt;= 5; n++)                for (m = 2; m &lt;= 5; m++)                {                    a[1] = i;                    a[2] = j;                    a[3] = n;                    a[4] = m;                    if (a[2] &gt; a[1] &amp;&amp; a[4] &gt; a[3] &amp;&amp; a[4] &gt; a[1] &amp;&amp; a[1] != a[3] &amp;&amp; a[2] != a[3] &amp;&amp; a[2] != a[4])                    {                        num++;                        printf(&quot;\nNo.:%d&quot;, num);                        for (k = 0; k &lt; 6; k++)                        {                            if (k % 3 == 0)                                printf(&quot;\n&quot;);                            printf(&quot;%3d&quot;, a[k]);                        }                    }                }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T3(妙)</title>
    <link href="/2020/04/13/CprogrammingT3/"/>
    <url>/2020/04/13/CprogrammingT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T3-妙"><a href="#C语言编程T3-妙" class="headerlink" title="C语言编程T3(妙)"></a>C语言编程T3(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一-暴力破解-正向思维"><a href="#思路一-暴力破解-正向思维" class="headerlink" title="思路一:暴力破解(正向思维)"></a>思路一:暴力破解(正向思维)</h3><p>不断尝试各种数字,逐一尝试<br>但是由于n不确定,所以不知道要嵌套多少for和准备多少临时变量<br>故不可使用穷举法</p><h3 id="思路二-回溯-逆向思维"><a href="#思路二-回溯-逆向思维" class="headerlink" title="思路二:回溯(逆向思维)"></a>思路二:回溯(逆向思维)</h3><p><strong>从后往前观察思考，找到其规律</strong><br>采用数组,从后往前,逐一尝试,不符或者满足则采用不同的回溯，直至得出所有解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/42.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找规律 : 正向、逆向、解中有规律</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 10int main(){    int i[N];    int sum,n,total,k,flag=0,count=0;    printf(&quot;Please enter requried terms (&lt;=10):&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf( &quot;                             their sum:&quot;);    scanf(&quot;%d&quot;,&amp;total);    sum=0;    k=n;    //从后往前推导    i[n]=1;    printf(&quot;There are following possible series:\n&quot;);    while(1)    {        if(sum+i[k]&lt;total)        {            if(k&lt;=1)            {                i[1]=total-sum;                flag=1;            }            else            {                sum+=i[k];                k--;                //从最小值开始往前赋值                i[k]=i[k+1];                continue;                //继续while循环判断            }        }        //sum在中间已经大于可total        else if(sum+i[k]&gt;total||k!=1)        {            //想办法回溯            //减去上一个sum加的i[k]            sum-=i[++k];            flag=0;        }        else//sum+i[k]==total&amp;&amp;k==1        {            flag=1;        }        if(flag)        {             printf(&quot;[%d]:&quot;,++count);            for(flag=1;flag&lt;=n;++flag)                printf(&quot;%d&quot;,i[flag]);            printf(&quot;\n&quot;);        }        //判断i[n]是否已经变化到极致        if(++k&gt;n)        {            break;        }        //往后回溯        sum-=i[k];        //不断试探        i[k]++;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T2</title>
    <link href="/2020/04/12/CprogrammingT2/"/>
    <url>/2020/04/12/CprogrammingT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T2"><a href="#C语言编程T2" class="headerlink" title="C语言编程T2"></a>C语言编程T2</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="判断素数可以通过sqrt-或者x-2来降低循环次数"><a href="#判断素数可以通过sqrt-或者x-2来降低循环次数" class="headerlink" title="判断素数可以通过sqrt()或者x/2来降低循环次数"></a>判断素数可以通过sqrt()或者x/2来降低循环次数</h3><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用long long或者unsigned long 来存储2的i次幂<br>计算2的i次幂可以迭代计算,节省时间</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用double来存储2的i次幂<br>注 :</p><ol><li><p>pow()返回的double型，所以将其转换为int型时容易有精度误差，容易出错！！！<br>所以常使用while循环迭代计算<br>2.浮点型(float,double)不可以进行取余运算<br>故判断是否整除可以通过整型的除法特性计算(1/2==0)<br>即:x/i == (long long)(x/i)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/33.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>切记 : pow()的精度误差，一般在int型中不用！！！<br>``` </p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdlib.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <math.h></h1><p>int IsPrime(double x);<br>int main()<br>{<br> int i,count=0,n;<br> double s=0;<br> printf(“Input n:\n”);<br> scanf(“%d”,&amp;n);<br> for(i=2;i&lt;=n;i++)<br> {</p><pre><code> s=pow(2,i)-1; if(IsPrime(s)==1) {     printf(&quot;2^%d-1=%.0f\n&quot;,i,s);     count++; }</code></pre><p> }</p><p> printf(“count=%d\n”,count);<br> return 0;<br>}<br>int IsPrime(double x)<br>{<br> int i;<br> for(i=2;i&lt;sqrt(x);i++)<br> {</p><pre><code> if(x/i == (long long)(x/i)) {     return 0; }</code></pre><p> }<br> return 1;<br>}</p></li></ol><p>```</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T3</title>
    <link href="/2020/04/11/CorrectionT3/"/>
    <url>/2020/04/11/CorrectionT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T3"><a href="#C语言改错T3" class="headerlink" title="C语言改错T3"></a>C语言改错T3</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><h3 id="分清"><a href="#分清" class="headerlink" title="分清:"></a>分清:</h3><p>1.指针数组:  int *p[4]<br><strong>常用于字符串交换,因为相比strcpy()更加节省时间和空间</strong><br><strong>故使用指针数组进行交换效率更高索引技术、索引排序</strong></p><blockquote><p>函数中使用:<br>void Fun(int *p[M]);<br>Fun(p);</p></blockquote><p>2.二维数组的 行指针 :  int (*p)[4] </p><blockquote><p>p[i]==*(p+i):也就是p[i]的地址！！！<br>p[i][j] == *(p[i]+j) == *(*(p+i)+j) == (*(a+i))[j]<br>&amp;p[i][j] == p[i]+j == *(p+i)+j<br>函数中使用:<br>void Fun(int (*p)[M]);<br>Fun(p);//p == p[0] == p[0]的地址</p></blockquote><p>3.二维数组的列指针 :  int *p; p=*a</p><blockquote><p>p=*a &lt;==&gt; p=a[0] &lt;==&gt; p=&amp;a[0][0]<br>a[i][j]=*(p+i*n+j)<br>&amp;a[i][j]=p+i*n+j<br>函数中使用:<br>void Fun(int *p);<br>Fun(*p);</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/28.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:指针数组的妙用！！！</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;void Input(char *p[], int n);void Sort(char *p[], int n);void Print(char *p[], int n);int main(){                    char str[20][40];    char *pstr[20];    int i, n;    printf(&quot;Input n(n&lt;=20):\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    //注意要清空缓冲区里的空格    getchar();    for (i = 0; i &lt; n; i++)    {                  //指针数组要初始化        pstr[i] = str[i];           //2    }    Input(pstr, n);    Sort(pstr, n);    printf(&quot;Results:\n&quot;);    Print(pstr, n);    return 0;}                void Input(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        gets(p[i]);    }}                void Sort(char *p[], int n){                    char *t;                              //1    int i, j;    for (i = 0; i &lt; n - 1; i++)    {                        //注:j=i+1而不是1        for (j = i + 1; j &lt; n; j++)        {                            if (strcmp(p[j], p[i]) &lt; 0)    //2            {                       //直接用指针数组来简化strcpy()                t = p[i];                p[i] = p[j];                p[j] = t;            }        }    }}                void Print(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        printf(&quot;%s\n&quot;, p[i]);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T2</title>
    <link href="/2020/04/11/CorrectionT2/"/>
    <url>/2020/04/11/CorrectionT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T2"><a href="#C语言改错T2" class="headerlink" title="C语言改错T2"></a>C语言改错T2</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br><strong>换行、空格到底要不要???</strong>(没有特殊提示应该不用吧~now)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/27.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>多了一个换行~</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int mon[][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},    {0,31,29,31,30,31,30,31,31,30,31,30,31},};int  DayofYear(int year, int month, int day);void  MonthDay(int year, int yearDay, int *pMonth, int *pDay);int main(){    int choice,year,month,day,yearday,pmonth,pday;    printf(&quot;1. year/month/day -&gt; yearDay\n&quot;);    printf(&quot;2. yearDay -&gt; year/month/day\n&quot;);    printf(&quot;3. Exit\n&quot;);    //这里不用换行了！！！    printf(&quot;Please enter your choice:&quot;);    scanf(&quot;%d&quot;,&amp;choice);    switch(choice)    {    case 1:        printf(&quot;Please enter year, month, day:&quot;);        scanf(&quot;%d,%d,%d&quot;,&amp;year,&amp;month,&amp;day);        yearday=DayofYear(year,month,day);        printf(&quot;yearDay = %d\n&quot;,yearday);        break;    case 2:        printf(&quot;Please enter year, yearDay:&quot;);        scanf(&quot;%d,%d&quot;,&amp;year,&amp;yearday);        MonthDay(year,yearday,&amp;pmonth,&amp;pday);        printf(&quot;month = %d,day = %d\n&quot;,pmonth,pday);        break;    case 3:        return 0;    }    return 0;}int  DayofYear(int year, int month, int day){    int i,leap,d=day;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    for(i=0;i&lt;month;i++)    {        d+=mon[leap][i];    }    return d;}void  MonthDay(int year, int yearDay, int *pMonth, int *pDay){    int i=0,leap;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    while(1)    {        yearDay-=mon[leap][i];        i++;        if(yearDay&lt;mon[leap][i])        {            break;        }    }    *pMonth=i;    *pDay=yearDay;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T1</title>
    <link href="/2020/04/11/CprogrammingT1/"/>
    <url>/2020/04/11/CprogrammingT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T1"><a href="#C语言编程T1" class="headerlink" title="C语言编程T1"></a>C语言编程T1</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用gets()/scanf()直接输入字符串<br>1.考虑符号和数字的分离、判断输入是否正确<br>2.采用栈或者队列来进行运算<br>综上所述:较为复杂！！！</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用getchar()直接输入字符<br>1.一个一个字符输入，故要进行分类计算(if),判断何时计算、何时停止<br>2.通过代码顺序实现类似栈的操作<br>可以一试！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/24.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心 : 在得到第二个运算符时，计算前一个运算符!!!</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    int num, num1, op;    char ch;    //用来计算最先输入的数    num = 0;//第一个数    num1 = 0;//第二个数    op = &#39;+&#39;;    do    {        ch = getchar();        if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        {        //将输入的字符12转换成数字12            num1 = num1 * 10 + (ch - &#39;0&#39;);        }        else        {        //计算前一个运算符!!!            if (op == &#39;+&#39;)            {                num = num + num1;            }            else if (op == &#39;-&#39;)            {                num = num - num1;            }            else if (op == &#39;*&#39;)            {                num = num * num1;            }            else if (op == &#39;/&#39;)            {                num = num / num1;            }            else            {                printf(&quot;错误的运算符：%c&quot;, op);                exit(0);            }         //不得不说...神奇         op = ch;         //初始化         num1 = 0;        }    }while (ch != &#39;=&#39;);    printf(&quot;%d&quot;, num);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T1</title>
    <link href="/2020/04/10/CorrectionT1/"/>
    <url>/2020/04/10/CorrectionT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T1"><a href="#C语言改错T1" class="headerlink" title="C语言改错T1"></a>C语言改错T1</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br>2.严格根据题目约束条件、<strong>理论结合实际</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/23.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/23.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int main(){    char str1[N],str2[N];    int i,j;    printf(&quot;\n输入字符串：&quot;  );    gets(str1);    i=j=0;    for(i=0;str1[i]!=&#39;\0&#39;;i++)    {    //什么叫元音字母！！！        if(str1[i]==&#39;e&#39;||str1[i]==&#39;o&#39;||str1[i]==&#39;a&#39;||str1[i]==&#39;i&#39;||str1[i]==&#39;u&#39;)        {            str2[j]=str1[i];            j++;        }    }    str2[j]=&#39;\0&#39;;    //还要输出这个！！！    printf(&quot;%s&quot;,str1);    printf(&quot;\n字符串中的元音字母是%s&quot;,str2);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用网站</title>
    <link href="/2020/04/10/web1.0/"/>
    <url>/2020/04/10/web1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Practical-websites"><a href="#Practical-websites" class="headerlink" title="Practical websites"></a>Practical websites</h1><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="图片海报"><a href="#图片海报" class="headerlink" title="图片海报 :"></a>图片海报 :</h4><p>创客贴 : <a href="https://www.chuangkit.com/templatecenter" target="_blank" rel="noopener">https://www.chuangkit.com/templatecenter</a></p><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩 :"></a>图片压缩 :</h4><p>Recompressor : <a href="https://recompressor.com/" target="_blank" rel="noopener">https://recompressor.com/</a><br>Squoosh : <a href="https://squoosh.app/" target="_blank" rel="noopener">https://squoosh.app/</a><br>Tingpng : <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><h4 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历 :"></a>个人简历 :</h4><p>超级简历 :  <a href="https://www.wondercv.com/" target="_blank" rel="noopener">https://www.wondercv.com/</a></p><h4 id="写作"><a href="#写作" class="headerlink" title="写作 :"></a>写作 :</h4><p>Get写作 : <a href="https://getgetai.com/" target="_blank" rel="noopener">https://getgetai.com/</a><br>Markdown编辑器 : <a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a><br>英语写作 : <a href="http://www.1checker.com/" target="_blank" rel="noopener">http://www.1checker.com/</a></p><h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图 :"></a>绘图 :</h4><p>Processon 支持流程图、思维导图\UML、网络拓扑图、组织结构图等 : <a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></p><h3 id="Study"><a href="#Study" class="headerlink" title="Study"></a>Study</h3><h4 id="论文"><a href="#论文" class="headerlink" title="论文 :"></a>论文 :</h4><p>Communications of the ACM : <a href="https://cacm.acm.org/" target="_blank" rel="noopener">https://cacm.acm.org/</a><br>中国知网 : <a href="https://www.cnki.net/" target="_blank" rel="noopener">https://www.cnki.net/</a><br>笔杆查重 : <a href="https://www.bigan.net/" target="_blank" rel="noopener">https://www.bigan.net/</a><br>Paperpass : <a href="https://www.paperpass.com/" target="_blank" rel="noopener">https://www.paperpass.com/</a></p><h4 id="视频"><a href="#视频" class="headerlink" title="视频 :"></a>视频 :</h4><p>中国大学MOOC : <a href="https://www.icourse163.org/" target="_blank" rel="noopener">https://www.icourse163.org/</a><br>慕课网-程序员 :  <a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com/</a><br>网易云课堂 : <a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a><br>网易公开课 : <a href="https://open.163.com/" target="_blank" rel="noopener">https://open.163.com/</a><br>爱课程 : <a href="https://sso.icourses.cn" target="_blank" rel="noopener">https://sso.icourses.cn</a><br>Coursera : <a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org/</a><br>盗盗盗 : <a href="https://ctokey.com/" target="_blank" rel="noopener">https://ctokey.com/</a></p><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网:"></a>科学上网:</h4><p>DogCould : <a href="https://www.ggjs.xyz/" target="_blank" rel="noopener">https://www.ggjs.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>Gadgets</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马3.0</title>
    <link href="/2020/04/10/Chess3.0/"/>
    <url>/2020/04/10/Chess3.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马3-0"><a href="#跳跳马3-0" class="headerlink" title="跳跳马3.0"></a>跳跳马3.0</h1><hr><p>进一步对跳跳马2.0程序输入和输出界面的优化:<br>1.添加了一些界面提示语句<br>2.进行了代码局部优化</p><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现:"></a>1.代码实现:</h2><hr><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 64int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col,n;    printf(&quot;输入顶点数目:\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;n=%d\n&quot;,n);    for(i=0;i&lt;n;i++)    {        b[i]=-1;        c[i]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            a[i][j]=0;        }    }    do    {        printf(&quot;请输入对应的边(x y 1)(输入一半即可,-1表示结束):\n&quot;);        scanf(&quot;%d%d&quot;,&amp;i,&amp;j);        scanf(&quot;%d&quot;,&amp;a[i][j]);        //printf(&quot;(%d,%d)=%d\n&quot;,i,j,a[i][j]);        //printf(&quot;res=%d\n&quot;,res);        a[j][i]=a[i][j];    }while(i!=-1);    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;n)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,n))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;n-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=n);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;n;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>只是完成了最基本的可视化界面。<br>查询理论上可以继续优化:<br>主要思路:<br>1.可以尝试使用邻接表来存储，节约存储空间，但是回溯是一个问题。<br>2.可以尝试使用动态规划，理论上应该满足优化子结构和重叠子问题。<br>3.可以进一步优化输入输出，目标:上传图片，使其自动化处理棋盘和生成对应的图:</p><blockquote><p>Think:<br>图像处理、模式识别、数据可视化</p><h4 id="未完待续-2020-4-10—-gt"><a href="#未完待续-2020-4-10—-gt" class="headerlink" title="未完待续(2020.4.10—&gt;)"></a>未完待续(2020.4.10—&gt;)</h4></blockquote>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马2.0</title>
    <link href="/2020/04/09/Chess2.0/"/>
    <url>/2020/04/09/Chess2.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马2-0"><a href="#跳跳马2-0" class="headerlink" title="跳跳马2.0"></a>跳跳马2.0</h1><hr><p>依旧是采用跳跳马1.0的思想；将棋盘中的马与小兵抽象成结点，结点的可达关系作为对应结点的边。</p><h2 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1.解决方法:"></a>1.解决方法:</h2><hr><h3 id="1-1-主要思想"><a href="#1-1-主要思想" class="headerlink" title="1.1 主要思想:"></a>1.1 主要思想:</h3><p>2.0用邻接矩阵来存储图，使用BFS(Breadth First Search)策略，并且采用数组来存储上一步经过的结点，故只要不满足约束条件时，利用此数组即可回溯到上一结点</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现:"></a>2.代码实现:</h2><hr><p>可以正确执行！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 14int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col;    for(i=0;i&lt;N;i++)    {        b[i]=-1;        c[N]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            a[i][j]=0;        }    }    do    {        scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;a[i][j]);    }while(i!=-1);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;N)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,N))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;N-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=N);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;N;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>对应的界面还未完善，只是实现了最核心的功能<br>代码的时间复杂度和空间复杂度应该可以进一步优化。</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马1.0</title>
    <link href="/2020/04/08/Chess1.0/"/>
    <url>/2020/04/08/Chess1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马1-0"><a href="#跳跳马1-0" class="headerlink" title="跳跳马1.0"></a>跳跳马1.0</h1><h2 id="1-游戏介绍"><a href="#1-游戏介绍" class="headerlink" title="1.游戏介绍:"></a>1.游戏介绍:</h2><hr><p>根据国际象棋的规则和棋盘大小，并且遵守马的行走规则，使用马将棋盘中的所有小兵都吃完，即通关计分。<br>具体游戏界面如下图:<br><img src="/img/Chessimg/chess1.jpg" srcset="/img/loading.gif" alt=""></p><center>游戏界面 </center><h2 id="2-实际问题"><a href="#2-实际问题" class="headerlink" title="2.实际问题:"></a>2.实际问题:</h2><hr><p>随着通过的关卡越多，小兵的数量也越多，而马只要走错一步就直接结束游戏，因此在每一步都必须十分正确，所以有必要使用程序来辅助玩家选择最恰当的路径，进而通关</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法:"></a>3.解决方法:</h2><hr><h3 id="3-1使用到的相关知识"><a href="#3-1使用到的相关知识" class="headerlink" title="3.1使用到的相关知识:"></a>3.1使用到的相关知识:</h3><p>关键词 : 抽象、图、DFS、BFS、栈、回溯、哈密顿图</p><blockquote><p>《离散数学引论》:<br>哈密顿图 : 存在一条哈密顿圈<br>哈密顿路 : 图中存在一条经过所有节点并且不重复的路</p><h3 id="3-2-主要思想"><a href="#3-2-主要思想" class="headerlink" title="3.2 主要思想:"></a>3.2 主要思想:</h3><p>将马和小兵抽象成图上的结点，如果小兵与小兵之间或者小兵与马之间满足马的行走规则,则将其连线，从而形成一张图，进而转换成求图上的哈密顿路问题。<br>如下图:<br><img src="/img/Chessimg/chess2.jpg" srcset="/img/loading.gif" alt=""><br>寻找一条哈密顿路:<br><img src="/img/Chessimg/chess3.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现:"></a>4.代码实现:</h2><p>使用邻接矩阵来存储图，采用BFS策略来进行路径的选择，通过节点间的度的关系来进行回溯约束，并且采用栈来存储之前遍历过的结点。<br>``` </p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<stdlib.h></h1><p>//邻接矩阵结构<br>typedef int VertexType;<br>typedef int EdgeType;</p></blockquote><h1 id="define-MAX-20"><a href="#define-MAX-20" class="headerlink" title="define MAX 20"></a>define MAX 20</h1><h1 id="define-INFINITY-65535"><a href="#define-INFINITY-65535" class="headerlink" title="define INFINITY 65535"></a>define INFINITY 65535</h1><h1 id="define-TRUE-1"><a href="#define-TRUE-1" class="headerlink" title="define TRUE 1"></a>define TRUE 1</h1><h1 id="define-FALSE-0"><a href="#define-FALSE-0" class="headerlink" title="define FALSE 0"></a>define FALSE 0</h1><p>typedef int Boole;  //布尔类型 存储TRUE FALSE<br>Boole visited[MAX];    //访问标志数组<br>Boole Svisited[MAX];   //已经入栈标志<br>int Stack[MAX];//用来存放图的顶点<br>    int top=0;//栈顶<br>typedef struct<br>{<br>    VertexType vexs[MAX];   //顶点表<br>    EdgeType arc[MAX][MAX];   //邻接矩阵 可看作边表<br>    int numVertexes,numEdges;<br>    //int GraphType;  //图的类型  无向0,有向1<br>}MGraph;<br>//循环队列<br>typedef struct{<br>int data[10];<br>int rear,front;<br>}Quene,*pQueue;</p><p>void init(pQueue q){<br>    q-&gt;front=0;<br>    q-&gt;rear=0;<br>}</p><p>void destroyQueue(pQueue q){<br>    free(q);<br>    q=NULL;<br>}<br>void add(pQueue q,int x){<br>    if((q-&gt;rear+1)%10==q-&gt;front){<br>        printf(“overflow”);<br>        return ;<br>    }else{<br>        q-&gt;rear=(q-&gt;rear+1)%10;<br>        q-&gt;data[q-&gt;rear]=x;<br>        printf(“入队成功\n”);<br>    }<br>}<br>int  DeQueue(pQueue q){<br>    int e=0;<br>    if(q-&gt;front==q-&gt;rear){<br>        printf(“null”);<br>        return e;<br>    }else{<br>        q-&gt;front=(q-&gt;front+1)%10;<br>       // printf(“q-&gt;front=%d\n”,q-&gt;front);<br>        printf(“删除的元素是:%d\n”,q-&gt;data[q-&gt;front]);<br>        e=q-&gt;data[q-&gt;front];</p><pre><code>}return e;</code></pre><p>}</p><p>void traverseQuene(pQueue q){<br>    int i=q-&gt;front;<br>    while(i!=q-&gt;rear){<br>        i=(i+1)%10;<br>        printf(“%d “,q-&gt;data[i]);<br>    }<br>    printf(“\n”);<br>}</p><p>//队长度<br>int QueueLength(pQueue q){<br>    return (q-&gt;rear)-(q-&gt;front)+10%10;<br>}<br>//构造图   有向图和无向图<br>void create(MGraph *G)<br>{<br>    int i,j,k,w;<br>    printf(“请输入顶点数,边数:\n”);<br>    scanf(“%d,%d”,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<br>    fflush(stdin);<br>    for(i=0;i<G->numVertexes;i++)     //建立顶点表<br>    {<br>        //printf(“\n第%d个顶点”,i);<br>        //scanf(“%c”,&amp;G-&gt;vexs[i]);<br>        //getchar();<br>        G-&gt;vexs[i]=i;<br>    }</p><pre><code>for(i=0;i&lt;G-&gt;numVertexes;i++)   //矩阵初始化    for(j=0;j&lt;G-&gt;numVertexes;j++)        G-&gt;arc[i][j]=INFINITY;for(k=0;k&lt;G-&gt;numEdges;k++){    printf(&quot;输入边（Vi,Vj）的上下标i,j：&quot;);    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    G-&gt;arc[i][j]=1;    //if(G-&gt;GraphType==0)      //此时为无向图   有向图与无向的区别就只是这一行代码的有无    G-&gt;arc[j][i]=G-&gt;arc[i][j];}</code></pre><p>}</p><p>void Output(MGraph *G)     //输出邻接矩阵<br>{<br>    int i,j,count=0;<br>    for(i=0;i<G->numVertexes;i++)<br>        printf(“\t%d”,G-&gt;vexs[i]);<br>    printf(“\n”);<br>    for(i=0;i<G->numVertexes;i++)<br>    {<br>        printf(“%4d”,G-&gt;vexs[i]);<br>        for(j=0;j<G->numVertexes;j++)<br>        {</p><pre><code>            printf(&quot;\t%d&quot;,G-&gt;arc[i][j]);            count++;            if(count%G-&gt;numVertexes==0)            printf(&quot;\n&quot;);    }}</code></pre><p> }</p><p>/*<br>//一次遍历全部顶点<br>void OneS(MGraph G){<br>    int i,j;<br>    //所有点标记为新点<br>    for(i=0;i&lt;G.numVertexes;i++){<br>        visited[i]=FALSE;<br>        Svisited[i]=FALSE;<br>        Stack[i]=-1;<br>    }<br>    Stack[0]=G.vexs[0];<br>    visited[0]=TRUE;//已经在栈中<br>    top=0;<br>    while(top!=G.numVertexes-1){<br>        for(i=1;i&lt;G.numVertexes;i++){<br>            printf(“i=%d G.arc[Stack[top]][i]=%d !visited[i]=%d !Svisited[i]=%d\n “,i,G.arc[Stack[top]][i],!visited[i],!Svisited[i]);<br>            if(G.arc[Stack[top]][i]!=INFINITY&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){//找邻接点<br>                PrintStack();<br>                top++;<br>                Stack[top]=G.vexs[i];<br>                visited[i]=TRUE;//此点已经入栈<br>            }<br>        }</p><pre><code>    if(i==G.numVertexes){        //退栈,表示此点不可达        Svisited[Stack[top]]=TRUE;        visited[Stack[top]]=FALSE;        Queue[rear]=Stack[top];//入队        rear++;        Stack[top]=-1;        top--;    }    printf(&quot;top=%d,G.numVertexes-1=%d\n&quot;,top,G.numVertexes-1);    if(rear-front==2){//出队        Svisited[Queue[front]]=FALSE;        front++;    }    printf(&quot;rear=%d\n&quot;,rear);}</code></pre><p>}*/</p><p>//打印栈<br>void PrintStack(){<br>    for(int i=0;i&lt;=top;i++){<br>        printf(“%d-&gt;”,Stack[i]);<br>    }<br>    printf(“&lt;\n”);<br>}</p><p>void PrintQueue(Queue Q){<br>    for(int i=0;i&lt;=top;i++){<br>            printf(“%d-&gt;”,Q-&gt;data[i]);<br>        }<br>        printf(“&lt;\n”);<br>}</p><p>//返回结点n的度<br>int NodeDu(MGraph G,int n){<br>    int count=0;<br>    for(int i=0;i&lt;G.numVertexes;i++){<br>        if(G.arc[n][i]==1){<br>            count ++;<br>        }<br>    }<br>    return count;<br>}<br>void PrintNodeDu(MGraph G){<br>    for(int i=0;i&lt;G.numVertexes;i++){<br>        printf(“顶点%d的度:%d”,i,NodeDu(G,i));<br>    }<br>}<br>void OnceSearch(MGraph G){<br>    int i,e;<br>    pQueue q=(pQueue)malloc(sizeof(Quene));//用来存放已经出栈的顶点<br>    //打印顶点<br>    for(i=0;i&lt;G.numVertexes;i++){<br>        printf(“顶点:%d\n”,G.vexs[i]);<br>        visited[i]=FALSE;//标记所有顶点都未被访问<br>        Svisited[i]=FALSE;//标记所有顶点都未被退栈<br>    }<br>    //栈,队初始化<br>    init(q);<br>    Stack[top]=G.vexs[0];<br>    //如果栈里元素=顶点数,则找到路径<br>    int Stop=0;//判断栈顶第二元素是否变化<br>    while((top+1)!=G.numVertexes){<br>        //找相邻结点<br>        for(i=1;i&lt;G.numVertexes;i++){<br>            if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){<br>                //记录栈顶第二元素</p><pre><code>            top++;            Stack[top]=G.vexs[i];            visited[i]=TRUE;        }    }     Stop=Stack[top-1];    printf(&quot;second STop=%d\n&quot;,Stop);     PrintStack();    //如果遍历所有相邻结点都没有找到合适结点,则退栈入队重新再找    if(0&lt;(top)&amp;&amp;(top+1)!=G.numVertexes){        //如果栈顶第二元素变化,说明已经退出第二层,则需要出队        add(q,Stack[top]);        Svisited[Stack[top]]=TRUE;        visited[Stack[top]]=FALSE;        printf(&quot;退栈结点:%d\n&quot;,Stack[top]);        top--;        traverseQuene(q);//打印队列        printf(&quot;此时队列元素个数为:%d\n&quot;,QueueLength(q));        printf(&quot;此时栈顶元素Stack[%d]=%d的度为:%d\n&quot;,top,Stack[top],NodeDu(G,Stack[top]));        if(QueueLength(q)==NodeDu(G,Stack[top])){            printf(&quot;进入删除队列:&quot;);            for(i=0;i&lt;NodeDu(G,Stack[top])-1;i++){                e=DeQueue(q);                Svisited[e]=FALSE;                visited[e]=FALSE;            }            /*add(q,Stack[top]);            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            printf(&quot;退栈结点:%d\n&quot;,Stack[top]);            top--;*/        }        printf(&quot;打印队列:&quot;);            traverseQuene(q);//打印队列            printf(&quot;此时可入栈结点:&quot;);            for(i=0;i&lt;G.numVertexes;i++){                if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                    printf(&quot; %d &quot;,G.vexs[i]);                }            }        printf(&quot;\ntop=%d\n&quot;,top);    }}</code></pre><p>}</p><p>int main()<br>{<br>    MGraph G;<br>    int i,j;<br>    //printf(“输入生成图的类型(无向图0/有向图1)：”);<br>    //scanf(“%d”,&amp;G.GraphType);<br>    create(&amp;G);<br>    printf(“邻接矩阵数据如下：\n”);<br>    Output(&amp;G);<br>    printf(“\n”);<br>    //PrintNodeDu(G);<br>    OnceSearch(G);<br>    printf(“\n图遍历完毕\n”);<br>    PrintStack();<br>    return 0;<br>}</p><p>```</p><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>代码功能没有实现，应该是回溯栈的选择和约束条件的问题，以后有机会在实现~</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TestMarkdown</title>
    <link href="/2020/04/07/first/"/>
    <url>/2020/04/07/first/</url>
    
    <content type="html"><![CDATA[<h1 id="这是H1标题"><a href="#这是H1标题" class="headerlink" title="这是H1标题"></a>这是H1标题</h1><p>&nbsp;&nbsp;如何缩进,这是空格….<br>以下可写内容<br>分割线</p><hr><h2 id="这是H2标题"><a href="#这是H2标题" class="headerlink" title="这是H2标题"></a>这是H2标题</h2><p>直接写？？？</p><h3 id="这是H3标题-故标题以此类推"><a href="#这是H3标题-故标题以此类推" class="headerlink" title="这是H3标题(故标题以此类推)"></a>这是H3标题(故标题以此类推)</h3><pre><code>$ hexo new &quot;My New Post&quot;代码部分这样写?</code></pre><p>添加链接<br>More info: <a href="https://github.com/YinGuoX" target="_blank" rel="noopener">MyGitHub</a><br>添加图片<br><img src="/img/avatar.png" srcset="/img/loading.gif" alt=""></p><center>如何居中</center><p>记得&lt;/center&gt;后要空一行</p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
      <category>Markdown基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
