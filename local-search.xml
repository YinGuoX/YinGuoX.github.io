<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Code One Hour：Matplotlib-Base-Four</title>
    <link href="/2020/07/26/Code_One_Hour9/"/>
    <url>/2020/07/26/Code_One_Hour9/</url>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib使用-基础篇Four"><a href="#Matplotlib使用-基础篇Four" class="headerlink" title="Matplotlib使用-基础篇Four"></a>Matplotlib使用-基础篇Four</h1><p>(来源于莫凡PYTHON)</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>本节知识点如下：</p><ul><li>实现多图：<ul><li>plt.subplot()</li><li>plt.subplot2grid()</li><li>gridspec.GridSpec()</li></ul></li><li>plt.subplots()</li><li>图中图：fig.add_axes()、plt.axes()</li><li>次坐标轴：ax.twinx()</li></ul><h2 id="Subplot实现多图"><a href="#Subplot实现多图" class="headerlink" title="Subplot实现多图"></a>Subplot实现多图</h2><h3 id="均匀多图"><a href="#均匀多图" class="headerlink" title="均匀多图"></a>均匀多图</h3><pre><code class="lang-python">import matplotlib.pyplot as pltplt.figure()# 将整个图像窗口分为2行2列# 当前位置为1plt.subplot(2,2,1)plt.plot([0,1],[0,1])# 将整个图像窗口分为2行2列# 当前位置为2plt.subplot(2,2,2)plt.plot([0,1],[0,2])# 将整个图像窗口分为2行2列# 当前位置为3plt.subplot(223)plt.plot([0,1],[0,3])plt.show()</code></pre><p><img src="/img/code_one_hour/coh9_1.png" srcset="/img/loading.gif" alt="png"></p><h3 id="不均匀多图"><a href="#不均匀多图" class="headerlink" title="不均匀多图"></a>不均匀多图</h3><pre><code class="lang-python">plt.subplot(2,1,1)plt.plot([0,1],[0,1])plt.subplot(2,3,4)plt.plot([0,1],[0,2])plt.subplot(248)plt.plot([0,1],[0,6])</code></pre><pre><code>[&lt;matplotlib.lines.Line2D at 0x10ddbb38&gt;]</code></pre><p><img src="/img/code_one_hour/coh9_2.png" srcset="/img/loading.gif" alt="png"></p><h2 id="Subplot2grid实现多图"><a href="#Subplot2grid实现多图" class="headerlink" title="Subplot2grid实现多图"></a>Subplot2grid实现多图</h2><pre><code class="lang-python"># (3,3) : 将整个图像窗口分成3行3列# (0,0):表示从第0行第0列开始作图# colspan = 3 : 表示列的跨度为3# rowspan = 1 : 表示行的跨度为1# 一般跨度缺省默认为1ax1 = plt.subplot2grid((3,3),(0,0),colspan=3)ax1.plot([1,2],[1,2])# 设置小图的标题  区别于大图的标题plt.title()ax1.set_title(&#39;ax1_title&#39;)</code></pre><pre><code>Text(0.5, 1.0, &#39;ax1_title&#39;)</code></pre><p><img src="/img/code_one_hour/coh9_3.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python">plt.figure(figsize=(8,6))ax1 = plt.subplot2grid((3,3),(0,0),colspan=3)ax1.plot([1,2],[1,2])ax1.set_title(&#39;ax1_title&#39;)ax2 = plt.subplot2grid((3,3),(1,0),colspan=2)ax3 = plt.subplot2grid((3,3),(1,2),rowspan=2)ax4 = plt.subplot2grid((3,3),(2,0))ax5 = plt.subplot2grid((3,3),(2,1))ax4.scatter([1,1],[1,2])ax4.set_xlabel(&#39;ax4_x&#39;)ax4.set_ylabel(&#39;ax4_y&#39;)</code></pre><pre><code>Text(0, 0.5, &#39;ax4_y&#39;)</code></pre><p><img src="/img/code_one_hour/coh9_4.png" srcset="/img/loading.gif" alt="png"></p><h2 id="gridspec实现多图"><a href="#gridspec实现多图" class="headerlink" title="gridspec实现多图"></a>gridspec实现多图</h2><p>gridspec允许使用索引的方式指定小图的大小和位置</p><pre><code class="lang-python">import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec</code></pre><pre><code class="lang-python">plt.figure(figsize=(8,8))# 将整个图像窗口分成3行3列gs = gridspec.GridSpec(3,3)# 该图占第0行的所有列ax6 = plt.subplot(gs[0,:])# 该图占第1行的0到2列(不包括2)ax7 = plt.subplot(gs[1,:2])# 该图占第1行到最后一行的第2列ax8 = plt.subplot(gs[1:,2])# 该图占倒数第一行的第0列 ax9 = plt.subplot(gs[-1,0])# 该图占倒数第一行的倒数第二列ax10 = plt.subplot(gs[-1,-2])</code></pre><p><img src="/img/code_one_hour/coh9_5.png" srcset="/img/loading.gif" alt="png"></p><h2 id="Subplots伪图中图"><a href="#Subplots伪图中图" class="headerlink" title="Subplots伪图中图"></a>Subplots伪图中图</h2><p>subplots 不同于 subplot, 它允许我们将图像窗口集合在一起表示。</p><pre><code class="lang-python"># 创建一个2行2列的图像窗口# sharex.sharey = True表示共享图像窗口f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True)ax11.scatter([1,2], [1,2])# 紧凑显示图像plt.tight_layout()</code></pre><p><img src="/img/code_one_hour/coh9_6.png" srcset="/img/loading.gif" alt="png"></p><h2 id="图中图"><a href="#图中图" class="headerlink" title="图中图"></a>图中图</h2><h3 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h3><pre><code class="lang-python">x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]</code></pre><h3 id="绘制大图"><a href="#绘制大图" class="headerlink" title="绘制大图"></a>绘制大图</h3><pre><code class="lang-python">left, bottom, width, height = 0.1, 0.1, 0.8, 0.8fig = plt.figure()ax1 = fig.add_axes([left,bottom,width,height])ax1.plot(x,y,&#39;r&#39;)ax1.set_xlabel(&#39;x&#39;)ax1.set_ylabel(&#39;y&#39;)ax1.set_title(&#39;title&#39;)</code></pre><pre><code>Text(0.5, 1.0, &#39;title&#39;)</code></pre><p><img src="/img/code_one_hour/coh9_7.png" srcset="/img/loading.gif" alt="png"></p><h3 id="fig-add-axes-方式绘制小图"><a href="#fig-add-axes-方式绘制小图" class="headerlink" title="fig.add_axes()方式绘制小图"></a>fig.add_axes()方式绘制小图</h3><pre><code class="lang-python">fig = plt.figure()# 如果figure的大小为10x10# 则大图在 (1,1)开始绘制left, bottom, width, height = 0.1, 0.1, 0.8, 0.8ax1 = fig.add_axes([left, bottom, width, height])ax1.plot(x, y, &#39;r&#39;)ax1.set_xlabel(&#39;x&#39;)ax1.set_ylabel(&#39;y&#39;)ax1.set_title(&#39;title&#39;)left, bottom, width, height = 0.2, 0.6, 0.25, 0.25ax2 = fig.add_axes([left, bottom, width, height])ax2.plot(y, x, &#39;b&#39;)ax2.set_xlabel(&#39;x&#39;)ax2.set_ylabel(&#39;y&#39;)ax2.set_title(&#39;title inside 1&#39;)</code></pre><pre><code>Text(0.5, 1.0, &#39;title inside 1&#39;)</code></pre><p><img src="/img/code_one_hour/coh9_8.png" srcset="/img/loading.gif" alt="png"></p><h3 id="plt-axes-方式绘制小图"><a href="#plt-axes-方式绘制小图" class="headerlink" title="plt.axes()方式绘制小图"></a>plt.axes()方式绘制小图</h3><pre><code class="lang-python">fig = plt.figure()left, bottom, width, height = 0.1, 0.1, 0.8, 0.8ax1 = fig.add_axes([left, bottom, width, height])ax1.plot(x, y, &#39;r&#39;)ax1.set_xlabel(&#39;x&#39;)ax1.set_ylabel(&#39;y&#39;)ax1.set_title(&#39;title&#39;)left, bottom, width, height = 0.2, 0.6, 0.25, 0.25ax2 = fig.add_axes([left, bottom, width, height])ax2.plot(y, x, &#39;b&#39;)ax2.set_xlabel(&#39;x&#39;)ax2.set_ylabel(&#39;y&#39;)ax2.set_title(&#39;title inside 1&#39;)plt.axes([0.6, 0.2, 0.25, 0.25])plt.plot(y[::-1], x, &#39;g&#39;) # 注意对y进行了逆序处理plt.xlabel(&#39;x&#39;)plt.ylabel(&#39;y&#39;)plt.title(&#39;title inside 2&#39;)plt.show()</code></pre><p><img src="/img/code_one_hour/coh9_9.png" srcset="/img/loading.gif" alt="png"></p><h2 id="次坐标轴"><a href="#次坐标轴" class="headerlink" title="次坐标轴"></a>次坐标轴</h2><p>有时可能用到次坐标轴，即同一个图上有第二个y轴存在。</p><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><pre><code class="lang-python">import numpy as npx = np.arange(0,10,0.1)y1 = 0.05*x**2y2 = -1*y1*2</code></pre><h3 id="设置两个坐标系并且画图"><a href="#设置两个坐标系并且画图" class="headerlink" title="设置两个坐标系并且画图"></a>设置两个坐标系并且画图</h3><pre><code class="lang-python">fig, ax1 = plt.subplots()# 产生一个ax1的镜面坐标ax2 = ax1.twinx()ax1.plot(x,y1,&#39;g-&#39;)ax1.set_xlabel(&#39;X data&#39;)ax1.set_ylabel(&#39;Y1 data&#39;,color = &#39;g&#39;)ax2.plot(x,y2,&#39;b-&#39;)ax2.set_ylabel(&#39;Y2 data&#39;,color =&#39;b&#39;)</code></pre><pre><code>Text(0, 0.5, &#39;Y2 data&#39;)</code></pre><p><img src="/img/code_one_hour/coh9_10.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Matplotlib</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Matplotlib-Base-Three</title>
    <link href="/2020/07/24/Code_One_Hour8/"/>
    <url>/2020/07/24/Code_One_Hour8/</url>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib使用-基础篇Three"><a href="#Matplotlib使用-基础篇Three" class="headerlink" title="Matplotlib使用-基础篇Three"></a>Matplotlib使用-基础篇Three</h1><p>(来源于莫凡PYTHON)</p><h2 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h2><p>本篇知识点归纳如下：</p><ul><li>散点图：plt.scatter()</li><li>柱状图：plt.bar()</li><li>等高线图：plt.contourf()</li><li>在等高线图中增加label：plt.clabel()</li><li>矩阵画图：plt.imshow()</li><li>在随机矩阵图中增加colorbar：plt.colorbar()</li></ul><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>生成1024个标准正态分布的二维数据组作为一个数据集，并且图形化这个数据集，每个点的颜色值用T来表示：</p><pre><code class="lang-python">import matplotlib.pyplot as pltimport numpy as npn = 1024X = np.random.normal(0,1,n)Y = np.random.normal(0,1,n)# print(X)# 求Y/X对应的tan的角度# arctan2是值值域为-pi到piT = np.arctan2(Y,X)# print(T)</code></pre><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>数据集生成完成后，使用plt.scatter()画出这个点集：</p><pre><code class="lang-python"># s=75：size=75# c=T：颜色为T# alpha=.5：透明度为50%plt.scatter(X,Y,s=75,c=T,alpha=0.5)plt.xlim(-1.5,1.5)# 隐藏x，y坐标轴plt.xticks(())plt.ylim(-1.5,1.5)plt.yticks(())plt.show()</code></pre><p><img src="/img/code_one_hour/coh8_1.png" srcset="/img/loading.gif" alt="png"></p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>柱状图是在数据分析过程中最为常用的图标，折线图和饼图能够表达的信息柱状图都可以表达。因此在学术报告或工作场景下，尽量使用柱状图来代替折线图和饼图。</p><h3 id="数据生成-1"><a href="#数据生成-1" class="headerlink" title="数据生成"></a>数据生成</h3><p>向上向下分别生成2组数据，X为0到11的整数 ，Y是相应的均匀分布的随机数据。</p><pre><code class="lang-python">n = 12X = np.arange(n)Y1 = (1-X/float(n))*np.random.uniform(0.5,1.0,n)Y2 = Y1print(X)print(Y1)</code></pre><pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11][0.65655053 0.48966973 0.69249911 0.43484417 0.4676229  0.43183273 0.26924631 0.31837679 0.18209083 0.16290861 0.16617777 0.05360242]</code></pre><h3 id="画图-1"><a href="#画图-1" class="headerlink" title="画图"></a>画图</h3><p>使用plt.bar()画出柱状图：参数为X,Y：X代表横坐标，即柱形的位置，Y代表纵坐标，即柱形的高度</p><pre><code class="lang-python">plt.bar(X,Y1)plt.bar(X,-Y2)plt.xlim(-.5,n)plt.ylim(-1.25,1.25)plt.xticks(())plt.yticks(())plt.show()</code></pre><p><img src="/img/code_one_hour/coh8_2.png" srcset="/img/loading.gif" alt="png"></p><h3 id="修改颜色和数据标签"><a href="#修改颜色和数据标签" class="headerlink" title="修改颜色和数据标签"></a>修改颜色和数据标签</h3><p>使用plt.bar()中的参数：</p><ul><li>facecolor参数：设置柱状图的主体颜色</li><li>edgecolor参数：设置边框颜色</li><li>plt.text():添加数值，ha=’center’设置横向居中对齐，va=’bottom’设置纵向底部对齐</li></ul><pre><code class="lang-python">plt.bar(X,+Y1,facecolor=&#39;#FFCCCC&#39;,edgecolor=&#39;black&#39;)plt.bar(X,-Y1,facecolor=&#39;blue&#39;,edgecolor=&#39;black&#39;)for x, y in zip(X, Y1):    # ha: horizontal alignment    # va: vertical alignment    print(x,y)    plt.text(x, y , &#39;%.2f&#39; % y, ha=&#39;center&#39;, va=&#39;bottom&#39;)for x, y in zip(X, Y2):    # ha: horizontal alignment    # va: vertical alignment    plt.text(x, -y , &#39;%.2f&#39; % y, ha=&#39;center&#39;, va=&#39;top&#39;)</code></pre><pre><code>0 0.65655052620621391 0.489669733294001762 0.69249911002934013 0.434844168081710674 0.46762290032629465 0.43183273153883826 0.269246308666689367 0.31837678619801288 0.182090825738033679 0.1629086144118323510 0.1661777734773707311 0.0536024200226529</code></pre><p><img src="/img/code_one_hour/coh8_3.png" srcset="/img/loading.gif" alt="png"></p><h2 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h2><h3 id="数据生成-2"><a href="#数据生成-2" class="headerlink" title="数据生成"></a>数据生成</h3><p>数据集即三维点:(x,y)和对应的高度值z，高度值使用height function f(x,y)生成。x, y 分别是在区间 [-3,3] 中均匀分布的256个值，并用meshgrid在二维平面中将每一个x和每一个y分别对应起来，编织成栅格:</p><pre><code class="lang-python">def f(x,y):    # the height function    return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)# 拓展成坐标矩阵X,Y = np.meshgrid(x,y)</code></pre><h3 id="画图-2"><a href="#画图-2" class="headerlink" title="画图"></a>画图</h3><p>接下来进行颜色填充。使用函数plt.contourf把颜色加进去，</p><ul><li>位置参数分别为：X, Y, f(X,Y)。</li><li>8代表等高线的密集程度，这里被分为10个部分。如果是0，则图像被一分为二。</li><li>透明度为0.75，</li><li>并将 f(X,Y) 的值对应到color map的RdBu组中寻找对应颜色。大家可能并不能直观理解 colormap ，它可以将颜色和数字进行映射。如果暂时不能理解的话也没有关系，我们可以将其想象成matplotlib为我们提供的配色方案。</li></ul><pre><code class="lang-python">plt.contourf(X, Y, f(X, Y), 20, alpha=.75, cmap=plt.cm.RdBu)</code></pre><pre><code>&lt;matplotlib.contour.QuadContourSet at 0x12243b70&gt;</code></pre><p><img src="/img/code_one_hour/coh8_4.png" srcset="/img/loading.gif" alt="png"></p><p>接下来进行等高线绘制。使用plt.contour函数划线。</p><ul><li>位置参数为：X, Y, f(X,Y)。</li><li>颜色选黑色，</li><li>线条宽度选0.5。<br><br>现在的结果如下图所示，只有颜色和线条，还没有数值Label：</li></ul><pre><code class="lang-python">plt.contourf(X, Y, f(X, Y), 20, alpha=.75, cmap=plt.cm.RdBu)C = plt.contour(X, Y, f(X, Y), 20, colors=&#39;black&#39;, linewidth=.5)</code></pre><pre><code>d:\dl\minconda3\envs\ml_dl_andrewng\lib\site-packages\ipykernel_launcher.py:2: UserWarning: The following kwargs were not used by contour: &#39;linewidth&#39;</code></pre><p><img src="/img/code_one_hour/coh8_5.png" srcset="/img/loading.gif" alt="png"></p><h3 id="添加高度数值"><a href="#添加高度数值" class="headerlink" title="添加高度数值"></a>添加高度数值</h3><p>可以通过plt.clabel()在等高线上加入高度数值：</p><ul><li>inline参数：控制是否将label画在线里面</li><li>fontsize参数：设置字体大小</li></ul><pre><code class="lang-python">plt.contourf(X,Y,f(X,Y),8,alpha=0.75,cmap=plt.cm.RdBu)C = plt.contour(X,Y,f(X,Y),8,colors=&#39;blue&#39;)plt.clabel(C,inline=False,fontsize=10)plt.xticks(())plt.yticks(())</code></pre><pre><code>([], &lt;a list of 0 Text major ticklabel objects&gt;)</code></pre><p><img src="/img/code_one_hour/coh8_6.png" srcset="/img/loading.gif" alt="png"></p><h2 id="随机矩阵画图"><a href="#随机矩阵画图" class="headerlink" title="随机矩阵画图"></a>随机矩阵画图</h2><p>怎样在matplotlib中打印出图像。这里我们打印出的是纯粹的数字，而非自然图像。</p><h3 id="数据生成-3"><a href="#数据生成-3" class="headerlink" title="数据生成"></a>数据生成</h3><p>生成一个 3x3 的 2D-array ，也就是三行三列的格子，array 中的每个值经过colormap与一个颜色对应并填充在格子中</p><pre><code class="lang-python">a = np.array([0.313660827978, 0.365348418405, 0.423733120134,              0.365348418405, 0.439599930621, 0.525083754405,              0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3)</code></pre><h3 id="画图-3"><a href="#画图-3" class="headerlink" title="画图"></a>画图</h3><p>之前选cmap的参数时用的是：cmap=plt.cmap.RdBu，而现在，我们可以直接用单引号传入参数。 origin=’lower’代表的就是选择的原点的位置。而 interpolation 表示画图方式，也可以从matplotlib官网上看到对于内插法的不同方法的描述。这里我们使用的是内插法中的 Nearest-neighbor 的方法，其他的方式也都可以随意取选。</p><pre><code class="lang-python">plt.imshow(a, interpolation=&#39;nearest&#39;, cmap=&#39;RdBu&#39;, origin=&#39;lower&#39;)</code></pre><pre><code>&lt;matplotlib.image.AxesImage at 0x122de828&gt;</code></pre><p><img src="/img/code_one_hour/coh8_7.png" srcset="/img/loading.gif" alt="png"></p><h3 id="增加colorbar"><a href="#增加colorbar" class="headerlink" title="增加colorbar"></a>增加colorbar</h3><p>添加一个colorbar ，它可以为我们显示不同颜色的区块所对应的具体数值。其中shrink参数可以用来调整 colorbar 的长度，这里我们使colorbar的长度变短为原来的92%，这样我们2D图像就创建完毕了：</p><pre><code class="lang-python">plt.imshow(a, interpolation=&#39;nearest&#39;, cmap=&#39;RdBu&#39;, origin=&#39;lower&#39;)plt.colorbar(shrink=0.92)plt.xticks(())plt.yticks(())plt.show()</code></pre><p><img src="/img/code_one_hour/coh8_8.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Matplotlib</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Matplotlib-Base-Two</title>
    <link href="/2020/07/22/Code_One_Hour7/"/>
    <url>/2020/07/22/Code_One_Hour7/</url>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib使用-基础篇Two"><a href="#Matplotlib使用-基础篇Two" class="headerlink" title="Matplotlib使用-基础篇Two"></a>Matplotlib使用-基础篇Two</h1><p>(来源于莫凡PYTHON)</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>本章知识点归纳如下：</p><ul><li>添加图例：plt.legend()</li><li>画点：plt.scatter()</li><li>添加标注：plt.annotate()</li><li>添加注释：plt.text()</li></ul><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>图例可以更好的展示出每个数据对应的图像名称</p><ul><li>label=’’：设置曲线的名称</li><li>plt.legend()：设置图例的显示，即获取代码中的label的信息，plt自动添加图例,参数loc决定图例的位置，best表示自动分配最佳位置。</li><li>loc参数选择： ‘best’ : 0, ‘upper right’ : 1, ‘upper left’ : 2, ‘lower left’ : 3, ‘lower right’ : 4, ‘right’ : 5, ‘center left’ : 6, ‘center right’ : 7, ‘lower center’ : 8, ‘upper center’ : 9, ‘center’ : 10</li></ul><pre><code class="lang-python">import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3,3,50)y1 = 2*x + 1y2 = x**2plt.figure()plt.xlim((-1,2))plt.ylim((-2,3))new_sticks = np.linspace(-1,2,5)plt.xticks(new_sticks)plt.yticks([-2, -1.8, -1, 1.22, 3],           [r&#39;$really\ bad$&#39;, r&#39;$bad$&#39;, r&#39;$normal$&#39;, r&#39;$good$&#39;, r&#39;$really\ good$&#39;])l1 = plt.plot(x,y1,label=&#39;linear line&#39;)l2 = plt.plot(x,y2,color=&#39;red&#39;,linewidth=3,linestyle=&#39;--&#39;,label=&#39;square line&#39;)plt.legend()</code></pre><pre><code>&lt;matplotlib.legend.Legend at 0x10708128&gt;</code></pre><p><img src="/img/code_one_hour/coh7_1.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python">l1 = plt.plot(x, y1, label=&#39;linear line&#39;)l2 = plt.plot(x, y2, color=&#39;red&#39;, linewidth=1.0, linestyle=&#39;--&#39;, label=&#39;square line&#39;)plt.legend(loc=10)</code></pre><pre><code>&lt;matplotlib.legend.Legend at 0x5715940&gt;</code></pre><p><img src="/img/code_one_hour/coh7_2.png" srcset="/img/loading.gif" alt="png"></p><p>同样可以通过设置 handles 参数来选择图例中显示的内容。首先，在上面的代码 plt.plot(x, y2, label=’linear line’) 和 plt.plot(x, y1, label=’square line’) 中用变量 l1 和 l2 分别存储起来，而且需要注意的是 l1, l2,要以逗号结尾, 因为plt.plot() 返回的是一个列表。然后将 l1,l2 这样的objects以列表的形式传递给 handles。另外，label 参数可以用来单独修改之前的 label 信息, 给不同类型的线条设置图例信息。</p><pre><code class="lang-python">l1, = plt.plot(x,y1,label=&#39;linear line&#39;)l2, = plt.plot(x,y2,color=&#39;red&#39;,linewidth=1,linestyle=&#39;--&#39;,label=&#39;square line&#39;)print(type(l1,))plt.legend(handles=[l1,l2],labels=[&#39;up&#39;,&#39;down&#39;],loc=&#39;best&#39;)</code></pre><pre><code>&lt;class &#39;matplotlib.lines.Line2D&#39;&gt;&lt;matplotlib.legend.Legend at 0x11a98be0&gt;</code></pre><p><img src="/img/code_one_hour/coh7_3.png" srcset="/img/loading.gif" alt="png"></p><h2 id="Annotation标注"><a href="#Annotation标注" class="headerlink" title="Annotation标注"></a>Annotation标注</h2><p>当图形中某些地方需要标注时，即使用annotation。两种方法，一种是用 plt 里面的 annotate，一种是直接用 plt 里面的 text 来写标注。</p><pre><code class="lang-python">x = np.linspace(-3,3,50)y = 2*x +1plt.figure(num=1,figsize=(8,5))ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0))plt.plot(x,y)</code></pre><pre><code>[&lt;matplotlib.lines.Line2D at 0x1099a1d0&gt;]</code></pre><p><img src="/img/code_one_hour/coh7_4.png" srcset="/img/loading.gif" alt="png"></p><p>然后标注出点(x0, y0)的位置信息。用plt.plot([x0, x0,], [0, y0,], ‘k—‘, linewidth=2.5) 画出一条垂直于x轴的虚线。其中，[x0, x0,], [0, y0,] 表示在图中画一条从点 (x0,y0) 到 (x0,0) 的直线，’k—‘ 表示直线的颜色为黑色(black)，线形为虚线。而 plt.scatter 函数可以在图中画点，此时我们画的点为 (x0,y0), 点的大小(size)为 50， 点的颜色为蓝色(blue),可简写为 b。</p><pre><code class="lang-python">x = np.linspace(-3,3,50)y = 2*x +1plt.figure(num=1,figsize=(8,5))ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0))plt.plot(x,y)x0 = 1y0 = 2*x0 + 1plt.plot([x0,x0],[0,y0],&#39;k--&#39;,linewidth=2.5)plt.scatter(x0,y0,s=50,color=&#39;b&#39;)</code></pre><pre><code>&lt;matplotlib.collections.PathCollection at 0x11c75e48&gt;</code></pre><p><img src="/img/code_one_hour/coh7_5.png" srcset="/img/loading.gif" alt="png"></p><h3 id="添加注释annotate"><a href="#添加注释annotate" class="headerlink" title="添加注释annotate"></a>添加注释annotate</h3><pre><code class="lang-python">plt.figure(num=1, figsize=(8, 5),)ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))plt.plot(x, y,)x0 = 1y0 = 2*x0 + 1plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2.5)# set dot stylesplt.scatter([x0, ], [y0, ], s=50, color=&#39;b&#39;)# &#39;2x+1=%s&#39;%y0：代表标注的内容# xycoords = &#39;data&#39;：基于数据的值来选择位置# xytext=(+30, -30) 和 textcoords=&#39;offset points&#39; ：对于标注位置的描述 和 xy 偏差值，# 即标注位置是 xy 位置向右移动 30，向下移动30#  arrowprops：对图中箭头类型和箭头弧度的设置，需要用 dict 形式传入。plt.annotate(&#39;2x+1=%s&#39;%y0, xy = (x0,y0),xycoords = &#39;data&#39;,xytext = (+30,-30),            textcoords=&#39;offset points&#39;,fontsize=16,            arrowprops=dict(arrowstyle=&#39;-&gt;&#39;,connectionstyle=&quot;arc3,rad=.2&quot;))</code></pre><pre><code>Text(30, -30, &#39;2x+1=3&#39;)</code></pre><p><img src="/img/code_one_hour/coh7_6.png" srcset="/img/loading.gif" alt="png"></p><h3 id="添加注释text"><a href="#添加注释text" class="headerlink" title="添加注释text"></a>添加注释text</h3><pre><code class="lang-python">plt.figure(num=1, figsize=(8, 5),)ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))plt.plot(x, y,)x0 = 1y0 = 2*x0 + 1plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2.5)# set dot stylesplt.scatter([x0, ], [y0, ], s=50, color=&#39;b&#39;)plt.annotate(r&#39;$2x+1=%s$&#39; % y0, xy=(x0, y0), xycoords=&#39;data&#39;, xytext=(+30, -30),             textcoords=&#39;offset points&#39;, fontsize=16,             arrowprops=dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3,rad=.2&quot;))# -3.7, 3,:选择text的位置# r&#39;$This\ is\ the\ some\ text. \mu\ \sigma_i\ \alpha_t$&#39;：text的内容# 空格需要转义字符\才可打出# fondict :设置text的大小和颜色plt.text(-3.7, 3, r&#39;$This\ is\ the\ some\ text. \mu\ \sigma_i\ \alpha_t$&#39;,         fontdict={&#39;size&#39;: 16, &#39;color&#39;: &#39;r&#39;})</code></pre><pre><code>Text(-3.7, 3, &#39;$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$&#39;)</code></pre><p><img src="/img/code_one_hour/coh7_7.png" srcset="/img/loading.gif" alt="png"></p><h2 id="tick-能见度"><a href="#tick-能见度" class="headerlink" title="tick 能见度"></a>tick 能见度</h2><p>当图片内容较多，相互遮盖时，可以通过设置相关内容的透明度来使图片更易观察</p><ul><li>.set_bbox()：可以调节图像信息</li></ul><pre><code class="lang-python">x = np.linspace(-3, 3, 50)y = 0.1*xplt.figure()# 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序，设置绘制的顺序plt.plot(x, y, linewidth=10, zorder=1)plt.ylim(-2, 2)ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))</code></pre><p><img src="/img/code_one_hour/coh7_8.png" srcset="/img/loading.gif" alt="png"></p><p>对被遮挡的图像调节相关透明度，本例中设置 x轴 和 y轴 的刻度数字进行透明度设置。其中label.set_fontsize(12)重新调节字体大小，bbox设置目的内容的透明度相关参，facecolor调节 box 前景色，edgecolor 设置边框， 本处设置边框为无，alpha设置透明度. 最终结果如下:</p><pre><code class="lang-python">plt.plot(x, y, linewidth=10, zorder=1)plt.ylim(-2, 2)ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))for label in ax.get_xticklabels()+ax.get_yticklabels():    label.set_fontsize(12)    label.set_bbox(dict(facecolor=&#39;white&#39;,edgecolor=&#39;None&#39;,alpha=0.5,zorder=10))plt.show()</code></pre><p><img src="/img/code_one_hour/coh7_9.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Matplotlib</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习6:支持向量机</title>
    <link href="/2020/07/22/ML_Andrew_Pex6_Support_Vector_Machines/"/>
    <url>/2020/07/22/ML_Andrew_Pex6_Support_Vector_Machines/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习6-支持向量机"><a href="#吴恩达机器学习程序练习6-支持向量机" class="headerlink" title="吴恩达机器学习程序练习6:支持向量机"></a>吴恩达机器学习程序练习6:支持向量机</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex67101</p><h2 id="1-支持向量机"><a href="#1-支持向量机" class="headerlink" title="1. 支持向量机"></a>1. 支持向量机</h2><p>在本节中，将使用高斯核函数的支持向量机(SVM)来构建垃圾邮件分类器</p><h3 id="1-1-数据集1的实验"><a href="#1-1-数据集1的实验" class="headerlink" title="1.1 数据集1的实验"></a>1.1 数据集1的实验</h3><p>先在数据集1(2D数据集)上实验</p><pre><code class="lang-python">import numpy as np import pandas as pdimport matplotlib.pyplot as pltimport seaborn as sbfrom scipy.io import loadmat</code></pre><pre><code class="lang-python">raw_data = loadmat(&#39;./andrew_ml_ex67101/ex6data1.mat&#39;)print(type(raw_data))# print(raw_data.get(&#39;X&#39;))data = pd.DataFrame(raw_data.get(&#39;X&#39;),columns=[&#39;X1&#39;,&#39;X2&#39;])data[&#39;y&#39;]=raw_data.get(&#39;y&#39;)data.head()</code></pre><pre><code>&lt;class &#39;dict&#39;&gt;</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>X1</th>      <th>X2</th>      <th>y</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1.9643</td>      <td>4.5957</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>2.2753</td>      <td>3.8589</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>2.9781</td>      <td>4.5651</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>2.9320</td>      <td>3.5519</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>3.5772</td>      <td>2.8560</td>      <td>1</td>    </tr>  </tbody></table></div><h4 id="1-1-1-数据可视化"><a href="#1-1-1-数据可视化" class="headerlink" title="1.1.1 数据可视化"></a>1.1.1 数据可视化</h4><pre><code class="lang-python">def plot_init_data(data,fig,ax):    positive = data[data[&#39;y&#39;].isin([1])]    negative = data[data[&#39;y&#39;].isin([0])]    ax.scatter(positive[&#39;X1&#39;],positive[&#39;X2&#39;],s=50,marker=&#39;x&#39;,label=&#39;Positive&#39;)    ax.scatter(negative[&#39;X1&#39;],negative[&#39;X2&#39;],s=50,marker=&#39;o&#39;,label=&#39;Negative&#39;)</code></pre><pre><code class="lang-python">fig, ax = plt.subplots(figsize=(12,8))plot_init_data(data,fig ,ax)ax.legend()plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_1.png" srcset="/img/loading.gif" alt="png"></p><p><strong>注：</strong>还有一个异常的正例在其他样本之外。这些类依旧是线性分离的，但是非常紧凑，可以训练线性支持向量机来学习类的边界</p><pre><code class="lang-python">from sklearn import svm# 令C=1svc = svm.LinearSVC(C=1,loss=&#39;hinge&#39;,max_iter=1000)svc</code></pre><pre><code>LinearSVC(C=1, loss=&#39;hinge&#39;)</code></pre><pre><code class="lang-python">svc.fit(data[[&#39;X1&#39;,&#39;X2&#39;]],data[&#39;y&#39;])svc.score(data[[&#39;X1&#39;,&#39;X2&#39;]],data[&#39;y&#39;])</code></pre><pre><code>d:\dl\minconda3\envs\ml_dl_andrewng\lib\site-packages\sklearn\svm\_base.py:977: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations.  &quot;the number of iterations.&quot;, ConvergenceWarning)0.9803921568627451</code></pre><h4 id="1-1-2-可视化分类边界"><a href="#1-1-2-可视化分类边界" class="headerlink" title="1.1.2 可视化分类边界"></a>1.1.2 可视化分类边界</h4><pre><code class="lang-python">def find_decision_boundary(svc,x1min,x1max,x2min,x2max,diff):    x1 = np.linspace(x1min,x1max,1000)    x2 = np.linspace(x2min,x2max,1000)    cordinates = [(x,y) for x in x1 for y in x2]    x_cord,y_cord = zip(*cordinates)    c_val = pd.DataFrame({&#39;x1&#39;:x_cord,&#39;x2&#39;:y_cord})    c_val[&#39;cval&#39;]=svc.decision_function(c_val[[&#39;x1&#39;,&#39;x2&#39;]])    decision = c_val[np.abs(c_val[&#39;cval&#39;])&lt;diff]    return decision.x1,decision.x2</code></pre><pre><code class="lang-python">x1,x2 = find_decision_boundary(svc,0,4,1.5,5,2*10**-3)fig,ax = plt.subplots(figsize=(12,8))ax.scatter(x1,x2,s=11,c=&#39;r&#39;,label=&#39;Boundary&#39;)plot_init_data(data,fig,ax)ax.set_title(&quot;SVM(C=1) Decision Boundary&quot;)ax.legend()plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_2.png" srcset="/img/loading.gif" alt="png"></p><p>令C的值越大，看看会发生什么？</p><pre><code class="lang-python">svc2 = svm.LinearSVC(C=100,loss=&#39;hinge&#39;,max_iter=1000)svc2.fit(data[[&#39;X1&#39;,&#39;X2&#39;]],data[&#39;y&#39;])svc2.score(data[[&#39;X1&#39;,&#39;X2&#39;]],data[&#39;y&#39;])</code></pre><pre><code>d:\dl\minconda3\envs\ml_dl_andrewng\lib\site-packages\sklearn\svm\_base.py:977: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations.  &quot;the number of iterations.&quot;, ConvergenceWarning)0.9411764705882353</code></pre><p>这次我们得到了训练数据的完美分类，但是通过增加C的值，我们创建了一个不再适合数据的决策边界。 我们可以通过查看每个类别预测的置信水平来看出这一点，这是该点与超平面距离的函数。</p><pre><code class="lang-python">x1, x2 = find_decision_boundary(svc, 0, 4, 1.5, 5, 2 * 10**-3)fig, ax = plt.subplots(figsize=(12,8))ax.scatter(x1, x2, s=1, c=&#39;r&#39;,label=&#39;Boundary&#39;)plot_init_data(data, fig, ax)ax.set_title(&#39;SVM (C=100) Decision Boundary&#39;)ax.legend()plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_3.png" srcset="/img/loading.gif" alt="png"></p><h3 id="1-2-高斯内核的SVM"><a href="#1-2-高斯内核的SVM" class="headerlink" title="1.2 高斯内核的SVM"></a>1.2 高斯内核的SVM</h3><p>现在将从线性SVM转移到能够使用内核进行非线性分类的SVM。虽然scikit-learn具有内置的高斯内核，但是为了更清楚其实现，我们从头开始实现。</p><h4 id="1-2-1-高斯内核"><a href="#1-2-1-高斯内核" class="headerlink" title="1.2.1 高斯内核"></a>1.2.1 高斯内核</h4><p>可以把高斯内核当成是衡量一对数据间的“距离”的函数，有一个参数$\sigma$,决定相似性下降至0有多快。</p><script type="math/tex; mode=display">K_{gaussian}(x^{(i),x^{(j)}})=exp(-\frac{\|x^{(i)}-x^{(j)}\|^2}{2\sigma^2})=exp\lgroup-\frac{\sum_{k=1}^n(x_k^{(i)}-x_k^{(j)})^2}{2\sigma^2}\rgroup</script><pre><code class="lang-python">def gaussian_kernel(x1,x2,sigma):    return np.exp(-(np.sum((x1-x2)**2)/(2*(sigma**2))))</code></pre><pre><code class="lang-python">x1 = np.array([1.0,2.0,1.0])x2 = np.array([0.0,4.0,-1.0])sigma = 2gaussian_kernel(x1,x2,sigma)</code></pre><pre><code>0.32465246735834974</code></pre><h4 id="1-2-2-数据集2的实验"><a href="#1-2-2-数据集2的实验" class="headerlink" title="1.2.2 数据集2的实验"></a>1.2.2 数据集2的实验</h4><p>接下来，在数据集2上使用高斯内核。找出非线性边界</p><pre><code class="lang-python">raw_data = loadmat(&#39;./andrew_ml_ex67101/ex6data2.mat&#39;)data= pd.DataFrame(raw_data[&#39;X&#39;],columns=[&#39;X1&#39;,&#39;X2&#39;])data[&#39;y&#39;] = raw_data[&#39;y&#39;]fig,ax = plt.subplots(figsize=(12,8))plot_init_data(data,fig,ax)ax.legend()plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_4.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python">svc = svm.SVC(C=100,gamma=10,probability=True)svc</code></pre><pre><code>SVC(C=100, gamma=10, probability=True)</code></pre><pre><code class="lang-python">svc.fit(data[[&#39;X1&#39;,&#39;X2&#39;]],data[&#39;y&#39;])svc.score(data[[&#39;X1&#39;,&#39;X2&#39;]],data[&#39;y&#39;])</code></pre><pre><code>0.9698725376593279</code></pre><pre><code class="lang-python">x1,x2 = find_decision_boundary(svc,0,1,0.4,1,0.01)fig,ax = plt.subplots(figsize=(12,8))plot_init_data(data,fig,ax)ax.scatter(x1,x2,s=10)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_5.png" srcset="/img/loading.gif" alt="png"></p><h4 id="1-2-3-数据集3的实验"><a href="#1-2-3-数据集3的实验" class="headerlink" title="1.2.3 数据集3的实验"></a>1.2.3 数据集3的实验</h4><p>对于第三个数据集，给出训练集和验证集，并且基于验证集性能为SVM模型找到最优超参数：寻找最优C和$\sigma$，候选数值为[0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30, 100]</p><pre><code class="lang-python">raw_data = loadmat(&#39;./andrew_ml_ex67101/ex6data3.mat&#39;)X = raw_data[&#39;X&#39;]Xval = raw_data[&#39;Xval&#39;]y = raw_data[&#39;y&#39;].ravel()yval = raw_data[&#39;yval&#39;].ravel()# print(raw_data)fig,ax = plt.subplots(figsize=(12,8))data = pd.DataFrame(raw_data.get(&#39;X&#39;),columns=[&#39;X1&#39;,&#39;X2&#39;])data[&#39;y&#39;] = raw_data.get(&#39;y&#39;)plot_init_data(data,fig,ax)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_6.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python">C_values = [0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30, 100]gamma_values = [0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30, 100]best_score = 0best_params = {&#39;C&#39;:None,&#39;gamma&#39;:None}for C in C_values:    for gamma in gamma_values:        svc = svm.SVC(C=C,gamma=gamma)        svc.fit(X,y)        score = svc.score(Xval,yval)        if score &gt; best_score:            best_score = score            best_params[&#39;C&#39;]=C            best_params[&#39;gamma&#39;]=gammabest_score,best_params</code></pre><pre><code>(0.965, {&#39;C&#39;: 0.3, &#39;gamma&#39;: 100})</code></pre><pre><code class="lang-python">svc = svm.SVC(C=best_params[&#39;C&#39;],gamma=best_params[&#39;gamma&#39;])svc.fit(X,y)x1,x2 = find_decision_boundary(svc,-0.6,0.3,-0.7,0.6,0.005)fig,ax = plt.subplots(figsize=(12,8))plot_init_data(data,fig,ax)ax.scatter(x1,x2,s=10)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex6_7.png" srcset="/img/loading.gif" alt="png"></p><h2 id="2-垃圾邮件分类"><a href="#2-垃圾邮件分类" class="headerlink" title="2. 垃圾邮件分类"></a>2. 垃圾邮件分类</h2><h3 id="2-1-处理邮件"><a href="#2-1-处理邮件" class="headerlink" title="2.1 处理邮件"></a>2.1 处理邮件</h3><p>更多详细信息可参考同文件夹下的andrew_ml_ex67101</p><h3 id="2-2-提取特征"><a href="#2-2-提取特征" class="headerlink" title="2.2 提取特征"></a>2.2 提取特征</h3><p>此部分是处理邮件，以获得适合SVM处理的格式的数据。这个任务很简单（将字词映射到为练习提供的字典中的ID），而其余的预处理步骤（如HTML删除，词干，标准化等）已经完成。 我们就直接读取预先处理好的数据就可以了。</p><h3 id="2-3-训练垃圾邮件分类SVM"><a href="#2-3-训练垃圾邮件分类SVM" class="headerlink" title="2.3 训练垃圾邮件分类SVM"></a>2.3 训练垃圾邮件分类SVM</h3><pre><code class="lang-python">spam_train = loadmat(&#39;./andrew_ml_ex67101/spamTrain.mat&#39;)spam_test = loadmat(&#39;./andrew_ml_ex67101/spamTest.mat&#39;)# spam_train,spam_test</code></pre><pre><code class="lang-python">X = spam_train[&#39;X&#39;]Xtest = spam_test[&#39;Xtest&#39;]y = spam_train[&#39;y&#39;].ravel()ytest = spam_test[&#39;ytest&#39;].ravel()X.shape,y.shape,Xtest.shape,ytest.shape</code></pre><pre><code>((4000, 1899), (4000,), (1000, 1899), (1000,))</code></pre><p>每个文档都已经转换为一个向量，其中1899个维对应于词汇表中的1899个单词。它们的值为二进制，表示文档中是否存在单词。</p><pre><code class="lang-python">svc = svm.SVC()svc.fit(X,y)</code></pre><pre><code>SVC()</code></pre><pre><code class="lang-python">print(&#39;Training accuracy = {0}%&#39;.format(np.round(svc.score(X, y) * 100, 2)))print(&#39;Test accuracy = {0}%&#39;.format(np.round(svc.score(Xtest, ytest) * 100, 2)))</code></pre><pre><code>Training accuracy = 99.32%Test accuracy = 98.7%</code></pre><h3 id="2-4-可视化结果"><a href="#2-4-可视化结果" class="headerlink" title="2.4 可视化结果"></a>2.4 可视化结果</h3><pre><code class="lang-python">kw = np.eye(1899)kw[:3,:]spam_val = pd.DataFrame({&#39;idx&#39;:range(1899)})</code></pre><pre><code class="lang-python">spam_val[&#39;isspam&#39;] = svc.decision_function(kw)</code></pre><pre><code class="lang-python">spam_val[&#39;isspam&#39;].describe()</code></pre><pre><code>count    1899.000000mean       -0.110039std         0.049094min        -0.42839625%        -0.13121350%        -0.11198575%        -0.091973max         0.396286Name: isspam, dtype: float64</code></pre><pre><code class="lang-python">decision = spam_val[spam_val[&#39;isspam&#39;]&gt; -0.55]decision</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>idx</th>      <th>isspam</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>-0.093653</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>-0.083078</td>    </tr>    <tr>      <th>2</th>      <td>2</td>      <td>-0.109401</td>    </tr>    <tr>      <th>3</th>      <td>3</td>      <td>-0.119685</td>    </tr>    <tr>      <th>4</th>      <td>4</td>      <td>-0.165824</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>1894</th>      <td>1894</td>      <td>0.101613</td>    </tr>    <tr>      <th>1895</th>      <td>1895</td>      <td>-0.016065</td>    </tr>    <tr>      <th>1896</th>      <td>1896</td>      <td>-0.151573</td>    </tr>    <tr>      <th>1897</th>      <td>1897</td>      <td>-0.109022</td>    </tr>    <tr>      <th>1898</th>      <td>1898</td>      <td>-0.091970</td>    </tr>  </tbody></table><p>1899 rows × 2 columns</p></div><pre><code class="lang-python">path =  &#39;./andrew_ml_ex67101/vocab.txt&#39;voc = pd.read_csv(path, header=None, names=[&#39;idx&#39;, &#39;voc&#39;], sep = &#39;\t&#39;)voc.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>idx</th>      <th>voc</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>aa</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>ab</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>abil</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>abl</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>about</td>    </tr>  </tbody></table></div><pre><code class="lang-python">spamvoc = voc.loc[list(decision[&#39;idx&#39;])]spamvoc</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>idx</th>      <th>voc</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>aa</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>ab</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>abil</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>abl</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>about</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>1894</th>      <td>1895</td>      <td>your</td>    </tr>    <tr>      <th>1895</th>      <td>1896</td>      <td>yourself</td>    </tr>    <tr>      <th>1896</th>      <td>1897</td>      <td>zdnet</td>    </tr>    <tr>      <th>1897</th>      <td>1898</td>      <td>zero</td>    </tr>    <tr>      <th>1898</th>      <td>1899</td>      <td>zip</td>    </tr>  </tbody></table><p>1899 rows × 2 columns</p></div><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Matplotlib-Base-One</title>
    <link href="/2020/07/20/Code_One_Hour6/"/>
    <url>/2020/07/20/Code_One_Hour6/</url>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib使用-基础篇One"><a href="#Matplotlib使用-基础篇One" class="headerlink" title="Matplotlib使用-基础篇One"></a>Matplotlib使用-基础篇One</h1><p>(来源于莫凡PYTHON)</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>本篇知识点归纳如下：</p><ul><li>导入模块：import matplotlib.pyplot as plt</li><li>定义图像窗口：plt.figure()</li><li>画图：plt.plot(x,y)</li><li>定义坐标轴范围：plt.xlim()/plt.ylim()</li><li>定义坐标轴名称：plt.xlabel()/plt.ylabel()</li><li>定义坐标轴刻度：plt.xticks()/plt.yticks()</li><li>设置图像边框颜色：ax = plt.gca() ax.spines[].set_color()</li><li>调整刻度位置：ax.xaxis.set_ticks_position()/ax.yaxis.set_ticks_position()</li><li>调整边框位置：ax.spines[].set_position()</li></ul><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><pre><code class="lang-python">import matplotlib.pyplot as pltimport numpy as np</code></pre><pre><code class="lang-python">x = np.linspace(-3,3,50)y1 = 2*x + 1y2 = x**2</code></pre><h2 id="定义图像窗口并画图"><a href="#定义图像窗口并画图" class="headerlink" title="定义图像窗口并画图"></a>定义图像窗口并画图</h2><p>代码思路：</p><ul><li>使用plt.figure()定义一个图像窗口：num为3，figsize为(8,5),参数可以缺省，num参数决定程序运行后弹出的图像窗口名字</li><li>使用plt.plot()画出y1,y2曲线，并且设置(color)为红色，宽度(linewidth)为1.0，曲线类型(linestyle)为虚线(eg:-、—、-.、:)</li><li>使用plt.show()显示图像</li></ul><pre><code class="lang-python">plt.figure(num=3,figsize=(8,5))plt.plot(x,y1,linestyle=&#39;-.&#39;)plt.plot(x,y2,color=&#39;red&#39;,linewidth=1.0,linestyle=&#39;--&#39;)plt.show()</code></pre><p><img src="/img/code_one_hour/coh6_1.png" srcset="/img/loading.gif" alt="png"></p><h2 id="定义坐标轴名称及范围"><a href="#定义坐标轴名称及范围" class="headerlink" title="定义坐标轴名称及范围"></a>定义坐标轴名称及范围</h2><ul><li>使用plt.xlim()设置x坐标轴的范围：(-1,2)</li><li>使用plt.xlabel()设置x坐标轴的名称：’i am x’</li></ul><pre><code class="lang-python">plt.figure(num=3,figsize=(8,5))plt.plot(x,y2)plt.plot(x,y1,color=&#39;red&#39;,linewidth=1.0,linestyle=&#39;--&#39;)plt.xlim((-1,2))plt.ylim((-2,3))plt.xlabel(&#39;i am x&#39;)plt.ylabel(&#39;i am y&#39;)plt.show()</code></pre><p><img src="/img/code_one_hour/coh6_2.png" srcset="/img/loading.gif" alt="png"></p><h2 id="定义坐标轴刻度及名称"><a href="#定义坐标轴刻度及名称" class="headerlink" title="定义坐标轴刻度及名称"></a>定义坐标轴刻度及名称</h2><p>有时候，坐标轴刻度可能不是一连串的数字，而是一些文字，或者需要调整坐标轴刻度的稀疏：</p><ul><li>使用plt.xticks()/plt.yticks()</li></ul><pre><code class="lang-python">plt.figure(num=3,figsize = (8,5))plt.plot(x,y2)plt.plot(x,y1,color=&#39;red&#39;,linewidth=1.0,linestyle=&#39;--&#39;)plt.xlim((-1,2))plt.ylim((-2,3))plt.xlabel(&#39;I am x&#39;)plt.ylabel(&#39;I am y&#39;)new_ticks = np.linspace(-1,2,5)print(new_ticks)plt.xticks(new_ticks)plt.yticks([-2,-1.8,-1,1.22,3],[&#39;really bad&#39;,&#39;bad&#39;,&#39;normal&#39;,&#39;good&#39;,&#39;really good&#39;])plt.show()</code></pre><pre><code>[-1.   -0.25  0.5   1.25  2.  ]</code></pre><p><img src="/img/code_one_hour/coh6_3.png" srcset="/img/loading.gif" alt="png"></p><h2 id="设置图像边框颜色"><a href="#设置图像边框颜色" class="headerlink" title="设置图像边框颜色"></a>设置图像边框颜色</h2><p>图像坐标轴总是由上下左右四条线组成，我们也可以对它们进行修改：</p><ul><li>使用plt.gca()获取当前坐标轴的信息（Get current axis）</li><li>使用.spines设置边框</li><li>使用.set_color设置边框颜色</li></ul><pre><code class="lang-python">plt.figure(num=3,figsize=(8,5))plt.plot(x,y2)plt.plot(x,y1,color=&#39;red&#39;,linewidth=1.0,linestyle=&#39;--&#39;)plt.xlim((-1,2))plt.ylim((-2,3))plt.xticks(new_ticks)plt.yticks([-2,-1.8,-1,1.22,3],[&#39;really bad&#39;,&#39;bad&#39;,&#39;normal&#39;,&#39;good&#39;,&#39;really good&#39;])ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;green&#39;)</code></pre><p><img src="/img/code_one_hour/coh6_4.png" srcset="/img/loading.gif" alt="png"></p><h2 id="调整刻度及边框位置"><a href="#调整刻度及边框位置" class="headerlink" title="调整刻度及边框位置"></a>调整刻度及边框位置</h2><ul><li>使用.xaxis.set_ticks_position设置x坐标刻度或者名称的位置：所有位置：top，bottom，both，default，none）</li><li>使用.spines设置边框</li><li>使用.set_position设置边框位置:（位置所有属性：outward，axes，data）</li></ul><pre><code class="lang-python">plt.figure(num = 3,figsize=(8,5))plt.plot(x,y2)plt.plot(x,y1,color=&#39;red&#39;,linewidth=2.0,linestyle=&#39;--&#39;)plt.xlim((-1,2))plt.ylim((-2,3))plt.xticks(new_ticks)plt.yticks([-2, -1.8, -1, 1.22, 3],[r&#39;$really\ bad$&#39;, r&#39;$bad$&#39;, r&#39;$normal$&#39;, r&#39;$good$&#39;, r&#39;$really\ good$&#39;])ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))plt.show()</code></pre><p><img src="/img/code_one_hour/coh6_5.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python">plt.figure(num=3,figsize=(8,5))plt.plot(x,y2)plt.plot(x,y1,color=&#39;red&#39;,linewidth=3.0,linestyle=&#39;--&#39;)plt.xlim((-1,2))plt.ylim((-2,3))plt.xticks(new_ticks)plt.yticks([-2, -1.8, -1, 1.22, 3],[r&#39;$really\ bad$&#39;, r&#39;$bad$&#39;, r&#39;$normal$&#39;, r&#39;$good$&#39;, r&#39;$really\ good$&#39;])ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)# 指定下边的边作为 x 轴 指定左边的边为 y 轴#指定 data 设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0))plt.show()</code></pre><p><img src="/img/code_one_hour/coh6_6.png" srcset="/img/loading.gif" alt="png"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>*题目：画出直线 y = x-1, 线型为虚线，线宽为1，纵坐标范围（-2，1），横坐标范围（-1，2），横纵坐标在（0，0）坐标点相交。横坐标的 [-1,-0.5,1] 分别对应 [bad, normal, good]。</p><pre><code class="lang-python">plt.figure(num=3,figsize=(8,5))x = np.linspace(-1,2,50)y = x - 1plt.plot(x,y,color=&#39;red&#39;,linewidth=1.0,linestyle=&#39;--&#39;)plt.xlim((-1,2))plt.ylim((-2,1))new_ticks=np.linspace(-1,2,3)plt.xticks(new_ticks)plt.yticks([-1,-0.5,1], [&#39;bad&#39;, &#39;normal&#39;, &#39;good&#39;])ax = plt.gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.xaxis.set_ticks_position(&#39;bottom&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))ax.yaxis.set_ticks_position(&#39;left&#39;)ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0))plt.show()</code></pre><p><img src="/img/code_one_hour/coh6_7.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Matplotlib</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Pandas-Base-Three</title>
    <link href="/2020/07/18/Code_One_Hour5/"/>
    <url>/2020/07/18/Code_One_Hour5/</url>
    
    <content type="html"><![CDATA[<h1 id="Pandas使用-基础篇Three"><a href="#Pandas使用-基础篇Three" class="headerlink" title="Pandas使用-基础篇Three"></a>Pandas使用-基础篇Three</h1><h2 id="1-数值计算和统计基础"><a href="#1-数值计算和统计基础" class="headerlink" title="1. 数值计算和统计基础"></a>1. 数值计算和统计基础</h2><ul><li>常用数学、统计方法</li></ul><pre><code class="lang-python">import numpy as npimport pandas as pddf = pd.DataFrame({&#39;key1&#39;:[4,5,3,np.nan,2],                 &#39;key2&#39;:[1,2,np.nan,4,5],                 &#39;key3&#39;:[1,2,3,&#39;j&#39;,&#39;k&#39;]},                 index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])print(df)print(df[&#39;key1&#39;].dtype,df[&#39;key2&#39;].dtype,df[&#39;key3&#39;].dtype)print(&#39;------------------------------------------------------&#39;)print(&quot;.mean()计算均值：只统计数字列(包括Nan),默认以列计算(axis=0)&quot;)m1 = df.mean()print(m1,type(m1))print(&#39;单独统计一列:&#39;,df[&#39;key1&#39;].mean())print(&quot;指定轴(行列方向)：axis=0以列来计算，axis=1以行来计算&quot;)m2 = df.mean(axis=1)print(m2)print(&quot;skipna参数：是否忽略NaN，默认True，如False，有NaN的列统计结果仍未NaN&quot;)m3 = df.mean(skipna=False)print(m3)</code></pre><pre><code>   key1  key2 key3a   4.0   1.0    1b   5.0   2.0    2c   3.0   NaN    3d   NaN   4.0    je   2.0   5.0    kfloat64 float64 object------------------------------------------------------.mean()计算均值：只统计数字列(包括Nan),默认以列计算(axis=0)key1    3.5key2    3.0dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;单独统计一列: 3.5指定轴(行列方向)：axis=0以列来计算，axis=1以行来计算a    2.5b    3.5c    3.0d    4.0e    3.5dtype: float64skipna参数：是否忽略NaN，默认True，如False，有NaN的列统计结果仍未NaNkey1   NaNkey2   NaNdtype: float64</code></pre><pre><code class="lang-python">df = pd.DataFrame({&#39;key1&#39;:np.arange(10),                  &#39;key2&#39;:np.random.rand(10)*10})print(df)print(&#39;-----&#39;)print(df.count(),&#39;→ count统计非Na值的数量\n&#39;)print(df.min(),&#39;→ min统计最小值\n&#39;,df[&#39;key2&#39;].max(),&#39;→ max统计最大值\n&#39;)print(df.quantile(q=0.75),&#39;→ quantile统计分位数，参数q确定位置\n&#39;)print(df.sum(),&#39;→ sum求和\n&#39;)print(df.mean(),&#39;→ mean求平均值\n&#39;)print(df.median(),&#39;→ median求算数中位数，50%分位数\n&#39;)print(df.std(),&#39;\n&#39;,df.var(),&#39;→ std,var分别求标准差，方差\n&#39;)print(df.skew(),&#39;→ skew样本的偏度\n&#39;)print(df.kurt(),&#39;→ kurt样本的峰度\n&#39;)</code></pre><pre><code>   key1      key20     0  0.7519551     1  8.8061832     2  0.7369473     3  1.6388334     4  5.7339715     5  6.6809226     6  6.1894237     7  2.8504798     8  9.7935699     9  1.472623-----key1    10key2    10dtype: int64 → count统计非Na值的数量key1    0.000000key2    0.736947dtype: float64 → min统计最小值 9.793568975290103 → max统计最大值key1    6.750000key2    6.558047Name: 0.75, dtype: float64 → quantile统计分位数，参数q确定位置key1    45.000000key2    44.654903dtype: float64 → sum求和key1    4.50000key2    4.46549dtype: float64 → mean求平均值key1    4.500000key2    4.292225dtype: float64 → median求算数中位数，50%分位数key1    3.027650key2    3.398808dtype: float64  key1     9.166667key2    11.551893dtype: float64 → std,var分别求标准差，方差key1    0.000000key2    0.334036dtype: float64 → skew样本的偏度key1   -1.200000key2   -1.508633dtype: float64 → kurt样本的峰度</code></pre><pre><code class="lang-python">print(&quot;统计学方法：&quot;)df[&#39;key1_s&#39;] = df[&#39;key1&#39;].cumsum()df[&#39;key2_s&#39;] = df[&#39;key2&#39;].cumsum()print(df,&#39;→ cumsum样本的累计和\n&#39;)df[&#39;key1_p&#39;] = df[&#39;key1&#39;].cumprod()df[&#39;key2_p&#39;] = df[&#39;key2&#39;].cumprod()print(df,&#39;→ cumprod样本的累计积\n&#39;)print(df.cummax(),&#39;\n&#39;,df.cummin(),&#39;→ cummax,cummin分别求累计最大值，累计最小值\n&#39;)# 会填充key1，和key2的值</code></pre><pre><code>统计学方法：   key1      key2  key1_s     key2_s0     0  0.751955       0   0.7519551     1  8.806183       1   9.5581372     2  0.736947       3  10.2950843     3  1.638833       6  11.9339174     4  5.733971      10  17.6678885     5  6.680922      15  24.3488106     6  6.189423      21  30.5382327     7  2.850479      28  33.3887118     8  9.793569      36  43.1822809     9  1.472623      45  44.654903 → cumsum样本的累计和   key1      key2  key1_s     key2_s  key1_p        key2_p0     0  0.751955       0   0.751955       0      0.7519551     1  8.806183       1   9.558137       0      6.6218512     2  0.736947       3  10.295084       0      4.8799533     3  1.638833       6  11.933917       0      7.9974294     4  5.733971      10  17.667888       0     45.8570205     5  6.680922      15  24.348810       0    306.3671746     6  6.189423      21  30.538232       0   1896.2358887     7  2.850479      28  33.388711       0   5405.1802048     8  9.793569      36  43.182280       0  52936.0051489     9  1.472623      45  44.654903       0  77954.788734 → cumprod样本的累计积   key1      key2  key1_s     key2_s  key1_p        key2_p0     0  0.751955       0   0.751955       0      0.7519551     1  8.806183       1   9.558137       0      6.6218512     2  8.806183       3  10.295084       0      6.6218513     3  8.806183       6  11.933917       0      7.9974294     4  8.806183      10  17.667888       0     45.8570205     5  8.806183      15  24.348810       0    306.3671746     6  8.806183      21  30.538232       0   1896.2358887     7  8.806183      28  33.388711       0   5405.1802048     8  9.793569      36  43.182280       0  52936.0051489     9  9.793569      45  44.654903       0  77954.788734     key1      key2  key1_s    key2_s  key1_p    key2_p0     0  0.751955       0  0.751955       0  0.7519551     0  0.751955       0  0.751955       0  0.7519552     0  0.736947       0  0.751955       0  0.7519553     0  0.736947       0  0.751955       0  0.7519554     0  0.736947       0  0.751955       0  0.7519555     0  0.736947       0  0.751955       0  0.7519556     0  0.736947       0  0.751955       0  0.7519557     0  0.736947       0  0.751955       0  0.7519558     0  0.736947       0  0.751955       0  0.7519559     0  0.736947       0  0.751955       0  0.751955 → cummax,cummin分别求累计最大值，累计最小值</code></pre><pre><code class="lang-python">print(&quot;唯一值：.unique()&quot;)s = pd.Series(list(&#39;asdvasdcfgg&#39;))sq = s.unique()print(s)print(sq,type(sq))print(pd.Series(sq))# 得到一个唯一值数组# 通过pd.Series重新变成新的Seriessq.sort()print(sq)# 重新排序</code></pre><pre><code>唯一值：.unique()0     a1     s2     d3     v4     a5     s6     d7     c8     f9     g10    gdtype: object[&#39;a&#39; &#39;s&#39; &#39;d&#39; &#39;v&#39; &#39;c&#39; &#39;f&#39; &#39;g&#39;] &lt;class &#39;numpy.ndarray&#39;&gt;0    a1    s2    d3    v4    c5    f6    gdtype: object[&#39;a&#39; &#39;c&#39; &#39;d&#39; &#39;f&#39; &#39;g&#39; &#39;s&#39; &#39;v&#39;]</code></pre><pre><code class="lang-python">print(&quot;值计数：.value_counts()&quot;)sc = s.value_counts(sort = False)  # 也可以这样写：pd.value_counts(sc, sort = False)print(sc)# 得到一个新的Series，计算出不同值出现的频率# sort参数：排序，默认为True</code></pre><pre><code>值计数：.value_counts()d    2a    2g    2f    1s    2c    1v    1dtype: int64</code></pre><pre><code class="lang-python">print(&quot;成员资格：.isin()&quot;)s = pd.Series(np.arange(10,15))df = pd.DataFrame({&#39;key1&#39;:list(&#39;asdcbvasd&#39;),                  &#39;key2&#39;:np.arange(4,13)})print(s)print(df)print(&#39;-----&#39;)print(s.isin([5,14]))print(df.isin([&#39;a&#39;,&#39;bc&#39;,&#39;10&#39;,8]))# 用[]表示# 得到一个布尔值的Series或者Dataframe</code></pre><pre><code>成员资格：.isin()0    101    112    123    134    14dtype: int32  key1  key20    a     41    s     52    d     63    c     74    b     85    v     96    a    107    s    118    d    12-----0    False1    False2    False3    False4     Truedtype: bool    key1   key20   True  False1  False  False2  False  False3  False  False4  False   True5  False  False6   True  False7  False  False8  False  False</code></pre><h2 id="2-文本数据"><a href="#2-文本数据" class="headerlink" title="2. 文本数据"></a>2. 文本数据</h2><ul><li>Pandas针对字符串匹配的一套方法，使其易于对数组的每个元素进行操作</li></ul><pre><code class="lang-python">print(&quot;通过str访问，且自动排除丢失/ NA值&quot;)s = pd.Series([&#39;A&#39;,&#39;b&#39;,&#39;C&#39;,&#39;bbhello&#39;,&#39;123&#39;,np.nan,&#39;hj&#39;])df = pd.DataFrame({&#39;key1&#39;:list(&#39;abcdef&#39;),                  &#39;key2&#39;:[&#39;hee&#39;,&#39;fv&#39;,&#39;w&#39;,&#39;hija&#39;,&#39;123&#39;,np.nan]})print(s)print(df)print(&#39;-------------------------------------------&#39;)print(&quot;直接通过.str调用字符串方法&quot;)print(s.str.count(&#39;b&#39;))print(df[&#39;key2&#39;].str.upper())print(&#39;-------------------------------------------&#39;)print(&quot;df.columns是一个Index对象，也可使用.str&quot;)df.columns = df.columns.str.upper()print(df)</code></pre><pre><code>通过str访问，且自动排除丢失/ NA值0          A1          b2          C3    bbhello4        1235        NaN6         hjdtype: object  key1  key20    a   hee1    b    fv2    c     w3    d  hija4    e   1235    f   NaN-------------------------------------------直接通过.str调用字符串方法0    0.01    1.02    0.03    2.04    0.05    NaN6    0.0dtype: float640     HEE1      FV2       W3    HIJA4     1235     NaNName: key2, dtype: object-------------------------------------------df.columns是一个Index对象，也可使用.str  KEY1  KEY20    a   hee1    b    fv2    c     w3    d  hija4    e   1235    f   NaN</code></pre><pre><code class="lang-python">print(&quot;字符串常用方法1：lower，upper，len，startswith，endswith&quot;)s = pd.Series([&#39;A&#39;,&#39;b&#39;,&#39;bbhello&#39;,&#39;123&#39;,np.nan])print(s.str.lower(),&#39;→ lower小写\n&#39;)print(s.str.upper(),&#39;→ upper大写\n&#39;)print(s.str.len(),&#39;→ len字符长度\n&#39;)print(s.str.startswith(&#39;b&#39;),&#39;→ 判断起始是否为a\n&#39;)print(s.str.endswith(&#39;3&#39;),&#39;→ 判断结束是否为3\n&#39;)</code></pre><pre><code>字符串常用方法1：lower，upper，len，startswith，endswith0          a1          b2    bbhello3        1234        NaNdtype: object → lower小写0          A1          B2    BBHELLO3        1234        NaNdtype: object → upper大写0    1.01    1.02    7.03    3.04    NaNdtype: float64 → len字符长度0    False1     True2     True3    False4      NaNdtype: object → 判断起始是否为a0    False1    False2    False3     True4      NaNdtype: object → 判断结束是否为3</code></pre><pre><code class="lang-python">print(&quot;符串常用方法2: strip()去除空格&quot;)s = pd.Series([&#39; jack&#39;, &#39;jill &#39;, &#39; jesse &#39;, &#39;frank&#39;])df = pd.DataFrame(np.random.randn(3, 2), columns=[&#39; Column A &#39;, &#39; Column B &#39;],                  index=range(3))print(s)print(df)print(&#39;-----------------------------------&#39;)print(s.str.strip())  # 去除字符串中的空格print(s.str.lstrip())  # 去除字符串中的左空格print(s.str.rstrip())  # 去除字符串中的右空格# 这里去掉了columns的前后空格，但没有去掉中间空格df.columns = df.columns.str.strip()print(df)</code></pre><pre><code>符串常用方法2: strip()去除空格0       jack1      jill 2     jesse 3      frankdtype: object    Column A    Column B 0   -0.845667   -0.8269471    0.362077   -1.4357382   -0.260095   -0.465580-----------------------------------0     jack1     jill2    jesse3    frankdtype: object0      jack1     jill 2    jesse 3     frankdtype: object0      jack1      jill2     jesse3     frankdtype: object   Column A  Column B0 -0.845667 -0.8269471  0.362077 -1.4357382 -0.260095 -0.465580</code></pre><pre><code class="lang-python">print(&quot;字符串常用方法3: replace()替换字符&quot;)df = pd.DataFrame(np.random.randn(3, 2), columns=[&#39; Column A &#39;, &#39; Column B &#39;],                  index=range(3))df.columns = df.columns.str.replace(&#39; &#39;,&#39;-&#39;)print(df)# n：替换个数df.columns = df.columns.str.replace(&#39;-&#39;,&#39;hehe&#39;,n=3)print(df)</code></pre><pre><code>字符串常用方法3: replace()替换字符   -Column-A-  -Column-B-0   -1.349258    1.9287321   -0.623833    1.8618072   -0.379427    0.178919   heheColumnheheAhehe  heheColumnheheBhehe0            -1.349258             1.9287321            -0.623833             1.8618072            -0.379427             0.178919</code></pre><pre><code class="lang-python">print(&quot;字符串常用方法4：split()、rsplit()分割字符串&quot;)s = pd.Series([&#39;a,b,c&#39;,&#39;1,2,3&#39;,[&#39;a,,,c&#39;],np.nan])print(s)print(&#39;---------------------------------------&#39;)print(s.str.split(&#39;,&#39;))print(s.str.split(&#39;,&#39;)[0])print(&#39;---------------------------------------&#39;)print(&quot;可以使用get或[]符号访问拆分列表中的元素&quot;)print(s.str.split(&#39;,&#39;).str[0])print(s.str.split(&#39;,&#39;).str.get(1))print(&#39;---------------------------------------&#39;)print(&quot;可以使用expand可以轻松扩展此操作以返回DataFrame, n参数限制分割数&quot;)print(s.str.split(&#39;,&#39;, expand=True))print(s.str.split(&#39;,&#39;, expand=True, n = 1))print(s.str.rsplit(&#39;,&#39;, expand=True, n = 1))print(&#39;---------------------------------------&#39;)print(&quot;rsplit类似于split，反向工作，即从字符串的末尾到字符串的开头&quot;)print(&#39;---------------------------------------&#39;)print(&quot;Dataframe使用split&quot;)df = pd.DataFrame({&#39;key1&#39;:[&#39;a,b,c&#39;,&#39;1,2,3&#39;,[&#39;:,., &#39;]],                  &#39;key2&#39;:[&#39;a-b-c&#39;,&#39;1-2-3&#39;,[&#39;:-.- &#39;]]})print(df)print(&quot;-----------&quot;)print(df[&#39;key2&#39;].str.split(&#39;-&#39;))</code></pre><pre><code>字符串常用方法4：split()、rsplit()分割字符串0      a,b,c1      1,2,32    [a,,,c]3        NaNdtype: object---------------------------------------0    [a, b, c]1    [1, 2, 3]2          NaN3          NaNdtype: object[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]---------------------------------------可以使用get或[]符号访问拆分列表中的元素0      a1      12    NaN3    NaNdtype: object0      b1      22    NaN3    NaNdtype: object---------------------------------------可以使用expand可以轻松扩展此操作以返回DataFrame, n参数限制分割数     0    1    20    a    b    c1    1    2    32  NaN  NaN  NaN3  NaN  NaN  NaN     0    10    a  b,c1    1  2,32  NaN  NaN3  NaN  NaN     0    10  a,b    c1  1,2    32  NaN  NaN3  NaN  NaN---------------------------------------rsplit类似于split，反向工作，即从字符串的末尾到字符串的开头---------------------------------------Dataframe使用split      key1     key20    a,b,c    a-b-c1    1,2,3    1-2-32  [:,., ]  [:-.- ]-----------0    [a, b, c]1    [1, 2, 3]2          NaNName: key2, dtype: object</code></pre><pre><code class="lang-python">print(&quot;字符串常用方法5：字符串索引&quot;)s = pd.Series([&#39;A&#39;,&#39;b&#39;,&#39;C&#39;,&#39;bbhello&#39;,&#39;123&#39;,np.nan,&#39;hj&#39;])df = pd.DataFrame({&#39;key1&#39;:list(&#39;abcdef&#39;),                  &#39;key2&#39;:[&#39;hee&#39;,&#39;fv&#39;,&#39;w&#39;,&#39;hija&#39;,&#39;123&#39;,np.nan]})print(s)print(df)print(&quot;------------------------------&quot;)print(s.str[0])  # 取第一个字符串print(s.str[:2])  # 取前两个字符串print(df[&#39;key2&#39;].str[0]) # str之后和字符串本身索引方式相同</code></pre><pre><code>字符串常用方法5：字符串索引0          A1          b2          C3    bbhello4        1235        NaN6         hjdtype: object  key1  key20    a   hee1    b    fv2    c     w3    d  hija4    e   1235    f   NaN------------------------------0      A1      b2      C3      b4      15    NaN6      hdtype: object0      A1      b2      C3     bb4     125    NaN6     hjdtype: object0      h1      f2      w3      h4      15    NaNName: key2, dtype: object</code></pre><h2 id="3-合并-merge、join"><a href="#3-合并-merge、join" class="headerlink" title="3. 合并(merge、join)"></a>3. 合并(merge、join)</h2><ul><li>Pandas具有全功能、高性能内存中连接操作，与SQL等关系数据库非常类似</li></ul><pre><code class="lang-python">print(&quot;merge合并 → 类似excel的vlookup&quot;)# left：第一个df# right：第二个df# on：参考键df1 = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;],                     &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],                     &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]})df2 = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;],                      &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],                      &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]})df3 = pd.DataFrame({&#39;key1&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],                    &#39;key2&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;],                    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],                    &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]})df4 = pd.DataFrame({&#39;key1&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K1&#39;, &#39;K2&#39;],                    &#39;key2&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;],                    &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],                    &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]})print(pd.merge(df1, df2, on=&#39;key&#39;))print(&quot;----------------------------------&quot;)# 多个链接键print(pd.merge(df3, df4, on=[&#39;key1&#39;,&#39;key2&#39;]))print(&quot;----------------------------------&quot;)print(&quot;参数how → 合并方式&quot;)# inner：默认，取交集# outer：取并集，数据缺失范围NaN# left：按照df3为参考合并，数据缺失范围NaN# right：按照df4为参考合并，数据缺失范围NaNprint(pd.merge(df3, df4,on=[&#39;key1&#39;,&#39;key2&#39;], how = &#39;inner&#39;))  print(pd.merge(df3, df4, on=[&#39;key1&#39;,&#39;key2&#39;], how = &#39;outer&#39;))  print(pd.merge(df3, df4, on=[&#39;key1&#39;,&#39;key2&#39;], how = &#39;left&#39;))  print(pd.merge(df3, df4, on=[&#39;key1&#39;,&#39;key2&#39;], how = &#39;right&#39;))  print(&quot;----------------------------------&quot;)print(&quot;参数 left_on, right_on, left_index, right_index → 当键不为一个列时，可以单独设置左键与右键&quot;)df1 = pd.DataFrame({&#39;lkey&#39;:list(&#39;bbacaab&#39;),                   &#39;data1&#39;:range(7)})df2 = pd.DataFrame({&#39;rkey&#39;:list(&#39;abd&#39;),                   &#39;date2&#39;:range(3)})print(pd.merge(df1, df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;))print(&#39;------&#39;)# df1以‘lkey’为键，df2以‘rkey’为键df1 = pd.DataFrame({&#39;key&#39;:list(&#39;abcdfeg&#39;),                   &#39;data1&#39;:range(7)})df2 = pd.DataFrame({&#39;date2&#39;:range(100,105)},                  index = list(&#39;abcde&#39;))print(pd.merge(df1, df2, left_on=&#39;key&#39;, right_index=True))# df1以‘key’为键，df2以index为键# left_index：为True时，第一个df以index为键，默认False# right_index：为True时，第二个df以index为键，默认False# 所以left_on, right_on, left_index, right_index可以相互组合：# left_on + right_on, left_on + right_index, left_index + right_on, left_index + right_index</code></pre><pre><code>merge合并 → 类似excel的vlookup  key   A   B   C   D0  K0  A0  B0  C0  D01  K1  A1  B1  C1  D12  K2  A2  B2  C2  D23  K3  A3  B3  C3  D3----------------------------------  key1 key2   A   B   C   D0   K0   K0  A0  B0  C0  D01   K1   K0  A2  B2  C1  D12   K1   K0  A2  B2  C2  D2----------------------------------参数how → 合并方式  key1 key2   A   B   C   D0   K0   K0  A0  B0  C0  D01   K1   K0  A2  B2  C1  D12   K1   K0  A2  B2  C2  D2  key1 key2    A    B    C    D0   K0   K0   A0   B0   C0   D01   K0   K1   A1   B1  NaN  NaN2   K1   K0   A2   B2   C1   D13   K1   K0   A2   B2   C2   D24   K2   K1   A3   B3  NaN  NaN5   K2   K0  NaN  NaN   C3   D3  key1 key2   A   B    C    D0   K0   K0  A0  B0   C0   D01   K0   K1  A1  B1  NaN  NaN2   K1   K0  A2  B2   C1   D13   K1   K0  A2  B2   C2   D24   K2   K1  A3  B3  NaN  NaN  key1 key2    A    B   C   D0   K0   K0   A0   B0  C0  D01   K1   K0   A2   B2  C1  D12   K1   K0   A2   B2  C2  D23   K2   K0  NaN  NaN  C3  D3----------------------------------参数 left_on, right_on, left_index, right_index → 当键不为一个列时，可以单独设置左键与右键  lkey  data1 rkey  date20    b      0    b      11    b      1    b      12    b      6    b      13    a      2    a      04    a      4    a      05    a      5    a      0------  key  data1  date20   a      0    1001   b      1    1012   c      2    1023   d      3    1035   e      5    104</code></pre><pre><code class="lang-python">print(&quot;merge()参数：sort()&quot;)df1 = pd.DataFrame({&#39;key&#39;:list(&#39;bbacaab&#39;),                   &#39;data1&#39;:[1,3,2,4,5,9,7]})df2 = pd.DataFrame({&#39;key&#39;:list(&#39;abd&#39;),                   &#39;date2&#39;:[11,2,33]})x1 = pd.merge(df1,df2, on = &#39;key&#39;, how = &#39;outer&#39;)x2 = pd.merge(df1,df2, on = &#39;key&#39;, sort=True, how = &#39;outer&#39;)print(x1)print(x2)print(&#39;------&#39;)# sort：按照字典顺序通过 连接键 对结果DataFrame进行排序。默认为False，设置为False会大幅提高性能print(x2.sort_values(&#39;data1&#39;))# 也可直接用Dataframe的排序方法：sort_values，sort_index</code></pre><pre><code>merge()参数：sort()  key  data1  date20   b    1.0    2.01   b    3.0    2.02   b    7.0    2.03   a    2.0   11.04   a    5.0   11.05   a    9.0   11.06   c    4.0    NaN7   d    NaN   33.0  key  data1  date20   a    2.0   11.01   a    5.0   11.02   a    9.0   11.03   b    1.0    2.04   b    3.0    2.05   b    7.0    2.06   c    4.0    NaN7   d    NaN   33.0------  key  data1  date23   b    1.0    2.00   a    2.0   11.04   b    3.0    2.06   c    4.0    NaN1   a    5.0   11.05   b    7.0    2.02   a    9.0   11.07   d    NaN   33.0</code></pre><pre><code class="lang-python">print(&quot;pd.join()：通过索引连接&quot;)left = pd.DataFrame({&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;],                     &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;]},                    index=[&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;])right = pd.DataFrame({&#39;C&#39;: [&#39;C0&#39;, &#39;C2&#39;, &#39;C3&#39;],                      &#39;D&#39;: [&#39;D0&#39;, &#39;D2&#39;, &#39;D3&#39;]},                     index=[&#39;K0&#39;, &#39;K2&#39;, &#39;K3&#39;])print(left)print(right)print(left.join(right))print(left.join(right, how=&#39;outer&#39;))  print(&#39;-----&#39;)# 等价于：pd.merge(left, right, left_index=True, right_index=True, how=&#39;outer&#39;)df1 = pd.DataFrame({&#39;key&#39;:list(&#39;bbacaab&#39;),                   &#39;data1&#39;:[1,3,2,4,5,9,7]})df2 = pd.DataFrame({&#39;key&#39;:list(&#39;abd&#39;),                   &#39;date2&#39;:[11,2,33]})print(df1)print(df2)print(pd.merge(df1, df2, left_index=True, right_index=True, suffixes=(&#39;_1&#39;, &#39;_2&#39;)))  print(df1.join(df2[&#39;date2&#39;]))print(&#39;-----&#39;)# suffixes=(&#39;_x&#39;, &#39;_y&#39;)默认left = pd.DataFrame({&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],                     &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;],                     &#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;]})right = pd.DataFrame({&#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;],                      &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;]},                     index=[&#39;K0&#39;, &#39;K1&#39;])print(left)print(right)print(left.join(right, on = &#39;key&#39;))# 等价于pd.merge(left, right, left_on=&#39;key&#39;, right_index=True, how=&#39;left&#39;, sort=False);# left的‘key’和right的index</code></pre><pre><code>pd.join()：通过索引连接     A   BK0  A0  B0K1  A1  B1K2  A2  B2     C   DK0  C0  D0K2  C2  D2K3  C3  D3     A   B    C    DK0  A0  B0   C0   D0K1  A1  B1  NaN  NaNK2  A2  B2   C2   D2      A    B    C    DK0   A0   B0   C0   D0K1   A1   B1  NaN  NaNK2   A2   B2   C2   D2K3  NaN  NaN   C3   D3-----  key  data10   b      11   b      32   a      23   c      44   a      55   a      96   b      7  key  date20   a     111   b      22   d     33  key_1  data1 key_2  date20     b      1     a     111     b      3     b      22     a      2     d     33  key  data1  date20   b      1   11.01   b      3    2.02   a      2   33.03   c      4    NaN4   a      5    NaN5   a      9    NaN6   b      7    NaN-----    A   B key0  A0  B0  K01  A1  B1  K12  A2  B2  K03  A3  B3  K1     C   DK0  C0  D0K1  C1  D1    A   B key   C   D0  A0  B0  K0  C0  D01  A1  B1  K1  C1  D12  A2  B2  K0  C0  D03  A3  B3  K1  C1  D1</code></pre><h2 id="4-连接与修补-concat、combine-first"><a href="#4-连接与修补-concat、combine-first" class="headerlink" title="4. 连接与修补(concat、combine_first)"></a>4. 连接与修补(concat、combine_first)</h2><ul><li>连接 - 沿轴执行连接操作</li></ul><pre><code class="lang-python">print(&quot;连接：pd.concat()&quot;)s1 = pd.Series([1,2,3])s2 = pd.Series([2,3,4])s3 = pd.Series([1,2,3],index = [&#39;a&#39;,&#39;c&#39;,&#39;h&#39;])s4 = pd.Series([2,3,4],index = [&#39;b&#39;,&#39;e&#39;,&#39;d&#39;])print(pd.concat([s1,s2]))print(pd.concat([s3,s4]).sort_index())print(&#39;-----&#39;)# 默认axis=0，行+行print(pd.concat([s3,s4], axis=1))print(&#39;-----&#39;)# axis=1,列+列，成为一个Dataframe</code></pre><pre><code>连接：pd.concat()0    11    22    30    21    32    4dtype: int64a    1b    2c    2d    4e    3h    3dtype: int64-----     0    1a  1.0  NaNc  2.0  NaNh  3.0  NaNb  NaN  2.0e  NaN  3.0d  NaN  4.0-----</code></pre><pre><code class="lang-python">print(&quot;pd.concat()参数：连接方式：join，join_axes&quot;)s5 = pd.Series([1,2,3],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])s6 = pd.Series([2,3,4],index = [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(pd.concat([s5,s6], axis= 1))print(pd.concat([s5,s6], axis= 1, join=&#39;inner&#39;))# join：{&#39;inner&#39;，&#39;outer&#39;}，默认为“outer”。如何处理其他轴上的索引。outer为联合和inner为交集。</code></pre><pre><code>pd.concat()参数：连接方式：join，join_axes     0    1a  1.0  NaNb  2.0  2.0c  3.0  3.0d  NaN  4.0   0  1b  2  2c  3  3</code></pre><pre><code class="lang-python">print(&quot;pd.concat()参数：覆盖列名：axis=1&quot;)sre = pd.concat([s5,s6], keys = [&#39;one&#39;,&#39;two&#39;])print(sre,type(sre))print(sre.index)print(&#39;-----&#39;)# keys：序列，默认值无。使用传递的键作为最外层构建层次索引sre = pd.concat([s5,s6], axis=1, keys = [&#39;one&#39;,&#39;two&#39;])print(sre,type(sre))# axis = 1, 覆盖列名</code></pre><pre><code>pd.concat()参数：覆盖列名：axis=1one  a    1     b    2     c    3two  b    2     c    3     d    4dtype: int64 &lt;class &#39;pandas.core.series.Series&#39;&gt;MultiIndex([(&#39;one&#39;, &#39;a&#39;),            (&#39;one&#39;, &#39;b&#39;),            (&#39;one&#39;, &#39;c&#39;),            (&#39;two&#39;, &#39;b&#39;),            (&#39;two&#39;, &#39;c&#39;),            (&#39;two&#39;, &#39;d&#39;)],           )-----   one  twoa  1.0  NaNb  2.0  2.0c  3.0  3.0d  NaN  4.0 &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><pre><code class="lang-python">print(&quot;pd.combine_first():修补&quot;)df1 = pd.DataFrame([[np.nan, 3., 5.], [-4.6, np.nan, np.nan],[np.nan, 7., np.nan]])df2 = pd.DataFrame([[-42.6, np.nan, -8.2], [-5., 1.6, 4]],index=[1, 2])print(df1)print(df2)print(df1.combine_first(df2))print(&#39;-----&#39;)# 根据index，df1的空值被df2替代# 如果df2的index多于df1，则更新到df1上，比如index=[&#39;a&#39;,1]df1.update(df2)print(df1)# update，直接df2覆盖df1，相同index位置</code></pre><pre><code>pd.combine_first():修补     0    1    20  NaN  3.0  5.01 -4.6  NaN  NaN2  NaN  7.0  NaN      0    1    21 -42.6  NaN -8.22  -5.0  1.6  4.0     0    1    20  NaN  3.0  5.01 -4.6  NaN -8.22 -5.0  7.0  4.0-----      0    1    20   NaN  3.0  5.01 -42.6  NaN -8.22  -5.0  1.6  4.0</code></pre><h2 id="去重以及替换-duplicated-replace"><a href="#去重以及替换-duplicated-replace" class="headerlink" title="去重以及替换(duplicated/replace)"></a>去重以及替换(duplicated/replace)</h2><pre><code class="lang-python">print(&quot;去重：.duplicated&quot;)# 判断是否重复# 通过布尔判断，得到不重复的值s = pd.Series([1,1,1,1,2,2,2,3,4,5,5,5,5])print(s.duplicated())print(s[s.duplicated() == False])print(&#39;-----&#39;)# drop.duplicates移除重复# inplace参数：是否替换原值，默认Falses_re = s.drop_duplicates()print(s_re)print(&#39;-----&#39;)# Dataframe中使用duplicateddf = pd.DataFrame({&#39;key1&#39;:[&#39;a&#39;,&#39;a&#39;,3,4,5],                  &#39;key2&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;]})print(df.duplicated())print(df[&#39;key2&#39;].duplicated())</code></pre><pre><code>去重：.duplicated0     False1      True2      True3      True4     False5      True6      True7     False8     False9     False10     True11     True12     Truedtype: bool0    14    27    38    49    5dtype: int64-----0    14    27    38    49    5dtype: int64-----0    False1     True2    False3    False4    Falsedtype: bool0    False1     True2    False3     True4    FalseName: key2, dtype: bool</code></pre><pre><code class="lang-python">print(&quot;# 替换 .replace&quot;)# 可一次性替换一个值或多个值# 可传入列表或字典s = pd.Series(list(&#39;ascaazsd&#39;))print(s.replace(&#39;a&#39;, np.nan))print(s.replace([&#39;a&#39;,&#39;s&#39;] ,np.nan))print(s.replace({&#39;a&#39;:&#39;hello world!&#39;,&#39;s&#39;:123}))</code></pre><h2 id="6-数据分组-groupby"><a href="#6-数据分组-groupby" class="headerlink" title="6.数据分组(groupby())"></a>6.数据分组(groupby())</h2><p>分组统计 - groupby功能</p><p>① 根据某些条件将数据拆分成组 ② 对每个组独立应用函数 ③ 将结果合并到一个数据结构中</p><p>Dataframe在行（axis=0）或列（axis=1）上进行分组，将一个函数应用到各个分组并产生一个新值，然后函数执行结果被合并到最终的结果对象中。</p><pre><code class="lang-python">print(&quot;分组&quot;)df = pd.DataFrame({&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;foo&#39;],                   &#39;B&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],                   &#39;C&#39; : np.random.randn(8),                   &#39;D&#39; : np.random.randn(8)})print(df)print(&#39;------&#39;)print(df.groupby(&#39;A&#39;), type(df.groupby(&#39;A&#39;)))print(&#39;------&#39;)# 直接分组得到一个groupby对象，是一个中间数据，没有进行计算a = df.groupby(&#39;A&#39;).mean()b = df.groupby([&#39;A&#39;,&#39;B&#39;]).mean()c = df.groupby([&#39;A&#39;])[&#39;D&#39;].mean()  # 以A分组，算D的平均值print(a,type(a),&#39;\n&#39;,a.columns)print(b,type(b),&#39;\n&#39;,b.columns)print(c,type(c))# 通过分组后的计算，得到一个新的dataframe# 默认axis = 0，以行来分组# 可单个或多个（[]）列分组</code></pre><pre><code>分组     A      B         C         D0  foo    one -0.099397 -1.7718951  bar    one -1.512472  1.1026472  foo    two -0.744870  0.2112683  bar  three -0.350660 -2.4127594  foo    two  1.215143  0.2102925  bar    two  0.217097  0.3523416  foo    one  0.187242  0.6434597  foo  three  0.367878 -0.136878------&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000000004FA33C8&gt; &lt;class &#39;pandas.core.groupby.generic.DataFrameGroupBy&#39;&gt;------            C         DA                      bar -0.548679 -0.319257foo  0.185199 -0.168751 &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;  Index([&#39;C&#39;, &#39;D&#39;], dtype=&#39;object&#39;)                  C         DA   B                        bar one   -1.512472  1.102647    three -0.350660 -2.412759    two    0.217097  0.352341foo one    0.043923 -0.564218    three  0.367878 -0.136878    two    0.235136  0.210780 &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;  Index([&#39;C&#39;, &#39;D&#39;], dtype=&#39;object&#39;)Abar   -0.319257foo   -0.168751Name: D, dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre><pre><code class="lang-python">print(&quot;分组 - 可迭代对象&quot;)df = pd.DataFrame({&#39;X&#39; : [&#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;B&#39;], &#39;Y&#39; : [1, 4, 3, 2]})print(df)print(df.groupby(&#39;X&#39;), type(df.groupby(&#39;X&#39;)))print(&#39;-----&#39;)print(list(df.groupby(&#39;X&#39;)), &#39;→ 可迭代对象，直接生成list\n&#39;)print(list(df.groupby(&#39;X&#39;))[0], &#39;→ 以元祖形式显示\n&#39;)for n,g in df.groupby(&#39;X&#39;):    print(n)    print(g)    print(&#39;###&#39;)print(&#39;-----&#39;)# n是组名，g是分组后的Dataframeprint(df.groupby([&#39;X&#39;]).get_group(&#39;A&#39;),&#39;\n&#39;)print(df.groupby([&#39;X&#39;]).get_group(&#39;B&#39;),&#39;\n&#39;)print(&#39;-----&#39;)# .get_group()提取分组后的组grouped = df.groupby([&#39;X&#39;])print(grouped.groups)print(grouped.groups[&#39;A&#39;])  # 也可写：df.groupby(&#39;X&#39;).groups[&#39;A&#39;]print(&#39;-----&#39;)# .groups：将分组后的groups转为dict# 可以字典索引方法来查看groups里的元素sz = grouped.size()print(sz,type(sz))print(&#39;-----&#39;)# .size()：查看分组后的长度df = pd.DataFrame({&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;foo&#39;],                   &#39;B&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],                   &#39;C&#39; : np.random.randn(8),                   &#39;D&#39; : np.random.randn(8)})grouped = df.groupby([&#39;A&#39;,&#39;B&#39;]).groupsprint(df)print(grouped)print(grouped[(&#39;foo&#39;, &#39;three&#39;)])# 按照两个列进行分组</code></pre><pre><code>分组 - 可迭代对象   X  Y0  A  11  B  42  A  33  B  2&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000000004FA3198&gt; &lt;class &#39;pandas.core.groupby.generic.DataFrameGroupBy&#39;&gt;-----[(&#39;A&#39;,    X  Y0  A  12  A  3), (&#39;B&#39;,    X  Y1  B  43  B  2)] → 可迭代对象，直接生成list(&#39;A&#39;,    X  Y0  A  12  A  3) → 以元祖形式显示A   X  Y0  A  12  A  3###B   X  Y1  B  43  B  2###-----   X  Y0  A  12  A  3    X  Y1  B  43  B  2 -----{&#39;A&#39;: Int64Index([0, 2], dtype=&#39;int64&#39;), &#39;B&#39;: Int64Index([1, 3], dtype=&#39;int64&#39;)}Int64Index([0, 2], dtype=&#39;int64&#39;)-----XA    2B    2dtype: int64 &lt;class &#39;pandas.core.series.Series&#39;&gt;-----     A      B         C         D0  foo    one  0.180591 -1.8828441  bar    one  1.155047  0.2498112  foo    two  0.080034 -0.0397133  bar  three  0.221933  1.2213824  foo    two -1.127785 -0.0755535  bar    two  0.219877  0.3892106  foo    one -0.550236 -1.1142797  foo  three  0.910438  0.923003{(&#39;bar&#39;, &#39;one&#39;): Int64Index([1], dtype=&#39;int64&#39;), (&#39;bar&#39;, &#39;three&#39;): Int64Index([3], dtype=&#39;int64&#39;), (&#39;bar&#39;, &#39;two&#39;): Int64Index([5], dtype=&#39;int64&#39;), (&#39;foo&#39;, &#39;one&#39;): Int64Index([0, 6], dtype=&#39;int64&#39;), (&#39;foo&#39;, &#39;three&#39;): Int64Index([7], dtype=&#39;int64&#39;), (&#39;foo&#39;, &#39;two&#39;): Int64Index([2, 4], dtype=&#39;int64&#39;)}Int64Index([7], dtype=&#39;int64&#39;)</code></pre><pre><code class="lang-python">print(&quot;其他轴上的分组&quot;)df = pd.DataFrame({&#39;data1&#39;:np.random.rand(2),                  &#39;data2&#39;:np.random.rand(2),                  &#39;key1&#39;:[&#39;a&#39;,&#39;b&#39;],                  &#39;key2&#39;:[&#39;one&#39;,&#39;two&#39;]})print(df)print(df.dtypes)print(&#39;-----&#39;)for n,p in df.groupby(df.dtypes, axis=1):    print(n)    print(p)    print(&#39;##&#39;)# 按照值类型分列</code></pre><pre><code>其他轴上的分组      data1     data2 key1 key20  0.068436  0.198071    a  one1  0.191372  0.821277    b  twodata1    float64data2    float64key1      objectkey2      objectdtype: object-----float64      data1     data20  0.068436  0.1980711  0.191372  0.821277##object  key1 key20    a  one1    b  two##</code></pre><pre><code class="lang-python">print(&quot;通过字典或者Series分组&quot;)df = pd.DataFrame(np.arange(16).reshape(4,4),                  columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&#39;-----&#39;)mapping = {&#39;a&#39;:&#39;one&#39;,&#39;b&#39;:&#39;one&#39;,&#39;c&#39;:&#39;two&#39;,&#39;d&#39;:&#39;two&#39;,&#39;e&#39;:&#39;three&#39;}by_column = df.groupby(mapping, axis = 1)print(by_column.sum())print(&#39;-----&#39;)# mapping中，a、b列对应的为one，c、d列对应的为two，以字典来分组s = pd.Series(mapping)print(s,&#39;\n&#39;)print(s.groupby(s).count())# s中，index中a、b对应的为one，c、d对应的为two，以Series来分组</code></pre><pre><code>通过字典或者Series分组    a   b   c   d0   0   1   2   31   4   5   6   72   8   9  10  113  12  13  14  15-----   one  two0    1    51    9   132   17   213   25   29-----a      oneb      onec      twod      twoe    threedtype: object one      2three    1two      2dtype: int64</code></pre><pre><code class="lang-python">print(&quot;分组计算函数方法&quot;)s = pd.Series([1, 2, 3, 10, 20, 30], index = [1, 2, 3, 1, 2, 3])grouped = s.groupby(level=0)  # 唯一索引用.groupby(level=0)，将同一个index的分为一组print(grouped)print(grouped.first(),&#39;→ first：非NaN的第一个值\n&#39;)print(grouped.last(),&#39;→ last：非NaN的最后一个值\n&#39;)print(grouped.sum(),&#39;→ sum：非NaN的和\n&#39;)print(grouped.mean(),&#39;→ mean：非NaN的平均值\n&#39;)print(grouped.median(),&#39;→ median：非NaN的算术中位数\n&#39;)print(grouped.count(),&#39;→ count：非NaN的值\n&#39;)print(grouped.min(),&#39;→ min、max：非NaN的最小值、最大值\n&#39;)print(grouped.std(),&#39;→ std，var：非NaN的标准差和方差\n&#39;)print(grouped.prod(),&#39;→ prod：非NaN的积\n&#39;)</code></pre><pre><code>分组计算函数方法&lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x000000000570C7B8&gt;1    12    23    3dtype: int64 → first：非NaN的第一个值1    102    203    30dtype: int64 → last：非NaN的最后一个值1    112    223    33dtype: int64 → sum：非NaN的和1     5.52    11.03    16.5dtype: float64 → mean：非NaN的平均值1     5.52    11.03    16.5dtype: float64 → median：非NaN的算术中位数1    22    23    2dtype: int64 → count：非NaN的值1    12    23    3dtype: int64 → min、max：非NaN的最小值、最大值1     6.3639612    12.7279223    19.091883dtype: float64 → std，var：非NaN的标准差和方差1    102    403    90dtype: int64 → prod：非NaN的积</code></pre><pre><code class="lang-python">print(&quot;多函数计算：agg()&quot;)df = pd.DataFrame({&#39;a&#39;:[1,1,2,2],                  &#39;b&#39;:np.random.rand(4),                  &#39;c&#39;:np.random.rand(4),                  &#39;d&#39;:np.random.rand(4),})print(df)print(df.groupby(&#39;a&#39;).agg([&#39;mean&#39;,np.sum]))df.groupby(&#39;a&#39;).agg(result1 = pd.NamedAgg(column = &#39;b&#39;,aggfunc = &#39;mean&#39;),result2 = pd.NamedAgg(column = &#39;b&#39;,aggfunc = &#39;sum&#39;))# 函数写法可以用str，或者np.方法# 可以通过list，dict传入，当用dict时，key名为columns</code></pre><pre><code>多函数计算：agg()   a         b         c         d0  1  0.126467  0.164106  0.4861381  1  0.896358  0.570124  0.0674942  2  0.423401  0.041686  0.3439263  2  0.932132  0.627672  0.746086          b                   c                   d                 mean       sum      mean       sum      mean       suma                                                            1  0.511412  1.022825  0.367115  0.734230  0.276816  0.5536312  0.677766  1.355533  0.334679  0.669358  0.545006  1.090012</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>result1</th>      <th>result2</th>    </tr>    <tr>      <th>a</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>0.511412</td>      <td>1.022825</td>    </tr>    <tr>      <th>2</th>      <td>0.677766</td>      <td>1.355533</td>    </tr>  </tbody></table></div><h2 id="7-分组转换及一般性“拆分-应用-合并”"><a href="#7-分组转换及一般性“拆分-应用-合并”" class="headerlink" title="7. 分组转换及一般性“拆分-应用-合并”"></a>7. 分组转换及一般性“拆分-应用-合并”</h2><ul><li>transform / apply</li></ul><h2 id="8-透视表及交叉表"><a href="#8-透视表及交叉表" class="headerlink" title="8.透视表及交叉表"></a>8.透视表及交叉表</h2><ul><li>类似excel数据透视 - pivot table / crosstab</li></ul><h2 id="9-数据读取"><a href="#9-数据读取" class="headerlink" title="9.数据读取"></a>9.数据读取</h2><ul><li>核心：read_table, read_csv, read_excel</li></ul><h1 id="实在看不下去了-有缘再续"><a href="#实在看不下去了-有缘再续" class="headerlink" title="实在看不下去了(有缘再续)"></a>实在看不下去了(有缘再续)</h1>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Pandas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习5:正则化线性回归和偏差、方差</title>
    <link href="/2020/07/18/ML_Andrew_Pex5_Regularized_Linear_Regression_and_Bais_Vs_Variance/"/>
    <url>/2020/07/18/ML_Andrew_Pex5_Regularized_Linear_Regression_and_Bais_Vs_Variance/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习5-正则化线性回归和偏差、方差"><a href="#吴恩达机器学习程序练习5-正则化线性回归和偏差、方差" class="headerlink" title="吴恩达机器学习程序练习5:正则化线性回归和偏差、方差"></a>吴恩达机器学习程序练习5:<br>正则化线性回归和偏差、方差</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex55139</p><h2 id="1-正则化线性回归"><a href="#1-正则化线性回归" class="headerlink" title="1. 正则化线性回归"></a>1. 正则化线性回归</h2><p>对一个水库的流出水量以及水库水位进行正则化线性回归。</p><h3 id="1-1-数据可视化"><a href="#1-1-数据可视化" class="headerlink" title="1.1 数据可视化"></a>1.1 数据可视化</h3><pre><code class="lang-python">import numpy as npimport scipy.io as sioimport scipy.optimize as optimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns</code></pre><pre><code class="lang-python">data = sio.loadmat(&#39;./andrew_ml_ex55139/ex5data1.mat&#39;)# print(data)X,y,Xval,yval,Xtest,ytest = map(np.ravel,[data[&#39;X&#39;],data[&#39;y&#39;],data[&#39;Xval&#39;],data[&#39;yval&#39;],data[&#39;Xtest&#39;],data[&#39;ytest&#39;]])X.shape,y.shape,Xval.shape,yval.shape,Xtest.shape,ytest.shape</code></pre><pre><code>((12,), (12,), (21,), (21,), (21,), (21,))</code></pre><pre><code class="lang-python">fig, ax = plt.subplots(figsize=(12,8))ax.scatter(X, y)ax.set_xlabel(&#39;water_level&#39;)ax.set_ylabel(&#39;flow&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex5_1.png" srcset="/img/loading.gif" alt="png"></p><h3 id="1-2-正则化线性回归代价函数"><a href="#1-2-正则化线性回归代价函数" class="headerlink" title="1.2 正则化线性回归代价函数"></a>1.2 正则化线性回归代价函数</h3><p>正则化线性回归代价函数公式：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}(\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})^2))+\frac{\lambda}{2m}(\sum_{j=1}^n\theta_j^2)</script><p>其中$\lambda$是正则化参数，控制了正则化的程度。正则化在原来的代价J上加了一个惩罚项。随着参数$\theta_j$的变大，惩罚项也会变大。此外，不需要正则化$\theta_0$</p><pre><code class="lang-python"># 为训练集、交叉验证集、测试集插入常数项1# X = np.insert(X.reshape(X.shape[0],1),0,np.ones(X.shape[0]),axis = 1)# Xval = np.insert(Xval.reshape(Xval.shape[0],1),0, np.ones(Xval.shape[0]),axis = 1)# Xtest = np.insert(Xtest.reshape(Xtest.shape[0],1), 0 , np.ones(Xtest.shape[0]),axis = 1)# y = y.reshape(y.shape[0],1)X, Xval, Xtest = [np.insert(x.reshape(x.shape[0], 1), 0, np.ones(x.shape[0]), axis=1) for x in (X, Xval, Xtest)]X.shape,Xval.shape,Xtest.shape</code></pre><pre><code>((12, 2), (21, 2), (21, 2))</code></pre><pre><code class="lang-python"># 维度：# X ： (m,n) m个训练集，n个特征# y : (m,1) m个训练集# h(x) = X*theta = y&#39;# theta : (n,1)def cost(theta,X,y):    m = X.shape[0]    inner = np.dot(X,theta) - y    square_sum = np.sum(inner**2)    cost = square_sum / (2*m)    return cost</code></pre><pre><code class="lang-python"># 法一：def costReg(theta,X,y,reg=1):    m = X.shape[0]    inner = np.dot(X,theta) - y    square_sum = np.sum(inner**2)    cost = square_sum / (2*m) + reg/(2*m)*np.sum(theta[1:]**2)    return cost# 法二：def costReg1(theta,X,y,reg=1):    m = X.shape[0]    regularized_term = (reg / (2 *m)) * np.power(theta[1:],2).sum()    return cost(theta,X,y) + regularized_term</code></pre><pre><code class="lang-python">theta = np.ones((X.shape[1]))print(theta)print(X)print(np.dot(X,theta).shape)print(y.shape)# print(np.dot(X,theta.T))costReg1(theta,X,y,1)</code></pre><pre><code>[1. 1.][[  1.         -15.93675813] [  1.         -29.15297922] [  1.          36.18954863] [  1.          37.49218733] [  1.         -48.05882945] [  1.          -8.94145794] [  1.          15.30779289] [  1.         -34.70626581] [  1.           1.38915437] [  1.         -44.38375985] [  1.           7.01350208] [  1.          22.76274892]](12,)(12,)303.9931922202643</code></pre><h3 id="1-3-正则化线性回归的梯度"><a href="#1-3-正则化线性回归的梯度" class="headerlink" title="1.3 正则化线性回归的梯度"></a>1.3 正则化线性回归的梯度</h3><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial \theta_0} = \frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)},for j=0</script><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial \theta_j} = \frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}+\frac{\lambda}{m}\theta_j,for j>0</script><pre><code class="lang-python">def gradient(theta,X,y):    m = X.shape[0]    inner = np.dot(X.T,(np.dot(X,theta)-y))    dtheta = inner/m    return dtheta</code></pre><pre><code class="lang-python"># 法一：def gradientReg(theta,X,y,reg):    m = X.shape[0]    inner = np.dot(X.T,(np.dot(X,theta)-y))    dtheta = inner/m    dtheta[1:] = dtheta[1:]+ (reg / m) *theta[1:]    return dtheta# 法二：def gradientReg1(theta, X, y, reg):    m = X.shape[0]    regularized_term = theta.copy()  # same shape as theta    regularized_term[0] = 0  # don&#39;t regularize intercept theta    regularized_term = (reg / m) * regularized_term    return gradient(theta, X, y) + regularized_term</code></pre><pre><code class="lang-python">gradientReg(theta,X,y,1)</code></pre><pre><code>array([-15.30301567, 598.25074417])</code></pre><h3 id="1-4-拟合线性回归"><a href="#1-4-拟合线性回归" class="headerlink" title="1.4 拟合线性回归"></a>1.4 拟合线性回归</h3><p>调用工具库找到$\theta$的最优解，在此令$\lambda=0$：因为现在训练的是二维的$\theta$，正则化不会对这种低维的$\theta$有很大的帮助。<br><br><strong>注意：</strong>使用第三方工具库时，需要按照其参数要求和自定义函数的返回值(一般要求theta为一行向量，而不是列向量)的要求</p><pre><code class="lang-python">theta = np.ones(X.shape[1])final_theta = opt.minimize(fun=costReg, x0=theta, args=(X, y, 0), method=&#39;tnc&#39;, jac=gradientReg, options={&#39;disp&#39;: True}).xfinal_theta</code></pre><pre><code>array([13.08790362,  0.36777923])</code></pre><pre><code class="lang-python">b = final_theta[0]m = final_theta[1]fig,ax = plt.subplots(figsize=(12,8))plt.scatter(X[:,1],y,c=&#39;r&#39;,label=&quot;Traning data&quot;)plt.plot(X[:,1],X[:,1]*m+b,c=&#39;b&#39;,label = &quot;Prediction&quot;)ax.set_xlabel(&#39;water_level&#39;)ax.set_ylabel(&#39;flow&#39;)ax.legend()plt.show()</code></pre><p><img src="/img/ML_Andrew/pex5_2.png" srcset="/img/loading.gif" alt="png"></p><h2 id="2-方差和偏差"><a href="#2-方差和偏差" class="headerlink" title="2. 方差和偏差"></a>2. 方差和偏差</h2><p>偏差较大的模型会欠拟合<br><br>方差较的的模型会过拟合<br><br>所以如何判断是否存在偏差和方差？</p><h3 id="2-1-学习曲线"><a href="#2-1-学习曲线" class="headerlink" title="2.1 学习曲线"></a>2.1 学习曲线</h3><ul><li>使用训练集的子集来拟合模型</li><li>在计算训练代价和验证集代价时，没有使用正则化</li><li>使用相同的训练集子集来计算训练代价。<br>代价公式：<script type="math/tex; mode=display">J_{train}(\theta)=\frac{1}{m}[\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2]</script></li></ul><pre><code class="lang-python">def linear_regression(X,y,l=1):    theta = np.ones(X.shape[1])    res = opt.minimize(fun = costReg,                      x0 = theta,                       args=(X,y,l),                       method=&#39;TNC&#39;,                       jac=gradientReg,                       options={&#39;disp&#39;:True}                      )    return res</code></pre><pre><code class="lang-python">training_cost,cv_cost = [],[]</code></pre><pre><code class="lang-python">m = X.shape[0]for i in range(1,m+1):    # 从0-m个训练集依次训练theta参数，并且计算对应的代价和验证集的代价    res = linear_regression(X[:i,:],y[:i],0)    tc = costReg(res.x,X[:i,:],y[:i],0)    cv = costReg(res.x,Xval,yval,0)    training_cost.append(tc)    cv_cost.append(cv)</code></pre><pre><code class="lang-python">fig,ax = plt.subplots(figsize=(12,8))plt.plot(np.arange(1,m+1),training_cost,label=&#39;training cost&#39;)plt.plot(np.arange(1,m+1),cv_cost,label=&#39;cv cost&#39;)ax.set_xlabel(&#39;Number training sets m&#39;)ax.set_ylabel(&#39;cost/error&#39;)plt.legend()plt.show()</code></pre><p><img src="/img/ML_Andrew/pex5_3.png" srcset="/img/loading.gif" alt="png"></p><p>If a learning algorithm is suffering from high bisa,getting more training data will not help much.<br><br>即：$J<em>{train}(\theta)$will be high,$J</em>{cv}(\theta)\approx J_{train}(\theta)$<br><br>根据图中可以得出，该模型拟合不太好，<strong>欠拟合了</strong></p><h2 id="3-多项式回归"><a href="#3-多项式回归" class="headerlink" title="3. 多项式回归"></a>3. 多项式回归</h2><p>由于对于现有数据来说，进行线性回归太过简单，容易欠拟合。因此需要多添加一些特征。</p><h3 id="3-1-特征映射"><a href="#3-1-特征映射" class="headerlink" title="3.1 特征映射"></a>3.1 特征映射</h3><pre><code class="lang-python"># 人为的添加新特征# 输入：原始X，幂的次数p# 返回：X的1-p次幂def poly_features(x,power,as_ndarray=False):    data = {&#39;f{}&#39;.format(i): np.power(x, i) for i in range(1, power + 1)}    # print(data)    df = pd.DataFrame(data)    # print(df)    return df.values if as_ndarray else df</code></pre><pre><code class="lang-python">data = sio.loadmat(&#39;./andrew_ml_ex55139/ex5data1.mat&#39;)X, y, Xval, yval, Xtest, ytest = map(np.ravel,[data[&#39;X&#39;], data[&#39;y&#39;], data[&#39;Xval&#39;], data[&#39;yval&#39;], data[&#39;Xtest&#39;], data[&#39;ytest&#39;]])</code></pre><pre><code class="lang-python">poly_features(X, power=3)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>f1</th>      <th>f2</th>      <th>f3</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>-15.936758</td>      <td>253.980260</td>      <td>-4047.621971</td>    </tr>    <tr>      <th>1</th>      <td>-29.152979</td>      <td>849.896197</td>      <td>-24777.006175</td>    </tr>    <tr>      <th>2</th>      <td>36.189549</td>      <td>1309.683430</td>      <td>47396.852168</td>    </tr>    <tr>      <th>3</th>      <td>37.492187</td>      <td>1405.664111</td>      <td>52701.422173</td>    </tr>    <tr>      <th>4</th>      <td>-48.058829</td>      <td>2309.651088</td>      <td>-110999.127750</td>    </tr>    <tr>      <th>5</th>      <td>-8.941458</td>      <td>79.949670</td>      <td>-714.866612</td>    </tr>    <tr>      <th>6</th>      <td>15.307793</td>      <td>234.328523</td>      <td>3587.052500</td>    </tr>    <tr>      <th>7</th>      <td>-34.706266</td>      <td>1204.524887</td>      <td>-41804.560890</td>    </tr>    <tr>      <th>8</th>      <td>1.389154</td>      <td>1.929750</td>      <td>2.680720</td>    </tr>    <tr>      <th>9</th>      <td>-44.383760</td>      <td>1969.918139</td>      <td>-87432.373590</td>    </tr>    <tr>      <th>10</th>      <td>7.013502</td>      <td>49.189211</td>      <td>344.988637</td>    </tr>    <tr>      <th>11</th>      <td>22.762749</td>      <td>518.142738</td>      <td>11794.353058</td>    </tr>  </tbody></table></div><h3 id="3-2-多项式回归"><a href="#3-2-多项式回归" class="headerlink" title="3.2 多项式回归"></a>3.2 多项式回归</h3><ul><li>使用之前的代价函数和梯度函数</li><li>扩展特征到8阶特征</li><li>使用<strong>归一化</strong>来处理$x^n$</li><li>不使用正则化,即设置$\lambda=0$</li></ul><pre><code class="lang-python"># 对特征进行归一化处理def normalize_feature(df):    return df.apply(lambda column: (column - column.mean()) / column.std())</code></pre><pre><code class="lang-python"># 扩展特征&quot;&quot;&quot;    args: keep feeding in X, Xval, or Xtest        will return in the same order &quot;&quot;&quot;def prepare_poly_data(*args, power):    def prepare(x):        # 扩展特征        df = poly_features(x, power=power)        # n归一化        ndarr = normalize_feature(df).values        # 插入常数项1        return np.insert(ndarr, 0, np.ones(ndarr.shape[0]), axis=1)    return [prepare(x) for x in args]</code></pre><pre><code class="lang-python">X_poly, Xval_poly, Xtest_poly= prepare_poly_data(X, Xval, Xtest, power=8)X_poly[:3, :]</code></pre><pre><code>array([[ 1.00000000e+00, -3.62140776e-01, -7.55086688e-01,         1.82225876e-01, -7.06189908e-01,  3.06617917e-01,        -5.90877673e-01,  3.44515797e-01, -5.08481165e-01],       [ 1.00000000e+00, -8.03204845e-01,  1.25825266e-03,        -2.47936991e-01, -3.27023420e-01,  9.33963187e-02,        -4.35817606e-01,  2.55416116e-01, -4.48912493e-01],       [ 1.00000000e+00,  1.37746700e+00,  5.84826715e-01,         1.24976856e+00,  2.45311974e-01,  9.78359696e-01,        -1.21556976e-02,  7.56568484e-01, -1.70352114e-01]])</code></pre><pre><code class="lang-python"># 画出学习曲线def plot_learning_curve(X, Xinit, y, Xval, yval, l=0):    training_cost,cv_cost=[],[]    m = X.shape[0]    for i in range(1,1+m):        # 不使用正则化        res = linear_regression(X[:i,:],y[:i],l)        # 因为正则化项只是用来训练参数theta，因此在计算误差时可以不需要计算正则化项        tc = cost(res.x, X[:i, :], y[:i])        cv = cost(res.x, Xval, yval)        training_cost.append(tc)        cv_cost.append(cv)    fig, ax = plt.subplots(2,  1, figsize=(12, 12))    ax[0].plot(np.arange(1, m + 1), training_cost, label=&#39;training cost&#39;)    ax[0].plot(np.arange(1, m + 1), cv_cost, label=&#39;cv cost&#39;)    ax[0].legend()    ax[0].set_xlabel(&#39;Number training sets m&#39;)    ax[0].set_ylabel(&#39;cost/error&#39;)    fitx = np.linspace(-50, 50, 100)     fitxtmp = prepare_poly_data(fitx, power=8)    fity = np.dot(prepare_poly_data(fitx, power=8)[0], linear_regression(X, y, l).x.T)    ax[1].plot(fitx, fity, c=&#39;r&#39;, label=&#39;fitcurve&#39;)    ax[1].scatter(Xinit, y, c=&#39;b&#39;, label=&#39;initial_Xy&#39;)    ax[1].set_xlabel(&#39;water_level&#39;)    ax[1].set_ylabel(&#39;flow&#39;)</code></pre><pre><code class="lang-python">plot_learning_curve(X_poly, X, y, Xval_poly, yval, l=0)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex5_4.png" srcset="/img/loading.gif" alt="png"></p><p>If a learning algorithm is suffering from high variance,getting more training data is likely to help.<br><br>即：$J<em>{train}(\theta)$will be high,$J</em>{cv}(\theta)\ll J_{train}(\theta)$<br><br>根据图中可以得出，看到训练的代价太低了，不真实. 这是<strong>过拟合了</strong></p><h3 id="3-3-调整正则化系数"><a href="#3-3-调整正则化系数" class="headerlink" title="3.3 调整正则化系数"></a>3.3 调整正则化系数</h3><p>令$\lambda=1$，使用正则化项减轻过拟合</p><pre><code class="lang-python"># 令lambda=1plot_learning_curve(X_poly, X, y, Xval_poly, yval, l=1)plt.show()</code></pre><p><img src="output_42_0.png" srcset="/img/loading.gif" alt="png"></p><p>如果令$\lambda=100$呢？<br>使正则化的惩罚太大，变成了欠拟合状态</p><pre><code class="lang-python">plot_learning_curve(X_poly, X, y, Xval_poly, yval, l=100)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex5_5.png" srcset="/img/loading.gif" alt="png"></p><h3 id="3-4-找到最佳的-lambda"><a href="#3-4-找到最佳的-lambda" class="headerlink" title="3.4 找到最佳的$\lambda$"></a>3.4 找到最佳的$\lambda$</h3><p>通过之前的实验，可以发现$\lambda$可以极大程度影响正则化多项式回归。因此此部分使用交叉验证集俩评价$\lambda$的表现好坏，然后选择表现最好的$\lambda$使用</p><p>从[0, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1, 3, 10]中尝试$\lambda$的值</p><pre><code class="lang-python">l_candidate = [0, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3,0.5,1, 3, 10]training_cost, cv_cost = [], []</code></pre><pre><code class="lang-python">for l in l_candidate:    res = linear_regression(X_poly,y,l)     # 因为正则化项只是用来训练参数theta，因此在计算误差时可以不需要计算正则化项    tc = cost(res.x,X_poly,y)    cv = cost(res.x,Xval_poly,yval)    training_cost.append(tc)    cv_cost.append(cv)</code></pre><pre><code class="lang-python"># print(training_cost)fig, ax = plt.subplots(figsize=(12,8))ax.plot(l_candidate,training_cost,label=&#39;training&#39;)ax.plot(l_candidate,cv_cost,label=&#39;cross validation&#39;)plt.legend()plt.xlabel(&#39;lambda&#39;)plt.ylabel(&#39;cost&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex5_6.png" srcset="/img/loading.gif" alt="png"></p><p>可以看到，最小值在5左右，对应的$\lambda$的值约为0.3</p><h3 id="3-5-计算测试集上的误差"><a href="#3-5-计算测试集上的误差" class="headerlink" title="3.5 计算测试集上的误差"></a>3.5 计算测试集上的误差</h3><p>实际上，为了获得一个更好的模型，需要把最终的模型用在一个从来没有在计算中出现过的测试集上，也即：需要再即没有被用作选择$\theta$也没有被用作选择$\lambda$的数据</p><pre><code class="lang-python"># 使用测试集计算误差for l in l_candidate:    theta = linear_regression(X_poly,y,l).x    print(&#39;test cost(l={}) = {}&#39;.format(l, costReg(theta, Xtest_poly, ytest,l)))</code></pre><pre><code>test cost(l=0) = 10.055426362410124test cost(l=0.001) = 11.036446361967528test cost(l=0.003) = 11.30996055923212test cost(l=0.01) = 10.974248212029881test cost(l=0.03) = 10.243474990625272test cost(l=0.1) = 9.194269309169977test cost(l=0.3) = 8.582242382060466test cost(l=0.5) = 8.858395797141128test cost(l=1) = 10.433118438156512test cost(l=3) = 17.91042362878564test cost(l=10) = 37.5893577595151</code></pre><p>调参后，$\lambda=0.3是最优选择$，这个时候测试代价最小</p><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Pandas-Base-Two</title>
    <link href="/2020/07/16/Code_One_Hour4/"/>
    <url>/2020/07/16/Code_One_Hour4/</url>
    
    <content type="html"><![CDATA[<h1 id="Pandas使用-基础篇Two"><a href="#Pandas使用-基础篇Two" class="headerlink" title="Pandas使用-基础篇Two"></a>Pandas使用-基础篇Two</h1><h2 id="1-datetime的使用"><a href="#1-datetime的使用" class="headerlink" title="1. datetime的使用"></a>1. datetime的使用</h2><ul><li>datetime模块：主要掌握:datetime.date(),datetime.datetime().datetime.timedelta()</li><li>日期解析方法：parser.parse</li></ul><pre><code class="lang-python">import datetime# 获取当天日期print(&quot;datetime.date.today()的使用：&quot;)today = datetime.date.today()print(&quot;today:&quot;,today)print(&quot;type(today):&quot;)print(type(today))print(&quot;datetime.date()的使用：&quot;)t = datetime.date(2016,6,1)print(t)print(&quot;-----------------------------&quot;)print(&quot;datetime.date.now()的使用：&quot;)now = datetime.datetime.now()print(&quot;now:&quot;,now)print(&quot;type(now):&quot;,type(now))print(&quot;datetime.datetime()的使用：&quot;)# 至少得输入年月日t1 = datetime.datetime(2016,6,1)t2 = datetime.datetime(2014,1,1,12,44,33)print(&quot;t1:&quot;,t1)print(&quot;t2:&quot;,t2)print(&quot;-----------------------------&quot;)print(&quot;datetime.timedelta()的用法&quot;)# 设置为1天print(datetime.timedelta(1))today = datetime.datetime.today()yestoday = today-datetime.timedelta(7)print(today)print(yestoday)</code></pre><pre><code>datetime.date.today()的使用：today: 2020-07-16type(today):&lt;class &#39;datetime.date&#39;&gt;datetime.date()的使用：2016-06-01-----------------------------datetime.date.now()的使用：now: 2020-07-16 15:16:12.220098type(now): &lt;class &#39;datetime.datetime&#39;&gt;datetime.datetime()的使用：t1: 2016-06-01 00:00:00t2: 2014-01-01 12:44:33-----------------------------datetime.timedelta()的用法1 day, 0:00:002020-07-16 15:16:12.2200982020-07-09 15:16:12.220098</code></pre><pre><code class="lang-python">from dateutil.parser import parseprint(&quot;使用parse()来实现日期字符串转换&quot;)date = &#39;12-21-2017&#39;t = parse(date)print(&quot;t:&quot;,t)print(&quot;type(t):&quot;,type(t))# 各种格式的日期字符串都可以解析，但是无法解析中文print(parse(&#39;2000-1-1&#39;),&#39;\n&#39;,     parse(&#39;5/1/2014&#39;),&#39;\n&#39;,      parse(&#39;5/1/2014&#39;,dayfirst=True),&#39;\n&#39;,      parse(&#39;Jan 31, 1997 10:45 PM&#39;)     )</code></pre><pre><code>使用parse()来实现日期字符串转换t: 2017-12-21 00:00:00type(t): &lt;class &#39;datetime.datetime&#39;&gt;2000-01-01 00:00:00  2014-05-01 00:00:00  2014-01-05 00:00:00  1997-01-31 22:45:00</code></pre><h2 id="2-Pandas的时刻数据类型-：-Timestamp"><a href="#2-Pandas的时刻数据类型-：-Timestamp" class="headerlink" title="2. Pandas的时刻数据类型 ： Timestamp"></a>2. Pandas的时刻数据类型 ： Timestamp</h2><ul><li>时刻数据是代表时间点，是pandas的数据类型，是将值与时间点相关联的最基本类型的时间序列数据。</li><li>pandas.Timestamp()</li></ul><pre><code class="lang-python">import numpy as npimport pandas as pddate1 = datetime.datetime(2016,12,1,12,45,30)date2 = &#39;2017-12-21&#39;t1 = pd.Timestamp(date1)t2 = pd.Timestamp(date2)print(&quot;t1:&quot;,t1)print(&quot;type(t1):&quot;,type(t1))print(&quot;t2:&quot;,t2)print(&quot;type(t2):&quot;,type(t2))print(pd.Timestamp(&#39;2020-12-21 15:00:22&#39;))</code></pre><pre><code>t1: 2016-12-01 12:45:30type(t1): &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;t2: 2017-12-21 00:00:00type(t2): &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;2020-12-21 15:00:22</code></pre><pre><code class="lang-python"># pd.to_datetime()：如果是单个时间数据，转换成pandas的时刻数据，数据类型为Timestampdate1 = datetime.datetime(2016,12,1,12,45,30)date2 = &#39;2017-12-23&#39;t1 = pd.to_datetime(date1)t2 = pd.to_datetime(date2)print(&quot;t1:&quot;,t1)print(&quot;type(t1):&quot;,type(t1))print(&quot;t2:&quot;,t2)print(&quot;type(t2):&quot;,type(t2))# 多个时间数据，将会转换为pandas的DatetimeIndexlst_date = [ &#39;2017-12-21&#39;, &#39;2017-12-22&#39;, &#39;2017-12-23&#39;]t3 = pd.to_datetime(lst_date)print(&quot;t3:&quot;,t3)print(&quot;type(t3):&quot;,type(t3))</code></pre><pre><code>t1: 2016-12-01 12:45:30type(t1): &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;t2: 2017-12-23 00:00:00type(t2): &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;t3: DatetimeIndex([&#39;2017-12-21&#39;, &#39;2017-12-22&#39;, &#39;2017-12-23&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)type(t3): &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;</code></pre><pre><code class="lang-python"># 当一组时间序列中夹杂其他格式数据，可用errors参数返回# errors = &#39;ignore&#39;:不可解析时返回原始输入，这里就是直接生成一般数组date3 = [&#39;2017-2-1&#39;,&#39;2017-2-2&#39;,&#39;2017-2-3&#39;,&#39;hello world!&#39;,&#39;2017-2-5&#39;,&#39;2017-2-6&#39;]t3 = pd.to_datetime(date3, errors = &#39;ignore&#39;)print(t3,type(t3))# errors = &#39;coerce&#39;:不可扩展，缺失值返回NaT（Not a Time），结果认为DatetimeIndext4 = pd.to_datetime(date3, errors = &#39;coerce&#39;)print(t4,type(t4))</code></pre><pre><code>Index([&#39;2017-2-1&#39;, &#39;2017-2-2&#39;, &#39;2017-2-3&#39;, &#39;hello world!&#39;, &#39;2017-2-5&#39;,       &#39;2017-2-6&#39;],      dtype=&#39;object&#39;) &lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;NaT&#39;, &#39;2017-02-05&#39;,               &#39;2017-02-06&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;</code></pre><h2 id="3-Pandas的时间戳索引数据类型：DatetimeIndex"><a href="#3-Pandas的时间戳索引数据类型：DatetimeIndex" class="headerlink" title="3. Pandas的时间戳索引数据类型：DatetimeIndex"></a>3. Pandas的时间戳索引数据类型：DatetimeIndex</h2><p>多个Timestamp组成的DatetimeIndex</p><ul><li>核心：pd.date_range()</li></ul><pre><code class="lang-python">print(&quot;直接生成时间戳索引：pd.DatetimeIndex()&quot;)rng = pd.DatetimeIndex([&#39;12/1/2017&#39;,&#39;12/2/2017&#39;,&#39;12/3/2017&#39;,&#39;12/4/2017&#39;,&#39;12/5/2017&#39;])print(rng,type(rng))print(&quot;rng[0]: &quot;,rng[0])print(&quot;type(rng[0]): &quot;,type(rng[0]))print(&quot;创建以时间戳为索引的Series&quot;)st = pd.Series(np.random.rand(len(rng)),index =rng)print(st)print(type(st))</code></pre><pre><code>直接生成时间戳索引：pd.DatetimeIndex()DatetimeIndex([&#39;2017-12-01&#39;, &#39;2017-12-02&#39;, &#39;2017-12-03&#39;, &#39;2017-12-04&#39;,               &#39;2017-12-05&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;rng[0]:  2017-12-01 00:00:00type(rng[0]):  &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;创建以时间戳为索引的Series2017-12-01    0.3950082017-12-02    0.0513712017-12-03    0.1775912017-12-04    0.8849272017-12-05    0.704827dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre><pre><code class="lang-python">print(&quot;通过pd.date_range()生成DatatimeIndex:日期范围&quot;)# 2种生成方式：①start + end； ②start/end + periods# pd.date_range(start=None, end=None, periods=None, freq=&#39;D&#39;, tz=None, normalize=False, name=None, closed=None, **kwargs)# start：开始时间# end：结束时间# periods：偏移量# freq：频率，默认天，pd.date_range()默认频率为日历日，pd.bdate_range()默认频率为工作日# tz：时区# normalize：时间参数值正则化到午夜时间戳（这里最后就直接变成0:00:00，并不是15:30:00）# name：索引对象名称# closed：默认为None的情况下，左闭右闭，left则左闭右开，right则左开右闭rng1 = pd.date_range(&#39;1/1/2017&#39;,&#39;1/10/2017&#39;, normalize=True)rng2 = pd.date_range(start = &#39;1/1/2017&#39;, periods = 10)rng3 = pd.date_range(end = &#39;1/30/2017 15:00:00&#39;, periods = 10)  # 增加了时、分、秒print(rng1)print(type(rng1))print(rng2)print(type(rng2))print(rng3)print(type(rng3))rng4 = pd.date_range(start = &#39;1/1/2017 15:30&#39;, periods = 10, name = &#39;hello world!&#39;, normalize = True)print(rng4)print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))  # 20170101也可读取print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;,closed = &#39;right&#39;))print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;,closed = &#39;left&#39;))# 直接转化为list，元素为Timestampprint(list(pd.date_range(start = &#39;1/1/2017&#39;, periods = 10)))print(&quot;-----------------------------------------------------------------&quot;)print(&quot;pd.bdate_range()默认频率为工作日&quot;)# pd.bdate_range()默认频率为工作日print(pd.bdate_range(&#39;20170101&#39;,&#39;20170107&#39;))</code></pre><pre><code>通过pd.date_range()生成DatatimeIndex:日期范围DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;DatetimeIndex([&#39;2017-01-21 15:00:00&#39;, &#39;2017-01-22 15:00:00&#39;,               &#39;2017-01-23 15:00:00&#39;, &#39;2017-01-24 15:00:00&#39;,               &#39;2017-01-25 15:00:00&#39;, &#39;2017-01-26 15:00:00&#39;,               &#39;2017-01-27 15:00:00&#39;, &#39;2017-01-28 15:00:00&#39;,               &#39;2017-01-29 15:00:00&#39;, &#39;2017-01-30 15:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)&lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],              dtype=&#39;datetime64[ns]&#39;, name=&#39;hello world!&#39;, freq=&#39;D&#39;)DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)[Timestamp(&#39;2017-01-01 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-02 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-03 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-04 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-05 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-06 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-07 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-08 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-09 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-10 00:00:00&#39;, freq=&#39;D&#39;)]-----------------------------------------------------------------pd.bdate_range()默认频率为工作日DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;, &#39;2017-01-05&#39;,               &#39;2017-01-06&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)</code></pre><pre><code class="lang-python">print(&quot;通过pd.date_range()生成DatatimeIndex: 改变频率(简单)&quot;)# 默认freq = &#39;D&#39;：每日历日print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/4&#39;))# B：每工作日print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/4&#39;,freq=&#39;B&#39;))# H：每小时print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/2&#39;,freq=&#39;H&#39;))# T/MIN：每分print(pd.date_range(&#39;2017/1/1 12:00&#39;,&#39;2017/1/1 12:10&#39;,freq=&#39;T&#39;))# S：每秒print(pd.date_range(&#39;2017/1/1 12:00&#39;,&#39;2017/1/1 12:00:30&#39;,freq=&#39;S&#39;)[3])# L：每毫秒（千分之一秒）print(pd.date_range(&#39;2017/1/1 12:00&#39;,&#39;2017/1/1 12:00:10&#39;,freq=&#39;L&#39;))# U：每微秒（百万分之一秒）print(pd.date_range(&#39;2017/1/1 12:00&#39;,&#39;2017/1/1 12:00:10&#39;,freq=&#39;U&#39;))# W-MON：从指定星期几开始算起，每周print(pd.date_range(&#39;2020/7/1&#39;,&#39;2020/7/16&#39;,freq=&#39;W-MON&#39;))# 星期几缩写：MON/TUE/WED/THU/FRI/SAT/SUN# WOM-2MON：每月的第几个星期几开始算，这里是每月第二个星期一print(pd.date_range(&#39;2020/7/1&#39;,&#39;2020/7/16&#39;,freq=&#39;WOM-2MON&#39;))</code></pre><pre><code>通过pd.date_range()生成DatatimeIndex: 改变频率(简单)DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)DatetimeIndex([&#39;2017-01-01 00:00:00&#39;, &#39;2017-01-01 01:00:00&#39;,               &#39;2017-01-01 02:00:00&#39;, &#39;2017-01-01 03:00:00&#39;,               &#39;2017-01-01 04:00:00&#39;, &#39;2017-01-01 05:00:00&#39;,               &#39;2017-01-01 06:00:00&#39;, &#39;2017-01-01 07:00:00&#39;,               &#39;2017-01-01 08:00:00&#39;, &#39;2017-01-01 09:00:00&#39;,               &#39;2017-01-01 10:00:00&#39;, &#39;2017-01-01 11:00:00&#39;,               &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 13:00:00&#39;,               &#39;2017-01-01 14:00:00&#39;, &#39;2017-01-01 15:00:00&#39;,               &#39;2017-01-01 16:00:00&#39;, &#39;2017-01-01 17:00:00&#39;,               &#39;2017-01-01 18:00:00&#39;, &#39;2017-01-01 19:00:00&#39;,               &#39;2017-01-01 20:00:00&#39;, &#39;2017-01-01 21:00:00&#39;,               &#39;2017-01-01 22:00:00&#39;, &#39;2017-01-01 23:00:00&#39;,               &#39;2017-01-02 00:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;)DatetimeIndex([&#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:01:00&#39;,               &#39;2017-01-01 12:02:00&#39;, &#39;2017-01-01 12:03:00&#39;,               &#39;2017-01-01 12:04:00&#39;, &#39;2017-01-01 12:05:00&#39;,               &#39;2017-01-01 12:06:00&#39;, &#39;2017-01-01 12:07:00&#39;,               &#39;2017-01-01 12:08:00&#39;, &#39;2017-01-01 12:09:00&#39;,               &#39;2017-01-01 12:10:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;T&#39;)2017-01-01 12:00:03DatetimeIndex([       &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:00.001000&#39;,               &#39;2017-01-01 12:00:00.002000&#39;, &#39;2017-01-01 12:00:00.003000&#39;,               &#39;2017-01-01 12:00:00.004000&#39;, &#39;2017-01-01 12:00:00.005000&#39;,               &#39;2017-01-01 12:00:00.006000&#39;, &#39;2017-01-01 12:00:00.007000&#39;,               &#39;2017-01-01 12:00:00.008000&#39;, &#39;2017-01-01 12:00:00.009000&#39;,               ...               &#39;2017-01-01 12:00:09.991000&#39;, &#39;2017-01-01 12:00:09.992000&#39;,               &#39;2017-01-01 12:00:09.993000&#39;, &#39;2017-01-01 12:00:09.994000&#39;,               &#39;2017-01-01 12:00:09.995000&#39;, &#39;2017-01-01 12:00:09.996000&#39;,               &#39;2017-01-01 12:00:09.997000&#39;, &#39;2017-01-01 12:00:09.998000&#39;,               &#39;2017-01-01 12:00:09.999000&#39;,        &#39;2017-01-01 12:00:10&#39;],              dtype=&#39;datetime64[ns]&#39;, length=10001, freq=&#39;L&#39;)DatetimeIndex([       &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:00.000001&#39;,               &#39;2017-01-01 12:00:00.000002&#39;, &#39;2017-01-01 12:00:00.000003&#39;,               &#39;2017-01-01 12:00:00.000004&#39;, &#39;2017-01-01 12:00:00.000005&#39;,               &#39;2017-01-01 12:00:00.000006&#39;, &#39;2017-01-01 12:00:00.000007&#39;,               &#39;2017-01-01 12:00:00.000008&#39;, &#39;2017-01-01 12:00:00.000009&#39;,               ...               &#39;2017-01-01 12:00:09.999991&#39;, &#39;2017-01-01 12:00:09.999992&#39;,               &#39;2017-01-01 12:00:09.999993&#39;, &#39;2017-01-01 12:00:09.999994&#39;,               &#39;2017-01-01 12:00:09.999995&#39;, &#39;2017-01-01 12:00:09.999996&#39;,               &#39;2017-01-01 12:00:09.999997&#39;, &#39;2017-01-01 12:00:09.999998&#39;,               &#39;2017-01-01 12:00:09.999999&#39;,        &#39;2017-01-01 12:00:10&#39;],              dtype=&#39;datetime64[ns]&#39;, length=10000001, freq=&#39;U&#39;)DatetimeIndex([&#39;2020-07-06&#39;, &#39;2020-07-13&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;W-MON&#39;)DatetimeIndex([&#39;2020-07-13&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;WOM-2MON&#39;)</code></pre><pre><code class="lang-python">print(&quot;通过pd.date_range()生成DatatimeIndex: 改变频率(复杂)&quot;)# M：每月最后一个日历日print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;,freq=&#39;M&#39;))# 月缩写：JAN/FEB/MAR/APR/MAY/JUN/JUL/AUG/SEP/OCT/NOV/DEC# Q-月：指定月为季度末，每个季度末最后一月的最后一个日历日# 所以Q-月只有三种情况：1-4-7-10,2-5-8-11,3-6-9-12print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;Q-MAY&#39;))  # A-月：每年指定月份的最后一个日历日print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;,freq=&#39;A-OCT&#39;))# BM：每月最后一个工作日print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;,freq=&#39;BM&#39;))# BQ-月：指定月为季度末，每个季度末（所指定月份+3是下一个季度）最后一月的最后一个工作日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BQ-MAY&#39;)) # BA-月：每年指定月份的最后一个工作日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BA-DEC&#39;))# MS：每月第一个日历日print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;MS&#39;)) # Q-月：指定月为季度末，每个季度末最后一月的第一个日历日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;QS-DEC&#39;))# A-月：每年指定月份的第一个日历日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;AS-DEC&#39;))# BMS：每月第一个工作日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BMS&#39;))# BQ-月：指定月为季度末，每个季度末最后一月的第一个工作日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BQS-DEC&#39;))  # BA-月：每年指定月份的第一个工作日print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BAS-DEC&#39;))</code></pre><pre><code>通过pd.date_range()生成DatatimeIndex: 改变频率(复杂)DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-30&#39;,               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,               &#39;2017-09-30&#39;, &#39;2017-10-31&#39;, &#39;2017-11-30&#39;, &#39;2017-12-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)DatetimeIndex([&#39;2017-02-28&#39;, &#39;2017-05-31&#39;, &#39;2017-08-31&#39;, &#39;2017-11-30&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;Q-MAY&#39;)DatetimeIndex([&#39;2017-10-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;A-OCT&#39;)DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-28&#39;,               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,               &#39;2017-09-29&#39;, &#39;2017-10-31&#39;, &#39;2017-11-30&#39;, &#39;2017-12-29&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BM&#39;)DatetimeIndex([&#39;2017-02-28&#39;, &#39;2017-05-31&#39;, &#39;2017-08-31&#39;, &#39;2017-11-30&#39;,               &#39;2018-02-28&#39;, &#39;2018-05-31&#39;, &#39;2018-08-31&#39;, &#39;2018-11-30&#39;,               &#39;2019-02-28&#39;, &#39;2019-05-31&#39;, &#39;2019-08-30&#39;, &#39;2019-11-29&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BQ-MAY&#39;)DatetimeIndex([&#39;2017-12-29&#39;, &#39;2018-12-31&#39;, &#39;2019-12-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;BA-DEC&#39;)DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-02-01&#39;, &#39;2017-03-01&#39;, &#39;2017-04-01&#39;,               &#39;2017-05-01&#39;, &#39;2017-06-01&#39;, &#39;2017-07-01&#39;, &#39;2017-08-01&#39;,               &#39;2017-09-01&#39;, &#39;2017-10-01&#39;, &#39;2017-11-01&#39;, &#39;2017-12-01&#39;,               &#39;2018-01-01&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)DatetimeIndex([&#39;2017-03-01&#39;, &#39;2017-06-01&#39;, &#39;2017-09-01&#39;, &#39;2017-12-01&#39;,               &#39;2018-03-01&#39;, &#39;2018-06-01&#39;, &#39;2018-09-01&#39;, &#39;2018-12-01&#39;,               &#39;2019-03-01&#39;, &#39;2019-06-01&#39;, &#39;2019-09-01&#39;, &#39;2019-12-01&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;QS-DEC&#39;)DatetimeIndex([&#39;2017-12-01&#39;, &#39;2018-12-01&#39;, &#39;2019-12-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;AS-DEC&#39;)DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-02-01&#39;, &#39;2017-03-01&#39;, &#39;2017-04-03&#39;,               &#39;2017-05-01&#39;, &#39;2017-06-01&#39;, &#39;2017-07-03&#39;, &#39;2017-08-01&#39;,               &#39;2017-09-01&#39;, &#39;2017-10-02&#39;, &#39;2017-11-01&#39;, &#39;2017-12-01&#39;,               &#39;2018-01-01&#39;, &#39;2018-02-01&#39;, &#39;2018-03-01&#39;, &#39;2018-04-02&#39;,               &#39;2018-05-01&#39;, &#39;2018-06-01&#39;, &#39;2018-07-02&#39;, &#39;2018-08-01&#39;,               &#39;2018-09-03&#39;, &#39;2018-10-01&#39;, &#39;2018-11-01&#39;, &#39;2018-12-03&#39;,               &#39;2019-01-01&#39;, &#39;2019-02-01&#39;, &#39;2019-03-01&#39;, &#39;2019-04-01&#39;,               &#39;2019-05-01&#39;, &#39;2019-06-03&#39;, &#39;2019-07-01&#39;, &#39;2019-08-01&#39;,               &#39;2019-09-02&#39;, &#39;2019-10-01&#39;, &#39;2019-11-01&#39;, &#39;2019-12-02&#39;,               &#39;2020-01-01&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BMS&#39;)DatetimeIndex([&#39;2017-03-01&#39;, &#39;2017-06-01&#39;, &#39;2017-09-01&#39;, &#39;2017-12-01&#39;,               &#39;2018-03-01&#39;, &#39;2018-06-01&#39;, &#39;2018-09-03&#39;, &#39;2018-12-03&#39;,               &#39;2019-03-01&#39;, &#39;2019-06-03&#39;, &#39;2019-09-02&#39;, &#39;2019-12-02&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BQS-DEC&#39;)DatetimeIndex([&#39;2017-12-01&#39;, &#39;2018-12-03&#39;, &#39;2019-12-02&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;BAS-DEC&#39;)</code></pre><pre><code class="lang-python">print(&quot;通过pd.date_range()生成DatatimeIndex: 复合频率&quot;)print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/2/1&#39;,freq=&#39;7D&#39;))print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/2/1&#39;,freq=&#39;2h30min&#39;))# 每间隔2月，每月最后一个日历日print(pd.date_range(&#39;2017/1/1&#39;,&#39;2018/2/1&#39;,freq=&#39;2M&#39;))</code></pre><pre><code>通过pd.date_range()生成DatatimeIndex: 复合频率DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-15&#39;, &#39;2017-01-22&#39;,               &#39;2017-01-29&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;7D&#39;)DatetimeIndex([&#39;2017-01-01 00:00:00&#39;, &#39;2017-01-01 02:30:00&#39;,               &#39;2017-01-01 05:00:00&#39;, &#39;2017-01-01 07:30:00&#39;,               &#39;2017-01-01 10:00:00&#39;, &#39;2017-01-01 12:30:00&#39;,               &#39;2017-01-01 15:00:00&#39;, &#39;2017-01-01 17:30:00&#39;,               &#39;2017-01-01 20:00:00&#39;, &#39;2017-01-01 22:30:00&#39;,               ...               &#39;2017-01-31 00:00:00&#39;, &#39;2017-01-31 02:30:00&#39;,               &#39;2017-01-31 05:00:00&#39;, &#39;2017-01-31 07:30:00&#39;,               &#39;2017-01-31 10:00:00&#39;, &#39;2017-01-31 12:30:00&#39;,               &#39;2017-01-31 15:00:00&#39;, &#39;2017-01-31 17:30:00&#39;,               &#39;2017-01-31 20:00:00&#39;, &#39;2017-01-31 22:30:00&#39;],              dtype=&#39;datetime64[ns]&#39;, length=298, freq=&#39;150T&#39;)DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-03-31&#39;, &#39;2017-05-31&#39;, &#39;2017-07-31&#39;,               &#39;2017-09-30&#39;, &#39;2017-11-30&#39;, &#39;2018-01-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;2M&#39;)</code></pre><pre><code class="lang-python">print(&quot;通过pd.date_range()生成DatatimeIndex：asfreq()：频率转换&quot;)ts = pd.Series(np.random.rand(4),index=pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))print(ts)# 改变频率，这里是D改为4H# method：插值模式，None不插值，ffill用之前值填充，bfill用之后值填充print(ts.asfreq(&#39;4H&#39;,method=&#39;ffill&#39;))</code></pre><pre><code>通过pd.date_range()生成DatatimeIndex：asfreq()：频率转换2017-01-01    0.9202312017-01-02    0.2074962017-01-03    0.6088602017-01-04    0.994574Freq: D, dtype: float642017-01-01 00:00:00    0.9202312017-01-01 04:00:00    0.9202312017-01-01 08:00:00    0.9202312017-01-01 12:00:00    0.9202312017-01-01 16:00:00    0.9202312017-01-01 20:00:00    0.9202312017-01-02 00:00:00    0.2074962017-01-02 04:00:00    0.2074962017-01-02 08:00:00    0.2074962017-01-02 12:00:00    0.2074962017-01-02 16:00:00    0.2074962017-01-02 20:00:00    0.2074962017-01-03 00:00:00    0.6088602017-01-03 04:00:00    0.6088602017-01-03 08:00:00    0.6088602017-01-03 12:00:00    0.6088602017-01-03 16:00:00    0.6088602017-01-03 20:00:00    0.6088602017-01-04 00:00:00    0.994574Freq: 4H, dtype: float64</code></pre><pre><code class="lang-python">print(&quot;通过pd.date_range()生成DatatimeIndex：shift():超前/滞后数据&quot;)ts = pd.Series(np.random.rand(4),              index = pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))print(ts)# 正数：数值后移（滞后）；负数：数值前移（超前）print(ts.shift(2))print(ts.shift(-2))print(&#39;------------------------------------------&#39;)# 计算变化百分比，这里计算：该时间戳与上一个时间戳相比，变化百分比print(ts.shift(1))per = ts/ts.shift(1) - 1print(per)print(&#39;------------------------------------------&#39;)# 加上freq参数：对时间戳进行位移，而不是对数值进行位移print(ts.shift(2, freq = &#39;D&#39;))print(ts.shift(2, freq = &#39;T&#39;))</code></pre><pre><code>通过pd.date_range()生成DatatimeIndex：shift():超前/滞后数据2017-01-01    0.2010282017-01-02    0.0318632017-01-03    0.8936292017-01-04    0.515929Freq: D, dtype: float642017-01-01         NaN2017-01-02         NaN2017-01-03    0.2010282017-01-04    0.031863Freq: D, dtype: float642017-01-01    0.8936292017-01-02    0.5159292017-01-03         NaN2017-01-04         NaNFreq: D, dtype: float64------------------------------------------2017-01-01         NaN2017-01-02    0.2010282017-01-03    0.0318632017-01-04    0.893629Freq: D, dtype: float642017-01-01          NaN2017-01-02    -0.8415012017-01-03    27.0461372017-01-04    -0.422659Freq: D, dtype: float64------------------------------------------2017-01-03    0.2010282017-01-04    0.0318632017-01-05    0.8936292017-01-06    0.515929Freq: D, dtype: float642017-01-01 00:02:00    0.2010282017-01-02 00:02:00    0.0318632017-01-03 00:02:00    0.8936292017-01-04 00:02:00    0.515929Freq: D, dtype: float64</code></pre><h2 id="4-Pandas的时期数据类型：Period"><a href="#4-Pandas的时期数据类型：Period" class="headerlink" title="4. Pandas的时期数据类型：Period"></a>4. Pandas的时期数据类型：Period</h2><ul><li>核心：pd.Period()</li></ul><pre><code class="lang-python">print(&quot;Period类型的创建：pd.Period()&quot;)# 生成一个以2017-01开始，月为频率的时间构造器# pd.Period()参数：一个时间戳 + freq 参数 # freq 用于指明该 period 的长度，时间戳则说明该 period 在时间轴上的位置p = pd.Period(&#39;2017&#39;,freq=&#39;M&#39;)print(p)print(type(p))print(p+1)print(p-1)print(pd.Period(&#39;2012&#39;, freq = &#39;A-DEC&#39;)-1 )</code></pre><pre><code>Period类型的创建：pd.Period()2017-01&lt;class &#39;pandas._libs.tslibs.period.Period&#39;&gt;2017-022016-122011</code></pre><pre><code class="lang-python">print(&quot;创建时期范围：pd.period_range()&quot;)prng = pd.period_range(&#39;1/1/2011&#39;,&#39;1/1/2012&#39;,freq=&#39;M&#39;)# 数据格式为PeriodIndex，单个数值为Periodprint(prng)print(type(prng))print(prng[0])print(type(prng[0]))# Timestamp表示一个时间戳，是一个时间截面；Period是一个时期，是一个时间段# 但两者作为index时区别不大ts = pd.Series(np.random.rand(len(prng)), index = prng)print(ts)print(type(ts))print(ts.index)</code></pre><pre><code>创建时期范围：pd.period_range()PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,             &#39;2012-01&#39;],            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)&lt;class &#39;pandas.core.indexes.period.PeriodIndex&#39;&gt;2011-01&lt;class &#39;pandas._libs.tslibs.period.Period&#39;&gt;2011-01    0.0948392011-02    0.0642112011-03    0.3604662011-04    0.3255292011-05    0.0111222011-06    0.0288982011-07    0.4727082011-08    0.8782152011-09    0.5347112011-10    0.8396252011-11    0.4002832011-12    0.9278772012-01    0.978354Freq: M, dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,             &#39;2012-01&#39;],            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</code></pre><pre><code class="lang-python">print(&quot;Period的频率转换：asfreq()&quot;)p = pd.Period(&#39;2017&#39;,&#39;A-DEC&#39;)print(p)# 通过.asfreq(freq, method=None, how=None)方法转换成别的频率print(p.asfreq(&#39;M&#39;, how = &#39;start&#39;))  # 也可写 how = &#39;s&#39;print(p.asfreq(&#39;D&#39;, how = &#39;end&#39;)) prng = pd.period_range(&#39;2017&#39;,&#39;2018&#39;,freq = &#39;M&#39;)ts1 = pd.Series(np.random.rand(len(prng)), index = prng)ts2 = pd.Series(np.random.rand(len(prng)), index = prng.asfreq(&#39;D&#39;, how = &#39;start&#39;))print(ts1.head(),len(ts1))print(ts2.head(),len(ts2))</code></pre><pre><code>Period的频率转换：asfreq()20172017-012017-12-312017-01    0.8249412017-02    0.6426812017-03    0.5849152017-04    0.1970872017-05    0.046987Freq: M, dtype: float64 132017-01-01    0.5171802017-02-01    0.7445252017-03-01    0.4939642017-04-01    0.2762432017-05-01    0.350304Freq: D, dtype: float64 13</code></pre><pre><code class="lang-python">print(&quot;时间戳(Timestamp)与时期Period之间的转换:to_period(),to_timestamp()&quot;)rng = pd.date_range(&#39;2017/1/1&#39;,periods=10,freq=&#39;M&#39;)prng = pd.period_range(&#39;2017&#39;,&#39;2018&#39;,freq=&#39;M&#39;)print(rng)print(prng)ts1 = pd.Series(np.random.rand(len(rng)), index = rng)print(ts1.head())# 每月最后一日，转化为每月print(ts1.to_period().head())ts2 = pd.Series(np.random.rand(len(prng)), index = prng)print(ts2.head())# 每月，转化为每月第一天print(ts2.to_timestamp().head())</code></pre><pre><code>时间戳(Timestamp)与时期Period之间的转换:to_period(),to_timestamp()DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-30&#39;,               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,               &#39;2017-09-30&#39;, &#39;2017-10-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)PeriodIndex([&#39;2017-01&#39;, &#39;2017-02&#39;, &#39;2017-03&#39;, &#39;2017-04&#39;, &#39;2017-05&#39;, &#39;2017-06&#39;,             &#39;2017-07&#39;, &#39;2017-08&#39;, &#39;2017-09&#39;, &#39;2017-10&#39;, &#39;2017-11&#39;, &#39;2017-12&#39;,             &#39;2018-01&#39;],            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)2017-01-31    0.9606482017-02-28    0.2484992017-03-31    0.9615852017-04-30    0.8655792017-05-31    0.423527Freq: M, dtype: float642017-01    0.9606482017-02    0.2484992017-03    0.9615852017-04    0.8655792017-05    0.423527Freq: M, dtype: float642017-01    0.5732672017-02    0.0633272017-03    0.1276212017-04    0.0451662017-05    0.193482Freq: M, dtype: float642017-01-01    0.5732672017-02-01    0.0633272017-03-01    0.1276212017-04-01    0.0451662017-05-01    0.193482Freq: MS, dtype: float64</code></pre><h2 id="5-时间序列：索引、切片"><a href="#5-时间序列：索引、切片" class="headerlink" title="5. 时间序列：索引、切片"></a>5. 时间序列：索引、切片</h2><ul><li>TimeSeries是Series的一个子类，所以Series索引及数据选取方面的方法基本一样</li><li>同时TimeSeries通过时间序列有更便捷的方法做索引和切片</li></ul><pre><code class="lang-python">print(&quot;索引：&quot;)rng = pd.date_range(&#39;2017/1&#39;,&#39;2017/3&#39;)ts = pd.Series(np.random.rand(len(rng)), index = rng)print(ts.head())print(&quot;--------------------------------------------------&quot;)print(&quot;基本下标位置索引：&quot;)print(ts[0])print(ts[:2])print(&quot;--------------------------------------------------&quot;)print(&quot;时间序列标签索引，支持各种时间字符串，以及datetime.datetime索引：&quot;)print(ts[&#39;2017/1/2&#39;])print(ts[&#39;20170103&#39;])print(ts[datetime.datetime(2017,1,20)])# 时间序列由于按照时间先后排序，故不用考虑顺序问题# 索引方法同样适用于Dataframe</code></pre><pre><code>索引：2017-01-01    0.2311852017-01-02    0.2346682017-01-03    0.8057482017-01-04    0.1451302017-01-05    0.070360Freq: D, dtype: float64--------------------------------------------------基本下标位置索引：0.231184563629290742017-01-01    0.2311852017-01-02    0.234668Freq: D, dtype: float64--------------------------------------------------时间序列标签索引，支持各种时间字符串，以及datetime.datetime索引：0.234667879555149120.80574835018320930.1339720263698666</code></pre><pre><code class="lang-python">print(&quot;切片：&quot;)rng = pd.date_range(&#39;2017/1&#39;,&#39;2017/3&#39;,freq = &#39;12H&#39;)ts = pd.Series(np.random.rand(len(rng)), index = rng)print(ts)print(&quot;-------------------------------------------------&quot;)# 和Series按照index索引原理一样，也是末端包含print(ts[&#39;2017/1/5&#39;:&#39;2017 02 27&#39;])print(&quot;传入月，直接得到一个切片&quot;)print(ts[&#39;2017/2&#39;].head())</code></pre><pre><code>切片：2017-01-01 00:00:00    0.0439322017-01-01 12:00:00    0.7859762017-01-02 00:00:00    0.1691602017-01-02 12:00:00    0.8025002017-01-03 00:00:00    0.864714                         ...   2017-02-27 00:00:00    0.3473982017-02-27 12:00:00    0.6610762017-02-28 00:00:00    0.8219322017-02-28 12:00:00    0.3950272017-03-01 00:00:00    0.724482Freq: 12H, Length: 119, dtype: float64-------------------------------------------------2017-01-05 00:00:00    0.6393552017-01-05 12:00:00    0.4477962017-01-06 00:00:00    0.6259112017-01-06 12:00:00    0.0192882017-01-07 00:00:00    0.047206                         ...   2017-02-25 12:00:00    0.8637762017-02-26 00:00:00    0.3026522017-02-26 12:00:00    0.9774282017-02-27 00:00:00    0.3473982017-02-27 12:00:00    0.661076Freq: 12H, Length: 108, dtype: float64传入月，直接得到一个切片2017-02-01 00:00:00    0.4864812017-02-01 12:00:00    0.0510042017-02-02 00:00:00    0.8854492017-02-02 12:00:00    0.1481652017-02-03 00:00:00    0.224783Freq: 12H, dtype: float64</code></pre><pre><code class="lang-python">print(&quot;具有重复索引的时间序列(DatetimeIndex)：&quot;)dates = pd.DatetimeIndex([&#39;1/1/2015&#39;,&#39;1/2/2015&#39;,&#39;1/3/2015&#39;,&#39;1/4/2015&#39;,&#39;1/1/2015&#39;,&#39;1/2/2015&#39;])ts = pd.Series(np.random.rand(len(dates)),index=dates)print(ts)print(&quot;.is_unique是判断vaules是否唯一&quot;)print(ts.is_unique)print(&quot;.index.is_unique是判断index是否唯一&quot;)print(ts.index.is_unique)print(&quot;-------------------------------------------&quot;)print(&quot;index有重复的将返回多个值&quot;)print(ts[&#39;20150101&#39;])print(type(ts[&#39;20150101&#39;]))print(ts[&#39;20150104&#39;])print(type(ts[&#39;20150104&#39;]))print(&quot;-------------------------------------------&quot;)print(&quot;可以通过group做分组，重复的值使用平均值处理&quot;)print(ts.groupby(level=0).mean())</code></pre><pre><code>具有重复索引的时间序列(DatetimeIndex)：2015-01-01    0.9371332015-01-02    0.7275732015-01-03    0.3602702015-01-04    0.8034392015-01-01    0.2164632015-01-02    0.211364dtype: float64.is_unique是判断vaules是否唯一True.index.is_unique是判断index是否唯一False-------------------------------------------index有重复的将返回多个值2015-01-01    0.9371332015-01-01    0.216463dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;2015-01-04    0.803439dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;-------------------------------------------可以通过group做分组，重复的值使用平均值处理2015-01-01    0.5767982015-01-02    0.4694682015-01-03    0.3602702015-01-04    0.803439dtype: float64</code></pre><h2 id="6-时间序列：重采样"><a href="#6-时间序列：重采样" class="headerlink" title="6. 时间序列：重采样"></a>6. 时间序列：重采样</h2><ul><li>将时间序列从一个频率转换为另一个频率的过程，并且会有数据的结合<ul><li>降采样：高频数据 → 低频数据，eg.以天为频率的数据转为以月为频率的数据</li><li>升采样：低频数据 → 高频数据，eg.以年为频率的数据转为以月为频率的数据</li></ul></li></ul><pre><code class="lang-python">print(&quot;重采样：.resample()&quot;)rng = pd.date_range(&#39;20170101&#39;,periods=12)ts = pd.Series(np.arange(12),index = rng)print(ts)print(&quot;------------------------------&quot;)# ts.resample(&#39;5D&#39;)：得到一个重采样构建器，频率改为5天ts_re =ts.resample(&#39;5D&#39;)# ts.resample(&#39;5D&#39;).sum():得到一个新的聚合后的Series，聚合方式为求和ts_re2 = ts.resample(&#39;5D&#39;).sum()print(ts_re)print(type(ts_re))print(ts_re2)print(type(ts_re2))print(&quot;------------------------------&quot;)print(ts.resample(&#39;5D&#39;).mean(),&#39;→ 求平均值\n&#39;)print(ts.resample(&#39;5D&#39;).max(),&#39;→ 求最大值\n&#39;)print(ts.resample(&#39;5D&#39;).min(),&#39;→ 求最小值\n&#39;)print(ts.resample(&#39;5D&#39;).median(),&#39;→ 求中值\n&#39;)print(ts.resample(&#39;5D&#39;).first(),&#39;→ 返回第一个值\n&#39;)print(ts.resample(&#39;5D&#39;).last(),&#39;→ 返回最后一个值\n&#39;)print(&quot;------------------------------&quot;)# OHLC:金融领域的时间序列聚合方式 → open开盘、high最大值、low最小值、close收盘print(ts.resample(&#39;5D&#39;).ohlc(),&#39;→ OHLC重采样\n&#39;)</code></pre><pre><code>重采样：.resample()2017-01-01     02017-01-02     12017-01-03     22017-01-04     32017-01-05     42017-01-06     52017-01-07     62017-01-08     72017-01-09     82017-01-10     92017-01-11    102017-01-12    11Freq: D, dtype: int32------------------------------DatetimeIndexResampler [freq=&lt;5 * Days&gt;, axis=0, closed=left, label=left, convention=start, base=0]&lt;class &#39;pandas.core.resample.DatetimeIndexResampler&#39;&gt;2017-01-01    102017-01-06    352017-01-11    21Freq: 5D, dtype: int32&lt;class &#39;pandas.core.series.Series&#39;&gt;------------------------------2017-01-01     2.02017-01-06     7.02017-01-11    10.5Freq: 5D, dtype: float64 → 求平均值2017-01-01     42017-01-06     92017-01-11    11Freq: 5D, dtype: int32 → 求最大值2017-01-01     02017-01-06     52017-01-11    10Freq: 5D, dtype: int32 → 求最小值2017-01-01     2.02017-01-06     7.02017-01-11    10.5Freq: 5D, dtype: float64 → 求中值2017-01-01     02017-01-06     52017-01-11    10Freq: 5D, dtype: int32 → 返回第一个值2017-01-01     42017-01-06     92017-01-11    11Freq: 5D, dtype: int32 → 返回最后一个值------------------------------            open  high  low  close2017-01-01     0     4    0      42017-01-06     5     9    5      92017-01-11    10    11   10     11 → OHLC重采样</code></pre><pre><code class="lang-python">print(&quot;降采样&quot;)print(&quot;------------------------------------&quot;)rng = pd.date_range(&#39;20170101&#39;, periods = 12)ts = pd.Series(np.arange(1,13), index = rng)print(ts)print(&quot;------------------------------------&quot;)# closed：各时间段哪一端是闭合（即包含）的，默认 左闭右闭# 详解：这里values为0-11，按照5D重采样 → [1,2,3,4,5],[6,7,8,9,10],[11,12]# left指定间隔左边为结束 → [1,2,3,4,5],[6,7,8,9,10],[11,12]# right指定间隔右边为结束 → [1],[2,3,4,5,6],[7,8,9,10,11],[12]print(ts.resample(&#39;5D&#39;).sum(),&#39;→ 默认\n&#39;)print(ts.resample(&#39;5D&#39;, closed = &#39;left&#39;).sum(),&#39;→ left\n&#39;)print(ts.resample(&#39;5D&#39;, closed = &#39;right&#39;).sum(),&#39;→ right\n&#39;)print(&quot;------------------------------------&quot;)# label：聚合值的index，默认为取左# 值采样认为默认（这里closed默认）print(ts.resample(&#39;5D&#39;, label = &#39;left&#39;).sum(),&#39;→ leftlabel\n&#39;)print(ts.resample(&#39;5D&#39;, label = &#39;right&#39;).sum(),&#39;→ rightlabel\n&#39;)</code></pre><pre><code>降采样------------------------------------2017-01-01     12017-01-02     22017-01-03     32017-01-04     42017-01-05     52017-01-06     62017-01-07     72017-01-08     82017-01-09     92017-01-10    102017-01-11    112017-01-12    12Freq: D, dtype: int32------------------------------------2017-01-01    152017-01-06    402017-01-11    23Freq: 5D, dtype: int32 → 默认2017-01-01    152017-01-06    402017-01-11    23Freq: 5D, dtype: int32 → left2016-12-27     12017-01-01    202017-01-06    452017-01-11    12Freq: 5D, dtype: int32 → right------------------------------------2017-01-01    152017-01-06    402017-01-11    23Freq: 5D, dtype: int32 → leftlabel2017-01-06    152017-01-11    402017-01-16    23Freq: 5D, dtype: int32 → rightlabel</code></pre><pre><code class="lang-python">print(&quot;升采样&quot;)print(&quot;------------------------------------&quot;)rng = pd.date_range(&#39;2017/1/1 0:0:0&#39;, periods = 5, freq = &#39;H&#39;)ts = pd.DataFrame(np.arange(15).reshape(5,3),                  index = rng,                  columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])print(ts)print(&quot;------------------------------------&quot;)# 低频转高频，主要是如何插值# .asfreq()：不做填充，返回Nan# .ffill()：向上填充# .bfill()：向下填充print(ts.resample(&#39;15T&#39;).asfreq())print(ts.resample(&#39;15T&#39;).ffill())print(ts.resample(&#39;15T&#39;).bfill())</code></pre><pre><code>升采样------------------------------------                      a   b   c2017-01-01 00:00:00   0   1   22017-01-01 01:00:00   3   4   52017-01-01 02:00:00   6   7   82017-01-01 03:00:00   9  10  112017-01-01 04:00:00  12  13  14------------------------------------                        a     b     c2017-01-01 00:00:00   0.0   1.0   2.02017-01-01 00:15:00   NaN   NaN   NaN2017-01-01 00:30:00   NaN   NaN   NaN2017-01-01 00:45:00   NaN   NaN   NaN2017-01-01 01:00:00   3.0   4.0   5.02017-01-01 01:15:00   NaN   NaN   NaN2017-01-01 01:30:00   NaN   NaN   NaN2017-01-01 01:45:00   NaN   NaN   NaN2017-01-01 02:00:00   6.0   7.0   8.02017-01-01 02:15:00   NaN   NaN   NaN2017-01-01 02:30:00   NaN   NaN   NaN2017-01-01 02:45:00   NaN   NaN   NaN2017-01-01 03:00:00   9.0  10.0  11.02017-01-01 03:15:00   NaN   NaN   NaN2017-01-01 03:30:00   NaN   NaN   NaN2017-01-01 03:45:00   NaN   NaN   NaN2017-01-01 04:00:00  12.0  13.0  14.0                      a   b   c2017-01-01 00:00:00   0   1   22017-01-01 00:15:00   0   1   22017-01-01 00:30:00   0   1   22017-01-01 00:45:00   0   1   22017-01-01 01:00:00   3   4   52017-01-01 01:15:00   3   4   52017-01-01 01:30:00   3   4   52017-01-01 01:45:00   3   4   52017-01-01 02:00:00   6   7   82017-01-01 02:15:00   6   7   82017-01-01 02:30:00   6   7   82017-01-01 02:45:00   6   7   82017-01-01 03:00:00   9  10  112017-01-01 03:15:00   9  10  112017-01-01 03:30:00   9  10  112017-01-01 03:45:00   9  10  112017-01-01 04:00:00  12  13  14                      a   b   c2017-01-01 00:00:00   0   1   22017-01-01 00:15:00   3   4   52017-01-01 00:30:00   3   4   52017-01-01 00:45:00   3   4   52017-01-01 01:00:00   3   4   52017-01-01 01:15:00   6   7   82017-01-01 01:30:00   6   7   82017-01-01 01:45:00   6   7   82017-01-01 02:00:00   6   7   82017-01-01 02:15:00   9  10  112017-01-01 02:30:00   9  10  112017-01-01 02:45:00   9  10  112017-01-01 03:00:00   9  10  112017-01-01 03:15:00  12  13  142017-01-01 03:30:00  12  13  142017-01-01 03:45:00  12  13  142017-01-01 04:00:00  12  13  14</code></pre><pre><code class="lang-python">print(&quot;时期重采样&quot;)print(&quot;------------------------------------&quot;)prng = pd.period_range(&#39;2016&#39;,&#39;2017&#39;,freq = &#39;M&#39;)ts = pd.Series(np.arange(len(prng)), index = prng)print(ts)ts.index = ts.index.astype(&#39;datetime64[ns]&#39;)print(&quot;------------------------------------&quot;)print(ts.resample(&#39;2M&#39;).sum())  # 降采样print(&quot;------------------------------------&quot;)print(ts.resample(&#39;15D&#39;).ffill())  # 升采样</code></pre><pre><code>时期重采样------------------------------------2016-01     02016-02     12016-03     22016-04     32016-05     42016-06     52016-07     62016-08     72016-09     82016-10     92016-11    102016-12    112017-01    12Freq: M, dtype: int32------------------------------------2016-01-31     02016-03-31     32016-05-31     72016-07-31    112016-09-30    152016-11-30    192017-01-31    23Freq: 2M, dtype: int32------------------------------------2016-01-01     02016-01-16     02016-01-31     02016-02-15     12016-03-01     22016-03-16     22016-03-31     22016-04-15     32016-04-30     32016-05-15     42016-05-30     42016-06-14     52016-06-29     52016-07-14     62016-07-29     62016-08-13     72016-08-28     72016-09-12     82016-09-27     82016-10-12     92016-10-27     92016-11-11    102016-11-26    102016-12-11    112016-12-26    11Freq: 15D, dtype: int32</code></pre><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Pandas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习4:神经网络学习</title>
    <link href="/2020/07/15/ML_Andrew_Pex4_Neural_Network_Learning/"/>
    <url>/2020/07/15/ML_Andrew_Pex4_Neural_Network_Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习4-神经网络学习"><a href="#吴恩达机器学习程序练习4-神经网络学习" class="headerlink" title="吴恩达机器学习程序练习4:神经网络学习"></a>吴恩达机器学习程序练习4:神经网络学习</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex45345</p><h2 id="1-神经网络"><a href="#1-神经网络" class="headerlink" title="1. 神经网络"></a>1. 神经网络</h2><p>对于此练习，我们再次处理手写数字数据集，这次使用反向传播的前馈神经网络，自动学习神经网络的参数</p><h3 id="1-1-数据可视化"><a href="#1-1-数据可视化" class="headerlink" title="1.1 数据可视化"></a>1.1 数据可视化</h3><p>这部分和ex3里是一样的，5000张20*20像素的手写数字数据集，以及对应的数字(0-9，0对应10)</p><pre><code class="lang-python">import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport matplotlibfrom scipy.io import loadmatfrom sklearn.preprocessing import OneHotEncoder</code></pre><pre><code class="lang-python">data = loadmat(&#39;./andrew_ml_ex45345/ex4data1.mat&#39;)print(type(data))data</code></pre><pre><code>&lt;class &#39;dict&#39;&gt;{&#39;__header__&#39;: b&#39;MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Oct 16 13:09:09 2011&#39;, &#39;__version__&#39;: &#39;1.0&#39;, &#39;__globals__&#39;: [], &#39;X&#39;: array([[0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        ...,        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.]]), &#39;y&#39;: array([[10],        [10],        [10],        ...,        [ 9],        [ 9],        [ 9]], dtype=uint8)}</code></pre><pre><code class="lang-python">X = data[&#39;X&#39;]y = data[&#39;y&#39;]X.shape,y.shape</code></pre><pre><code>((5000, 400), (5000, 1))</code></pre><pre><code class="lang-python">weight  = loadmat(&quot;./andrew_ml_ex45345/ex4weights.mat&quot;)# print(weight)theta1,theta2 = weight[&quot;Theta1&quot;],weight[&#39;Theta2&#39;]theta1.shape,theta2.shape</code></pre><pre><code>((25, 401), (10, 26))</code></pre><pre><code class="lang-python"># 可视化数据集sample_idx = np.random.choice(np.arange(data[&#39;X&#39;].shape[0]),100)sample_images = data[&quot;X&quot;][sample_idx,:]fig,ax_array = plt.subplots(nrows=10,ncols=10,sharey=True,sharex=True,figsize=(12,12))for r in range(10):    for c in range(10):        ax_array[r,c].matshow(np.array(sample_images[10*r+c].reshape((20,20))).T,cmap=matplotlib.cm.binary)        plt.xticks(np.array([]))        plt.yticks(np.array([]))</code></pre><p><img src="/img/ML_Andrew/4_1.png" srcset="/img/loading.gif" alt="png"></p><h3 id="1-2-模型展示"><a href="#1-2-模型展示" class="headerlink" title="1.2 模型展示"></a>1.2 模型展示</h3><p>与ex3采用相同的模型,25个隐藏层单元和10个输出层单元。<br><img src="/img/ML_Andrew/3_2.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-3-前向传播和代价函数"><a href="#1-3-前向传播和代价函数" class="headerlink" title="1.3 前向传播和代价函数"></a>1.3 前向传播和代价函数</h3><p>实现神经网络的代价函数和梯度函数要求：应该适用在任何数据集(任意数量的输入输出单元)</p><h4 id="1-3-1-激活函数"><a href="#1-3-1-激活函数" class="headerlink" title="1.3.1 激活函数"></a>1.3.1 激活函数</h4><pre><code class="lang-python">def sigmoid(z):    return 1/(1+np.exp(-z))</code></pre><h4 id="1-3-2-前向传播函数"><a href="#1-3-2-前向传播函数" class="headerlink" title="1.3.2 前向传播函数"></a>1.3.2 前向传播函数</h4><pre><code class="lang-python">def forward_propagate(X,theta1,theta2):    m = X.shape[0]    a1 = np.insert(X,0,values=np.ones(m),axis=1)    z2 = a1*theta1.T    a2 = np.insert(sigmoid(z2),0,values=np.ones(m),axis=1)    z3 = a2*theta2.T    h = sigmoid(z3)    return a1,z2,a2,z3,h</code></pre><h4 id="1-3-3-代价函数"><a href="#1-3-3-代价函数" class="headerlink" title="1.3.3 代价函数"></a>1.3.3 代价函数</h4><p>m为训练集的样本个数，k为分类的类数</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m\sum_{k=1}^k[-y_k^{(i)}log(h_\theta(x^{(i)}))_k-(1-y_k^{(i)})log(1-(h_\theta(x^{(i)}))_k)]</script><pre><code class="lang-python">def cost(theta1,theta2,inpit_size,hidden_size,num_labels,X,y,learning_rate):    m = X.shape[0]    X = np.matrix(X)    y = np.matrix(y)    a1,z2,a2,z3,h = forward_propagate(X,theta1,theta2)    # 计算代价函数    J = 0    for i in range(m):        first_term = np.multiply(-y[i,:],np.log(h[i,:]))        # second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:]))        second_term = np.multiply((1 - y[i,:]),np.log(1-h[i,:]))        J += np.sum(first_term-second_term)    J = J/m    return J</code></pre><h4 id="1-3-4-标签集转换"><a href="#1-3-4-标签集转换" class="headerlink" title="1.3.4 标签集转换"></a>1.3.4 标签集转换</h4><p>对y标签进行编码，因为一开始我们得到的y是5000*1维的向量，但是我们要将其编码成5000*10的矩阵。即：原始$y_0=2$,那么转换后的就是对应的[0,1,0,0,0,0,0,0,0,0]<br><br>Scikitlearn有一个内置编码函数，可以使用这个：</p><pre><code class="lang-python">encoder = OneHotEncoder(sparse=False)y_onehot = encoder.fit_transform(y)y_onehot.shape</code></pre><pre><code>(5000, 10)</code></pre><pre><code class="lang-python">print(y[2])print(y_onehot[2,:])</code></pre><pre><code>[10][0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</code></pre><pre><code class="lang-python"># 计算初始化theta的代价函数Jinput_size = 400hidden_size = 25num_labels = 10learning_rate = 1cost(theta1,theta2,input_size,hidden_size,num_labels,X,y_onehot,learning_rate)</code></pre><pre><code>0.2876291651613188</code></pre><h3 id="1-4-正则化代价函数"><a href="#1-4-正则化代价函数" class="headerlink" title="1.4 正则化代价函数"></a>1.4 正则化代价函数</h3><p>防止过拟合，公式：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m\sum_{k=1}^k[-y_k^{(i)}log(h_\theta(x^{(i)}))_k-(1-y_k^{(i)})log(1-(h_\theta(x^{(i)}))_k)]+\frac{\lambda}{2m}[\sum_{j=1}^{25}\sum_{k=1}^{400}(\Theta_{j,k}^{(1)})^{2}+\sum_{j=1}^{10}\sum_{k=1}^{25}(\Theta_{j,k}^{(2)})^2]</script><p><strong>注：</strong>代码需要满足任意大小的$\Theta^{(1)}$和$\Theta^{(2)}$</p><pre><code class="lang-python">def costReg(theta1,theta2,input_size,hidden_size,num_labels,X,y,learning_rate):    m = X.shape[0]    X = np.matrix(X)    y = np.matrix(y)    a1,z2,a2,z3,h = forward_propagate(X,theta1,theta2)    # 计算代价    J = 0    for i in range(m):        first_term = np.multiply(-y[i,:], np.log(h[i,:]))        second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:]))        J += np.sum(first_term - second_term)    J = J / m    # 加上正则化项    J += (float(learning_rate)/(2*m))*(np.sum(np.power(theta1[:,1:],2))+np.sum(np.power(theta2[:,1:],2)))    return J</code></pre><pre><code class="lang-python">costReg(theta1,theta2,input_size,hidden_size,num_labels,X,y_onehot,learning_rate)</code></pre><pre><code>0.38376985909092354</code></pre><h2 id="2-反向传播"><a href="#2-反向传播" class="headerlink" title="2 反向传播"></a>2 反向传播</h2><p>实现反向传播算法：计算神经网络代价函数的梯度，从而可以使用工具库来计算代价函数的最小值</p><h3 id="2-1-sigmoid函数的梯度"><a href="#2-1-sigmoid函数的梯度" class="headerlink" title="2.1 sigmoid函数的梯度"></a>2.1 sigmoid函数的梯度</h3><p>sigmoid函数的梯度(导数)，推导公式如下：（自己草稿纸推导换元即可）</p><script type="math/tex; mode=display">sigmoid(z)=g(z)=\frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">g^{'}(z)=\frac{\mathrm{d}}{\mathrm{d}z}g(z)=g(z)(1-g(z))</script><p>在绝对值较大的情况下，梯度应该接近0，当z=0时，设置梯度为0.25,此外当作用在向量以及矩阵上时，应该是计算每个元素的梯度。</p><pre><code class="lang-python">def sigmoid_gradient(z):    # np.multiply()矩阵对应元素相乘，而不是矩阵的乘法    return np.multiply(sigmoid(z),(1-sigmoid(z)))</code></pre><pre><code class="lang-python">sigmoid_gradient(0)</code></pre><pre><code>0.25</code></pre><h3 id="2-2-随机初始化"><a href="#2-2-随机初始化" class="headerlink" title="2.2 随机初始化"></a>2.2 随机初始化</h3><p>当训练神经网络时，需要将$\Theta^{(l)}$初始化，一般将$\Theta^{(l)}$设定为${-\epsilon<em>{init},\epsilon</em>{init}}$之间的随机值，此处我们设定$\epsilon_{init}=0.12$,以保证参数足够小，使参数学习更高效</p><pre><code class="lang-python">params = (np.random.random(size=hidden_size*(input_size+1)+num_labels*(hidden_size+1))-0.5)*0.24print(hidden_size*(input_size+1)+num_labels*(hidden_size+1))print(params.size)</code></pre><pre><code>1028510285</code></pre><h3 id="2-3-反向传播"><a href="#2-3-反向传播" class="headerlink" title="2.3 反向传播"></a>2.3 反向传播</h3><p>2011年左右的说法(在Deep Learning已经更加直观)：<br><br>反向传播的步骤：给定训练集$(x^{(t)},y^{(t)})$</p><ul><li>先计算前向传播得出的$h_\theta(x)$。</li><li>对应l层的每个节点j，计算误差项$\delta_j^{(l)}$,此数据衡量这个节点对最后输出的误差贡献了多少</li><li>对于每个输出节点，直接结算与目标的差值，定义为$\delta_j^{(3)}$。</li><li>对于每个隐藏节点，需要基于现有权重(l+1层的误差)，计算$\delta_j^{(l)}$，这也是为什么叫反向传播。</li></ul><pre><code class="lang-python">def backprop(params, input_size, hidden_size, num_labels, X, y, learning_rate):    m = X.shape[0]    X = np.matrix(X)    y = np.matrix(y)    # 初始化theta1    theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1))))    theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1))))    # 进行一次前向传播    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)    # 初始化梯度，误差    J = 0    delta1 = np.zeros(theta1.shape)    delta2 = np.zeros(theta2.shape)    # 计算代价函数    for i in range(m):        first_term = np.multiply(-y[i,:], np.log(h[i,:]))        second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:]))        J += np.sum(first_term - second_term)    J = J / m    # 反向传播    # 对于每一个训练样本(一共m个训练样本)    # 计算其误差(导数)    for t in range(m):        a1t = a1[t,:] # (1,401)        z2t = z2[t,:] # (1,25)        a2t = a2[t,:] # (1,26)        ht = h[t,:] # (1,10)        yt = y[t,:] # (1,10)        # 计算的是dz3的导数(梯度)        d3t = ht-yt # (1,10)        # 计算的是dz2的导数(梯度)        z2t = np.insert(z2t,0,values=np.ones(1))        d2t = np.multiply((theta2.T*d3t.T).T,sigmoid_gradient(z2t))        # 计算的是theta1的导数(梯度)        delta1 = delta1 + (d2t[:,1:]).T*a1t        #计算的是theta2的导数(梯度)        delta2 = delta2 + d3t.T*a2t    delta1 = delta1/m    delta2 = delta2/m    return J,delta1,delta2</code></pre><h3 id="2-4-梯度校验"><a href="#2-4-梯度校验" class="headerlink" title="2.4 梯度校验"></a>2.4 梯度校验</h3><p>将$\Theta^{(1)},\Theta^{(2)}$连接成一个长向量$\theta$，然后使用导数的基本定义来校验梯度。即：<script type="math/tex">\frac{\partial}{\partial \theta_i}j(\theta)=f_i(\theta)\approx\frac{J(\theta^{i+})-J(\theta^{(i-)})}{2\epsilon}</script><br>如果反向传播计算之前，则这个数字应该小于10e-9<br><strong>以下代码(我也不知道哪错了！！！(应该需要对每一个theta[ ][ ]计算梯度)待续)</strong></p><pre><code class="lang-python">def backprop_test(params, input_size, hidden_size, num_labels, X, y, learning_rate):    m = X.shape[0]    X = np.matrix(X)    y = np.matrix(y)    # 进行一次前向传播    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)    # 初始化theta1    # theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1))))    # theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1))))    # 初始化梯度，误差    J = 0    delta1 = np.zeros(theta1.shape)    delta2 = np.zeros(theta2.shape)    # 计算代价函数    for i in range(m):        first_term = np.multiply(-y[i,:], np.log(h[i,:]))        second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:]))        J += np.sum(first_term - second_term)    J = J / m    # 反向传播    # 对于每一个训练样本(一共m个训练样本)    # 计算其误差(导数)    for t in range(m):        a1t = a1[t,:] # (1,401)        z2t = z2[t,:] # (1,25)        a2t = a2[t,:] # (1,26)        ht = h[t,:] # (1,10)        yt = y[t,:] # (1,10)        # 计算的是dz3的导数(梯度)        d3t = ht-yt # (1,10)        # 计算的是dz2的导数(梯度)        z2t = np.insert(z2t,0,values=np.ones(1))        d2t = np.multiply((theta2.T*d3t.T).T,sigmoid_gradient(z2t))        # 计算的是theta1的导数(梯度)        delta1 = delta1 + (d2t[:,1:]).T*a1t        #计算的是theta2的导数(梯度)        delta2 = delta2 + d3t.T*a2t    delta1 = delta1/m    delta2 = delta2/m    return J,delta1,delta2</code></pre><pre><code class="lang-python">def approx_theta_gradient():    epsilon = 0.024    print(theta1.shape)    theta1t1= theta1    theta1t1[0,0]=theta1t1[0,0]+epsilon    print(theta1)    print(theta1t1)    theta2t1 = theta2    theta2t1[0,0]=theta2t1[0,0]+epsilon    theta1h1 = theta1    theta1h1[0,0]=theta1h1[0,0]-epsilon    theta2h1 = theta2    theta2h1[0,0]=theta2h1[0,0]-epsilon    f1 = cost(theta1t1,theta2t1,input_size,hidden_size,num_labels,X,y_onehot,learning_rate)    f2 = cost(theta1h1,theta2h1,input_size,hidden_size,num_labels,X,y_onehot,learning_rate)    print(f1)    print(f2)    dthet1 = (f1-f2)/(2*epsilon)    j,delta1,delta2 = backprop_test(params, input_size, hidden_size, num_labels, X, y, learning_rate)    print(dthet1)    return dthet1-delta1</code></pre><h3 id="2-5-正则化神经网络的反向传播"><a href="#2-5-正则化神经网络的反向传播" class="headerlink" title="2.5 正则化神经网络的反向传播"></a>2.5 正则化神经网络的反向传播</h3><p>计算带有正则化项的神经网络的反向传播</p><pre><code class="lang-python">def backpropReg(params, input_size, hidden_size, num_labels, X, y, learning_rate):    m = X.shape[0]    X = np.matrix(X)    y = np.matrix(y)    # 初始化theta    theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1))))    theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1))))    # 进行前向传播    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)    # 初始化J,d1,d2    J = 0    delta1 = np.zeros(theta1.shape)  # (25, 401)    delta2 = np.zeros(theta2.shape)  # (10, 26)   # 计算代价J    for i in range(m):        first_term = np.multiply(-y[i,:], np.log(h[i,:]))        second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:]))        J += np.sum(first_term - second_term)    J = J / m    # 为代价函数添加正则化项    J += (float(learning_rate) / (2 * m)) * (np.sum(np.power(theta1[:,1:], 2)) + np.sum(np.power(theta2[:,1:], 2)))    # 反向传播    for t in range(m):        a1t = a1[t,:]  # (1, 401)        z2t = z2[t,:]  # (1, 25)        a2t = a2[t,:]  # (1, 26)        ht = h[t,:]  # (1, 10)        yt = y[t,:]  # (1, 10)        d3t = ht - yt  # (1, 10)        z2t = np.insert(z2t, 0, values=np.ones(1))  # (1, 26)        d2t = np.multiply((theta2.T * d3t.T).T, sigmoid_gradient(z2t))  # (1, 26)        delta1 = delta1 + (d2t[:,1:]).T * a1t        delta2 = delta2 + d3t.T * a2t    delta1 = delta1 / m    delta2 = delta2 / m    # 为theta1,theta2的导数添加求导后的正则化项    delta1[:,1:] = delta1[:,1:] + (theta1[:,1:] * learning_rate) / m    delta2[:,1:] = delta2[:,1:] + (theta2[:,1:] * learning_rate) / m    # 将梯度扁平化并且连接起来    grad = np.concatenate((np.ravel(delta1), np.ravel(delta2)))    return J, grad</code></pre><h3 id="2-6-使用第三方工具库计算参数最优解"><a href="#2-6-使用第三方工具库计算参数最优解" class="headerlink" title="2.6 使用第三方工具库计算参数最优解"></a>2.6 使用第三方工具库计算参数最优解</h3><pre><code class="lang-python">from scipy.optimize import minimizeimport timets = time.time()fmin = minimize(fun=backpropReg, x0=(params), args=(input_size, hidden_size, num_labels, X, y_onehot, learning_rate),                 method=&#39;TNC&#39;, jac=True, options={&#39;maxiter&#39;: 250})print(fmin)td = time.time()print((td-ts)/60,&#39;min&#39;)</code></pre><pre><code>     fun: 0.3412497508385368     jac: array([ 1.18401994e-04, -2.19216211e-06,  2.21265574e-06, ...,       -3.42577606e-04, -2.89790391e-04, -6.89273558e-05]) message: &#39;Max. number of function evaluations reached&#39;    nfev: 251     nit: 21  status: 3 success: False       x: array([ 1.63284742, -0.01096081,  0.01106328, ...,  0.59476747,       -0.13515738, -2.62801714])5.895565982659658 min</code></pre><pre><code class="lang-python"># 获取计算后的最优参数X = np.matrix(X)thetafinal1 = np.matrix(np.reshape(fmin.x[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1))))thetafinal2 = np.matrix(np.reshape(fmin.x[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1))))# thetafinal1,thetafinal2</code></pre><pre><code class="lang-python"># 使用优化后的theta进行预测a1, z2, a2, z3, h = forward_propagate(X, thetafinal1, thetafinal2 )y_pred = np.array(np.argmax(h, axis=1) + 1)y_pred</code></pre><pre><code>array([[10],       [10],       [10],       ...,       [ 9],       [ 9],       [ 9]], dtype=int64)</code></pre><pre><code class="lang-python"># 查看精确度from sklearn.metrics import classification_reportprint(classification_report(y,y_pred))</code></pre><pre><code>              precision    recall  f1-score   support           1       0.98      0.99      0.99       500           2       0.99      0.99      0.99       500           3       0.99      0.98      0.99       500           4       0.99      0.99      0.99       500           5       1.00      0.99      1.00       500           6       1.00      0.99      0.99       500           7       0.99      0.99      0.99       500           8       0.99      1.00      1.00       500           9       0.98      0.99      0.99       500          10       0.99      1.00      1.00       500    accuracy                           0.99      5000   macro avg       0.99      0.99      0.99      5000weighted avg       0.99      0.99      0.99      5000</code></pre><h2 id="3-可视化隐藏层"><a href="#3-可视化隐藏层" class="headerlink" title="3. 可视化隐藏层"></a>3. 可视化隐藏层</h2><pre><code class="lang-python">print(thetafinal1.shape)hidden_layer = thetafinal1[:,1:]hidden_layer.shape</code></pre><pre><code>(25, 401)(25, 400)</code></pre><pre><code class="lang-python">fig,ax_array = plt.subplots(nrows=5,ncols=5,sharey=True,sharex=True,figsize=(12,12))for r in range(5):    for c in range(5):        ax_array[r,c].matshow(np.array(hidden_layer[5*r+c].reshape((20,20))),cmap=matplotlib.cm.binary)        plt.xticks(np.array([]))        plt.yticks(np.array([]))</code></pre><p><img src="/img/ML_Andrew/4_2.png" srcset="/img/loading.gif" alt="png"></p><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Pandas-Base-One</title>
    <link href="/2020/07/14/Code_One_Hour3/"/>
    <url>/2020/07/14/Code_One_Hour3/</url>
    
    <content type="html"><![CDATA[<h1 id="Pandas使用-基础篇One"><a href="#Pandas使用-基础篇One" class="headerlink" title="Pandas使用-基础篇One"></a>Pandas使用-基础篇One</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Pandas是Python第三方库，提供高性能易用数据类型和分析工具。<br><br>Pandas基于Numpy实现，常与Numpy和Matplotlib一同使用。<br><br>Pandas基于Series、DataFrame两种数据类型进行基本操作、运算操作、特征类操作、关联类操作等。</p><h2 id="2-Series数据结构"><a href="#2-Series数据结构" class="headerlink" title="2. Series数据结构"></a>2. Series数据结构</h2><h3 id="2-1-基本概念及创建"><a href="#2-1-基本概念及创建" class="headerlink" title="2.1 基本概念及创建"></a>2.1 基本概念及创建</h3><p>Series是带有标签的一维数组，可以保存任何数据类型（整数，字符串，浮点数，Python对象等）,轴标签统称为索引</p><pre><code class="lang-python">import numpy as npimport pandas as pd# 创建一个Series数据s = pd.Series(np.random.rand(5))print(&quot;s:\n&quot;,s)print(&quot;type(s):&quot;,type(s))print(&quot;s.index:&quot;,s.index)print(&quot;type(s.index):&quot;,type(s.index))print(&quot;s.values:&quot;,s.values)print(&quot;type(s.values:)&quot;,type(s.values))</code></pre><pre><code>s: 0    0.9910891    0.3906862    0.4110353    0.1578254    0.744405dtype: float64type(s): &lt;class &#39;pandas.core.series.Series&#39;&gt;s.index: RangeIndex(start=0, stop=5, step=1)type(s.index): &lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;s.values: [0.99108888 0.39068557 0.4110352  0.15782502 0.74440456]type(s.values:) &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>从上述代码可知：series相比于ndarray，是一个自带索引index的数组 → 一维数组 + 对应索引<br><br>所以当只看series的值的时候，就是一个ndarray。series和ndarray较相似，索引切片功能差别不大。<br><br>series和dict相比，series更像一个有顺序的字典（dict本身不存在顺序），其索引原理与字典相似（一个用key，一个用index）</p><h4 id="2-1-1-Series的创建"><a href="#2-1-1-Series的创建" class="headerlink" title="2.1.1 Series的创建"></a>2.1.1 Series的创建</h4><pre><code class="lang-python">print(&quot;创建方法一：由字典创建&quot;)dic = {&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3,&#39;4&#39;:4,&#39;5&#39;:&#39;hello&#39;}print(&quot;dic:&quot;,dic)s = pd.Series(dic)print(&quot;s:\n&quot;,s)print(&quot;--------------------------------------------------------&quot;)print(&quot;创建方法二：由数组创建&quot;)arr = np.random.randn(5)print(&quot;arr:&quot;,arr)s = pd.Series(arr)print(&quot;s:\n&quot;,s)print(&quot;设置Series的索引和数值类型:index,dtype&quot;)s = pd.Series(arr,index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;],dtype=np.object)print(&quot;s:\n&quot;,s)print(&quot;--------------------------------------------------------&quot;)print(&quot;创建方法三：由标量创建&quot;)# 最好提供索引s = pd.Series(10,index=range(5))print(&quot;s:\n&quot;,s)</code></pre><pre><code>创建方法一：由字典创建dic: {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: &#39;hello&#39;}s: a        1b        2c        34        45    hellodtype: object--------------------------------------------------------创建方法二：由数组创建arr: [-0.27992332 -0.47444909  0.07829063 -0.89396309 -0.71199936]s: 0   -0.2799231   -0.4744492    0.0782913   -0.8939634   -0.711999dtype: float64设置Series的索引和数值类型:index,dtypes: a    -0.279923b    -0.474449c    0.0782906d    -0.893963e    -0.711999dtype: object--------------------------------------------------------创建方法三：由标量创建s: 0    101    102    103    104    10dtype: int64</code></pre><h4 id="2-1-2-Series的属性"><a href="#2-1-2-Series的属性" class="headerlink" title="2.1.2 Series的属性"></a>2.1.2 Series的属性</h4><pre><code class="lang-python">s1 = pd.Series(np.random.randn(5))print(s1)print(&#39;--------------------------&#39;)s2 = pd.Series(np.random.randn(5),name=&#39;test&#39;)print(s2)print(&quot;Series的name属性：&quot;)print(&#39;s1.name:&#39;,s1.name,&quot;type(s1.name)&quot;,type(s1.name))print(&#39;s2.name:&#39;,s2.name,&quot;type(s2.name)&quot;,type(s2.name))print(&#39;--------------------------&#39;)print(&quot;重新命名一个Series的name:rename:不改变原Series&quot;)s3 = s2.rename(&#39;hahah&#39;)print(&quot;s2.name:&quot;,s2.name,&quot;\ns3.name:&quot;,s3.name)</code></pre><pre><code>0    0.5294231    0.1775812   -0.2461143   -1.3939324   -1.603171dtype: float64--------------------------0   -1.6608281   -0.0496512    1.1467933   -0.9169074    1.046905Name: test, dtype: float64Series的name属性：s1.name: None type(s1.name) &lt;class &#39;NoneType&#39;&gt;s2.name: test type(s2.name) &lt;class &#39;str&#39;&gt;--------------------------重新命名一个Series的name:rename:不改变原Seriess2.name: test s3.name: hahah</code></pre><h3 id="2-2-索引"><a href="#2-2-索引" class="headerlink" title="2.2 索引"></a>2.2 索引</h3><ul><li>位置下标/标签索引/切片索引/布尔索引</li></ul><pre><code class="lang-python">print(&quot;位置下标进行索引：&quot;)s = pd.Series(np.random.randn(5),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])print(s)print(&quot;s[0]:&quot;,s[0])print(&quot;type(s[0]):&quot;,type(s[0]))# 将np.float转换为python的floatprint(&quot;float(s[0])&quot;,float(s[0]))print(&quot;type(float(s[0])):&quot;,type(float(s[0])))print(&quot;numpy.float与float占用的字节不同&quot;)# print(s[-1])# print(s[6])print(&quot;位置索引只能在Series个数的范围内&quot;)</code></pre><pre><code>位置下标进行索引：a   -0.808881b    0.436290c    0.947834d    0.985208e   -1.519866dtype: float64s[0]: -0.8088810564339672type(s[0]): &lt;class &#39;numpy.float64&#39;&gt;float(s[0]) -0.8088810564339672type(float(s[0])): &lt;class &#39;float&#39;&gt;numpy.float与float占用的字节不同位置索引只能在Series个数的范围内</code></pre><pre><code class="lang-python">print(&quot;使用标签进行索引：&quot;)s = pd.Series(np.random.randn(5),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])print(s)print(&quot;s[&#39;a&#39;]:&quot;,s[&#39;a&#39;])print(&quot;type(s[&#39;a&#39;])&quot;,type(s[&#39;a&#39;]))print(&quot;多标签索引：&quot;)sci = s[[&#39;a&#39;,&#39;b&#39;,&#39;e&#39;]]print(sci)print(&quot;type(s):&quot;,type(s))print(&quot;type(sci):&quot;,type(sci))</code></pre><pre><code>使用标签进行索引：a    0.279955b   -0.537458c   -1.724077d   -1.379164e    0.414601dtype: float64s[&#39;a&#39;]: 0.2799546950699817type(s[&#39;a&#39;]) &lt;class &#39;numpy.float64&#39;&gt;多标签索引：a    0.279955b   -0.537458e    0.414601dtype: float64type(s): &lt;class &#39;pandas.core.series.Series&#39;&gt;type(sci): &lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre><pre><code class="lang-python">print(&quot;进行切片索引；&quot;)s1 = pd.Series(np.random.rand(5))s2 = pd.Series(np.random.randn(5),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])print(&quot;s1:&quot;)print(s1)print(&quot;s2:&quot;)print(s2)print(&quot;s1[1:4]:\n&quot;,s1[1:4])print(&quot;s1[4]:&quot;,s1[4])print(&quot;s2[&#39;a&#39;:&#39;c&#39;]:\n&quot;,s2[&#39;a&#39;:&#39;c&#39;])print(&quot;s2[0:3]:\n&quot;,s2[0:3])print(&quot;------------------------------&quot;)print(&quot;s2[:-1]:从头到尾不包尾&quot;)print(s2[:-1])print(&quot;跳步&quot;)print(s2[::2])</code></pre><pre><code>进行切片索引；s1:0    0.7989521    0.7232802    0.9074903    0.5499694    0.804682dtype: float64s2:a   -0.257709b    0.383322c    0.438494d   -1.134009e    0.531293dtype: float64s1[1:4]: 1    0.7232802    0.9074903    0.549969dtype: float64s1[4]: 0.804682149011115s2[&#39;a&#39;:&#39;c&#39;]: a   -0.257709b    0.383322c    0.438494dtype: float64s2[0:3]: a   -0.257709b    0.383322c    0.438494dtype: float64------------------------------s2[:-1]:从头到尾不包尾a   -0.257709b    0.383322c    0.438494d   -1.134009dtype: float64跳步a   -0.257709c    0.438494e    0.531293dtype: float64</code></pre><pre><code class="lang-python">print(&quot;使用布尔型进行索引：&quot;)s = pd.Series(np.random.rand(3)*100)s[4] = Noneprint(&quot;s:&quot;)print(s)bs1 = s&gt;50bs2 = s.isnull()bs3 = s.notnull()print(&quot;bs1 = s &gt; 50 :&quot;)print(bs1,type(bs1),bs1.dtype)print(&quot;bs2 = s.isnull :&quot;)print(bs2,type(bs2),bs2.dtype)print(&quot;bs3 = s.notnull :&quot;)print(bs3,type(bs3),bs3.dtype)print(&quot;--------------------------------------&quot;)print(&quot;s[s&gt;50]:&quot;)print(s[s&gt;50])print(&quot;s[s.notnull()]:&quot;)print(s[s.notnull()])</code></pre><pre><code>使用布尔型进行索引：s:0    89.21651    27.02942    39.34814       Nonedtype: objectbs1 = s &gt; 50 :0     True1    False2    False4    Falsedtype: bool &lt;class &#39;pandas.core.series.Series&#39;&gt; boolbs2 = s.isnull :0    False1    False2    False4     Truedtype: bool &lt;class &#39;pandas.core.series.Series&#39;&gt; boolbs3 = s.notnull :0     True1     True2     True4    Falsedtype: bool &lt;class &#39;pandas.core.series.Series&#39;&gt; bool--------------------------------------s[s&gt;50]:0    89.2165dtype: objects[s.notnull()]:0    89.21651    27.02942    39.3481dtype: object</code></pre><h3 id="2-3-基本技巧"><a href="#2-3-基本技巧" class="headerlink" title="2.3 基本技巧"></a>2.3 基本技巧</h3><ul><li>数据查看/重新索引/对齐/添加、修改、删除</li></ul><pre><code class="lang-python">print(&quot;查看数据&quot;)s = pd.Series(np.random.rand(50))print(&quot;查看头部数据(默认查看5条)&quot;)print(s.head())print(&quot;查看尾部数据(默认查看5条)&quot;)print(s.tail(10))</code></pre><pre><code>查看数据查看头部数据(默认查看5条)0    0.5418011    0.2994342    0.1316533    0.6483024    0.942479dtype: float64查看尾部数据(默认查看5条)40    0.63989041    0.65465642    0.23067343    0.05576244    0.54218545    0.99636346    0.39424647    0.37916048    0.74622049    0.077130dtype: float64</code></pre><pre><code class="lang-python">print(&quot;重新索引reindex&quot;)# .reindex将会根据索引重新排序，如果当前索引不存在，则引入缺失值Nan# fill_value参数：填充Nan的值s = pd.Series(np.random.rand(3),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])print(s)s1 = s.reindex([&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;])print(s1)s2 = s.reindex([&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;],fill_value=100)print(s2)</code></pre><pre><code>重新索引reindexa    0.465069b    0.709122c    0.820364dtype: float64c    0.820364a    0.465069b    0.709122d         NaNe         NaNdtype: float64c      0.820364a      0.465069b      0.709122d    100.000000e    100.000000dtype: float64</code></pre><pre><code class="lang-python">print(&quot;对齐&quot;)# Series 和 ndarray 之间的主要区别是，Series 上的操作会根据标签自动对齐# index顺序不会影响数值计算，以标签来计算# 空值和任何值计算结果扔为空值# 有些像数据库的全连接s1 = pd.Series(np.random.rand(3),index = [&quot;Jack&quot;,&#39;Marry&#39;,&#39;Tom&#39;])s2 = pd.Series(np.random.rand(3),index = [&quot;Wang&quot;,&quot;Jack&quot;,&quot;Marry&quot;])print(s1)print(s2)print(&quot;s1+s2:&quot;)print(s1+s2)</code></pre><pre><code>对齐Jack     0.900155Marry    0.238390Tom      0.370405dtype: float64Wang     0.398863Jack     0.336837Marry    0.757366dtype: float64s1+s2:Jack     1.236992Marry    0.995755Tom           NaNWang          NaNdtype: float64</code></pre><pre><code class="lang-python">print(&quot;删除&quot;)s = pd.Series(np.random.rand(5),index = list(&#39;ngjur&#39;))print(s)s1 = s.drop(&#39;n&#39;)s2 = s.drop([&#39;g&#39;,&#39;j&#39;])print(&quot;s1:&quot;)print(s1)print(&quot;s2:&quot;)print(s2)print(&#39;s:&#39;)print(s)</code></pre><pre><code>删除n    0.815866g    0.279513j    0.734668u    0.199442r    0.866230dtype: float64s1:g    0.279513j    0.734668u    0.199442r    0.866230dtype: float64s2:n    0.815866u    0.199442r    0.866230dtype: float64s:n    0.815866g    0.279513j    0.734668u    0.199442r    0.866230dtype: float64</code></pre><pre><code class="lang-python">print(&quot;添加&quot;)s1 = pd.Series(np.random.rand(5))s2 = pd.Series(np.random.rand(5),index = list(&#39;njurd&#39;))print(s1)print(s2)print(&quot;直接通过下标索引or标签inde添加值即可(改变原数组)&quot;)s1[5] = 100s2[&#39;a&#39;] = 100print(s1)print(s2)print(&quot;通过.append()直接添加一个数组(返回一个新数组，不改变原数组)&quot;)s3 = s1.append(s2)print(s3)print(s1)</code></pre><pre><code>添加0    0.2243551    0.8974322    0.8252913    0.6127194    0.949516dtype: float64n    0.081467j    0.341444u    0.001559r    0.599653d    0.763388dtype: float64直接通过下标索引or标签inde添加值即可(改变原数组)0      0.2243551      0.8974322      0.8252913      0.6127194      0.9495165    100.000000dtype: float64n      0.081467j      0.341444u      0.001559r      0.599653d      0.763388a    100.000000dtype: float64通过.append()直接添加一个数组(返回一个新数组，不改变原数组)0      0.2243551      0.8974322      0.8252913      0.6127194      0.9495165    100.000000n      0.081467j      0.341444u      0.001559r      0.599653d      0.763388a    100.000000dtype: float640      0.2243551      0.8974322      0.8252913      0.6127194      0.9495165    100.000000dtype: float64</code></pre><pre><code class="lang-python">print(&quot;修改&quot;)# 通过索引直接修改s = pd.Series(np.random.rand(3),index=list(&#39;abc&#39;))print(s)s[&#39;a&#39;] = 100s[[&#39;b&#39;,&#39;c&#39;]] = 200print(s)</code></pre><pre><code>修改a    0.525042b    0.005570c    0.623136dtype: float64a    100.0b    200.0c    200.0dtype: float64</code></pre><h2 id="3-Dataframe数据结构"><a href="#3-Dataframe数据结构" class="headerlink" title="3. Dataframe数据结构"></a>3. Dataframe数据结构</h2><ul><li>“二维数组”Dataframe：是一个表格类型的数据结构，是带有标签的二维数组。包含一组有序的列，其列的值类型可以是数值、字符串、布尔值等。</li><li>Dataframe中给的数据以一个或多个二维块存放，不是列表、字典或者一维数组结构。</li></ul><pre><code class="lang-python">data = {&#39;name&#39;:[&#39;Jack&#39;,&#39;Tom&#39;,&#39;Mary&#39;],       &#39;age&#39;:[18,19,20],        &#39;gender&#39;:[&#39;m&#39;,&#39;m&#39;,&#39;w&#39;]       }frame = pd.DataFrame(data)print(&quot;data:&quot;)print(data)print(&quot;frame&quot;)print(frame)print(type(frame))print(&#39;frame.index:&#39;,frame.index,&#39;\nframe.index的数据类型为：&#39;,type(frame.index))print(&#39;frame.columns:&#39;,frame.columns,&#39;\nframe.columns的数据类型为：&#39;,type(frame.columns))print(&#39;frame.values:&#39;,frame.values,&#39;\nframe.values的数据类型为：&#39;,type(frame.values))</code></pre><pre><code>data:{&#39;name&#39;: [&#39;Jack&#39;, &#39;Tom&#39;, &#39;Mary&#39;], &#39;age&#39;: [18, 19, 20], &#39;gender&#39;: [&#39;m&#39;, &#39;m&#39;, &#39;w&#39;]}frame   name  age gender0  Jack   18      m1   Tom   19      m2  Mary   20      w&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;frame.index: RangeIndex(start=0, stop=3, step=1) frame.index的数据类型为： &lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;frame.columns: Index([&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;], dtype=&#39;object&#39;) frame.columns的数据类型为： &lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;frame.values: [[&#39;Jack&#39; 18 &#39;m&#39;] [&#39;Tom&#39; 19 &#39;m&#39;] [&#39;Mary&#39; 20 &#39;w&#39;]] frame.values的数据类型为： &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h3 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h3><pre><code class="lang-python">print(&quot;创建方法一：由数组or列表组成的字典创建&quot;)# columns 为字典的key# index 为默认的数字标签# 字典value的长度必须保持一致data1 = {    &#39;a&#39;:[1,2,3],    &#39;b&#39;:[3,4,5],    &#39;c&#39;:[5,6,7]}data2 = {&#39;one&#39;:np.random.rand(3),        &#39;two&#39;:np.random.rand(3)}print(data1)print(data2)df1 = pd.DataFrame(data1)df2 = pd.DataFrame(data2)print(df1)print(df2)print(&quot;columns可以指定：多则Nan,少则省略&quot;)df1 = pd.DataFrame(data1,columns = [&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;d&#39;])df2 = pd.DataFrame(data2,columns=[&#39;one&#39;])print(df1)print(df2)print(&quot;可以重新定义index，格式为list,长度必须保持一致&quot;)df2 = pd.DataFrame(data2,index=[&#39;f1&#39;,&#39;f2&#39;,&#39;f3&#39;])print(df2)</code></pre><pre><code>创建方法一：由数组or列表组成的字典创建{&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [3, 4, 5], &#39;c&#39;: [5, 6, 7]}{&#39;one&#39;: array([0.46225442, 0.36833065, 0.3688846 ]), &#39;two&#39;: array([0.32915014, 0.49685771, 0.98724123])}   a  b  c0  1  3  51  2  4  62  3  5  7        one       two0  0.462254  0.3291501  0.368331  0.4968582  0.368885  0.987241columns可以指定：多则Nan,少则省略   b  c  a    d0  3  5  1  NaN1  4  6  2  NaN2  5  7  3  NaN        one0  0.4622541  0.3683312  0.368885可以重新定义index，格式为list,长度必须保持一致         one       twof1  0.462254  0.329150f2  0.368331  0.496858f3  0.368885  0.987241</code></pre><pre><code class="lang-python">print(&quot;创建方法二：由Series组成的字典&quot;)# 由Seris组成的字典 创建Dataframe，columns为字典key，# index为Series的标签（如果Series没有指定标签，则是默认数字标签）# Series可以长度不一样，生成的Dataframe会出现NaN值data1 = {    &#39;one&#39;:pd.Series(np.random.rand(2)),    &#39;two&#39;:pd.Series(np.random.rand(3))}data2 = {    &#39;one&#39;:pd.Series(np.random.rand(2),index=[&#39;a&#39;,&#39;b&#39;]),    &#39;two&#39;:pd.Series(np.random.rand(3),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])}print(data1)print(data2)df1 = pd.DataFrame(data1)df2 = pd.DataFrame(data2)print(df1)print(df2)</code></pre><pre><code>创建方法二：由Series组成的字典{&#39;one&#39;: 0    0.5834431    0.743103dtype: float64, &#39;two&#39;: 0    0.6921301    0.1646972    0.857449dtype: float64}{&#39;one&#39;: a    0.24425b    0.48213dtype: float64, &#39;two&#39;: a    0.654920b    0.625679c    0.307724dtype: float64}        one       two0  0.583443  0.6921301  0.743103  0.1646972       NaN  0.857449       one       twoa  0.24425  0.654920b  0.48213  0.625679c      NaN  0.307724</code></pre><pre><code class="lang-python">print(&quot;创建方法三：通过二维数组直接创建&quot;)# index和colunms指定长度与原数组保持一致ar = np.random.rand(9).reshape(3,3)print(ar)df1 = pd.DataFrame(ar)df2 = pd.DataFrame(ar,index=[&#39;a&#39;,&#39;v&#39;,&#39;c&#39;],columns=[&#39;one&#39;,&#39;tow&#39;,&#39;three&#39;])print(df1)print(df2)</code></pre><pre><code>创建方法三：通过二维数组直接创建[[0.36972013 0.95234904 0.1272267 ] [0.88124423 0.67480024 0.22678015] [0.232217   0.62060741 0.56844851]]          0         1         20  0.369720  0.952349  0.1272271  0.881244  0.674800  0.2267802  0.232217  0.620607  0.568449        one       tow     threea  0.369720  0.952349  0.127227v  0.881244  0.674800  0.226780c  0.232217  0.620607  0.568449</code></pre><pre><code class="lang-python">print(&quot;创建方法四：由字典组成的列表创建&quot;)data = [{&#39;one&#39;:1,&#39;two&#39;:2},{&#39;one&#39;:5,&#39;two&#39;:10,&#39;three&#39;:20}]print(data)df1 = pd.DataFrame(data)df2 = pd.DataFrame(data,index=[&#39;a&#39;,&#39;b&#39;])df3 = pd.DataFrame(data,columns=[&#39;one&#39;,&#39;two&#39;])print(df1)print(df2)print(df3)</code></pre><pre><code>创建方法四：由字典组成的列表创建[{&#39;one&#39;: 1, &#39;two&#39;: 2}, {&#39;one&#39;: 5, &#39;two&#39;: 10, &#39;three&#39;: 20}]   one  two  three0    1    2    NaN1    5   10   20.0   one  two  threea    1    2    NaNb    5   10   20.0   one  two0    1    21    5   10</code></pre><pre><code class="lang-python">print(&quot;创建方法五：由字典组成的字典&quot;)# columns参数可以增加和减少现有列，如出现新的列，值为NaN# 不能改变原有index，如果指向新的标签，值为NaN （非常重要！）data = {&#39;Jack&#39;:{&#39;math&#39;:90,&#39;english&#39;:89,&#39;art&#39;:{&quot;one&quot;:1,&#39;two&#39;:2}},        &#39;Marry&#39;:{&#39;math&#39;:50,&#39;english&#39;:59,&#39;art&#39;:35},        &#39;Tom&#39;:{&#39;math&#39;:20,&#39;english&#39;:29,&#39;art&#39;:21}       }df1 = pd.DataFrame(data)print(df1)df2 = pd.DataFrame(data,columns=[&#39;Jack&#39;,&#39;Tom&#39;,&#39;Bob&#39;])df3 = pd.DataFrame(data,index=[&#39;math&#39;,&#39;v&#39;,&#39;c&#39;])print(df2)print(df3)</code></pre><pre><code>创建方法五：由字典组成的字典                         Jack  Marry  Tommath                       90     50   20english                    89     59   29art      {&#39;one&#39;: 1, &#39;two&#39;: 2}     35   21                         Jack  Tom  Bobmath                       90   20  NaNenglish                    89   29  NaNart      {&#39;one&#39;: 1, &#39;two&#39;: 2}   21  NaN      Jack  Marry   Tommath  90.0   50.0  20.0v      NaN    NaN   NaNc      NaN    NaN   NaN</code></pre><h3 id="3-2-索引"><a href="#3-2-索引" class="headerlink" title="3.2 索引"></a>3.2 索引</h3><ul><li>DataFrame即有行索引也有列索引，可以看做由Series组成的字典</li><li>选择列/选择行/切片/布尔判断</li></ul><pre><code class="lang-python">print(&quot;选择行与列&quot;)df = pd.DataFrame(np.random.rand(12).reshape(3,4)*100,                 index = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;],                 columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&quot;按照列名选择列，只选择一列输出Series，选择多列输出Dataframe&quot;)data1 = df[&#39;a&#39;]data2 = df[[&#39;a&#39;,&#39;c&#39;]]print(&quot;data1:&quot;)print(data1)print(&quot;type(data1):&quot;)print(type(data1))print(&quot;data2:&quot;)print(data2)print(&quot;type(data2):&quot;)print(type(data2))print(&quot;按照index选择行，只选择一行输出Series，选择多行输出Dataframe&quot;)data3 = df.loc[&#39;one&#39;]data4 = df.loc[[&#39;one&#39;,&#39;two&#39;]]print(&quot;data3:&quot;)print(data3)print(&quot;type(data3):&quot;)print(type(data3))print(&quot;data4:&quot;)print(data4)print(&quot;type(data4):&quot;)print(type(data4))</code></pre><pre><code>选择行与列               a          b          c          done    34.515554  98.949577  43.898236   9.665055two     3.553410  13.477195  39.114289   7.865690three  24.351288  49.230077  22.481929  62.159299按照列名选择列，只选择一列输出Series，选择多列输出Dataframedata1:one      34.515554two       3.553410three    24.351288Name: a, dtype: float64type(data1):&lt;class &#39;pandas.core.series.Series&#39;&gt;data2:               a          cone    34.515554  43.898236two     3.553410  39.114289three  24.351288  22.481929type(data2):&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;按照index选择行，只选择一行输出Series，选择多行输出Dataframedata3:a    34.515554b    98.949577c    43.898236d     9.665055Name: one, dtype: float64type(data3):&lt;class &#39;pandas.core.series.Series&#39;&gt;data4:             a          b          c         done  34.515554  98.949577  43.898236  9.665055two   3.553410  13.477195  39.114289  7.865690type(data4):&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><pre><code class="lang-python">print(&quot;df[]:[]里为列名选择列，[]为切片数字选择行且为DataFrame类型&quot;)# 不能带有不存在的标签进行索引df = pd.DataFrame(np.random.rand(12).reshape(3,4)*100,                 index = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;],                 columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&quot;----------------------------------------------------------&quot;)data1 = df[&#39;a&#39;]data2 = df[[&#39;b&#39;,&#39;c&#39;]]print(data1)print(data2)print(&quot;----------------------------------------------------------&quot;)# data3 = df[2]# data3 = df[&#39;one&#39;]data3 = df[:2]print(data3)</code></pre><pre><code>df[]:[]里为列名选择列，[]为切片数字选择行且为DataFrame类型               a          b          c          done    83.198851   3.308012  36.786939  82.549339two    77.854744  60.662882  74.282610  66.435758three  64.264539  55.905489  75.796004  88.491406----------------------------------------------------------one      83.198851two      77.854744three    64.264539Name: a, dtype: float64               b          cone     3.308012  36.786939two    60.662882  74.282610three  55.905489  75.796004----------------------------------------------------------             a          b          c          done  83.198851   3.308012  36.786939  82.549339two  77.854744  60.662882  74.282610  66.435758</code></pre><pre><code class="lang-python">print(&quot;df.loc[]用于一般的按index索引行&quot;)# 不能带有不存在的标签进行索引df1 = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   index = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;],                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])df2 = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df1)print(df2)print(&#39;-------------------------------------------------&#39;)print(&quot;单标签索引返回Series类型&quot;)data1 = df1.loc[&#39;one&#39;]data2 =df2.loc[1]print(data1)print(type(data1))print(data2)print(type(data2))print(&#39;-------------------------------------------------&#39;)print(&quot;多标签索引返回DataFrame类型&quot;)data3 = df1.loc[[&#39;two&#39;,&#39;three&#39;,]]data4 = df2.loc[[3,2,1]]print(data3)print(type(data3))print(data4)print(type(data4))print(&#39;-------------------------------------------------&#39;)print(&quot;行切片索引也使用loc&quot;)data5 = df1.loc[&#39;one&#39;:&#39;three&#39;]data6 = df2.loc[1:3]print(data5)print(data6)</code></pre><pre><code>df.loc[]用于一般的按index索引行               a          b          c          done     4.433433  18.488460   5.073606  77.901160two    28.299044  36.706668  55.477949  88.617636three  67.329849  41.235974  78.402812  65.005240four   78.509645  87.248411  88.946362  72.474774           a          b          c          d0  25.421173  86.974363  50.466541   5.3469361   2.100977  41.670700  95.095015  53.0272832  66.022038  66.276853  95.279613  15.7456683  97.756592  70.521653  42.338155  82.867693-------------------------------------------------单标签索引返回Series类型a     4.433433b    18.488460c     5.073606d    77.901160Name: one, dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;a     2.100977b    41.670700c    95.095015d    53.027283Name: 1, dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;-------------------------------------------------多标签索引返回DataFrame类型               a          b          c          dtwo    28.299044  36.706668  55.477949  88.617636three  67.329849  41.235974  78.402812  65.005240&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;           a          b          c          d3  97.756592  70.521653  42.338155  82.8676932  66.022038  66.276853  95.279613  15.7456681   2.100977  41.670700  95.095015  53.027283&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;-------------------------------------------------行切片索引也使用loc               a          b          c          done     4.433433  18.488460   5.073606  77.901160two    28.299044  36.706668  55.477949  88.617636three  67.329849  41.235974  78.402812  65.005240           a          b          c          d1   2.100977  41.670700  95.095015  53.0272832  66.022038  66.276853  95.279613  15.7456683  97.756592  70.521653  42.338155  82.867693</code></pre><pre><code class="lang-python">print(&quot;df.iloc[]按整数位置(0-length)索引行&quot;)df = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   index = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;],                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&#39;--------------------------------------------------&#39;)print(&quot;单位置索引(不可超过行数)返回Series类型&quot;)print(df.iloc[0])print(df.iloc[-1])print(type(df.iloc[0]))print(&#39;--------------------------------------------------&#39;)print(&quot;多位置索引(不可超过行数)返回DataFrame类型&quot;)# 顺序可变print(df.iloc[[0,2]])print(df.iloc[[3,2,1]])print(&#39;--------------------------------------------------&#39;)print(&quot;切片索引(不可超过行数)返回DataFrame类型&quot;)print(df.iloc[0:2])print(df.iloc[:-1])</code></pre><pre><code>df.iloc[]按整数位置(0-length)索引行               a          b          c          done    90.019311   7.982531  29.532628  93.410032two     6.744925   0.010697  76.843287  65.002500three  32.529591  27.465725  34.814478  30.768194four   10.434341  46.873697  80.104416  18.696060--------------------------------------------------单位置索引(不可超过行数)返回Series类型a    90.019311b     7.982531c    29.532628d    93.410032Name: one, dtype: float64a    10.434341b    46.873697c    80.104416d    18.696060Name: four, dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;--------------------------------------------------多位置索引(不可超过行数)返回DataFrame类型               a          b          c          done    90.019311   7.982531  29.532628  93.410032three  32.529591  27.465725  34.814478  30.768194               a          b          c          dfour   10.434341  46.873697  80.104416  18.696060three  32.529591  27.465725  34.814478  30.768194two     6.744925   0.010697  76.843287  65.002500--------------------------------------------------切片索引(不可超过行数)返回DataFrame类型             a         b          c          done  90.019311  7.982531  29.532628  93.410032two   6.744925  0.010697  76.843287  65.002500               a          b          c          done    90.019311   7.982531  29.532628  93.410032two     6.744925   0.010697  76.843287  65.002500three  32.529591  27.465725  34.814478  30.768194</code></pre><pre><code class="lang-python">print(&quot;布尔类型索引&quot;)df = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   index = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;],                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&#39;--------------------------------------------------&#39;)print(&quot;每个元素判断生成布尔型并且索引&quot;)# 索引结果保留 所有数据：True返回原数据，False返回值为NaNb1 = df&lt;20print(b1)print(type(b1))print(df[b1])print(&#39;--------------------------------------------------&#39;)print(&quot;单列判断生成布尔型并且索引&quot;)# 索引结果保留 单列判断为True的行数据，包括其他列b2 = df[&#39;a&#39;]&gt;50print(b2)print(type(b2))print(df[b2])print(&#39;--------------------------------------------------&#39;)print(&quot;多列判断生成布尔型并且索引&quot;)# 索引结果保留 所有数据：True返回原数据，False返回值为NaNb3 = df[[&#39;a&#39;,&#39;b&#39;]]&gt;50print(b3)print(type(b3))print(df[b3])print(&#39;--------------------------------------------------&#39;)print(&quot;多行判断生成布尔型并且索引&quot;)# 索引结果保留 所有数据：True返回原数据，False返回值为NaNb4 = df.loc[[&#39;one&#39;,&#39;three&#39;]]&gt;50print(b4)print(type(b4))print(df[b4])</code></pre><pre><code>布尔类型索引               a          b          c          done    28.998578  41.329836  49.808520  20.614252two    69.983658  34.904093  89.407329  33.697769three  73.968437  13.572205  77.644312  82.873489four    3.867114  32.306858  35.811209  74.641972--------------------------------------------------每个元素判断生成布尔型并且索引           a      b      c      done    False  False  False  Falsetwo    False  False  False  Falsethree  False   True  False  Falsefour    True  False  False  False&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;              a          b   c   done         NaN        NaN NaN NaNtwo         NaN        NaN NaN NaNthree       NaN  13.572205 NaN NaNfour   3.867114        NaN NaN NaN--------------------------------------------------单列判断生成布尔型并且索引one      Falsetwo       Truethree     Truefour     FalseName: a, dtype: bool&lt;class &#39;pandas.core.series.Series&#39;&gt;               a          b          c          dtwo    69.983658  34.904093  89.407329  33.697769three  73.968437  13.572205  77.644312  82.873489--------------------------------------------------多列判断生成布尔型并且索引           a      bone    False  Falsetwo     True  Falsethree   True  Falsefour   False  False&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;               a   b   c   done          NaN NaN NaN NaNtwo    69.983658 NaN NaN NaNthree  73.968437 NaN NaN NaNfour         NaN NaN NaN NaN--------------------------------------------------多行判断生成布尔型并且索引           a      b      c      done    False  False  False  Falsethree   True  False   True   True&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;               a   b          c          done          NaN NaN        NaN        NaNtwo          NaN NaN        NaN        NaNthree  73.968437 NaN  77.644312  82.873489four         NaN NaN        NaN        NaN</code></pre><pre><code class="lang-python">print(&quot;多重索引：如同时索引行和列&quot;)print(&quot;布尔类型索引&quot;)df = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   index = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;],                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&#39;--------------------------------------------------&#39;)print(df[&#39;a&#39;].loc[[&#39;one&#39;,&#39;three&#39;]])print(df[[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]].iloc[::2])print(df[df[&#39;a&#39;]&lt;50].iloc[:2])</code></pre><pre><code>多重索引：如同时索引行和列布尔类型索引               a          b          c          done    72.241830  32.478322  61.098307  41.233279two     0.578751   7.160494  23.428193  99.938190three  10.793854  16.929929  71.040860  35.324026four   19.334477   5.480799  54.711986  28.119088--------------------------------------------------one      72.241830three    10.793854Name: a, dtype: float64               b          c          done    32.478322  61.098307  41.233279three  16.929929  71.040860  35.324026               a          b          c          dtwo     0.578751   7.160494  23.428193  99.938190three  10.793854  16.929929  71.040860  35.324026</code></pre><h3 id="3-3-基本技巧"><a href="#3-3-基本技巧" class="headerlink" title="3.3 基本技巧"></a>3.3 基本技巧</h3><ul><li>数据查看、转置、添加、修改、删除、对齐、排序</li></ul><pre><code class="lang-python">print(&quot;查看数据：&quot;)df = pd.DataFrame(np.random.rand(8).reshape(4,2)*100,columns=[&#39;a&#39;,&#39;b&#39;])print(df)print(df.head(2))print(df.tail())print(&quot;DataFrame转置&quot;)print(df.T)</code></pre><pre><code>查看数据：           a          b0  77.464431   1.6022591  82.486761  96.5623922  87.438763   2.6510023  94.637020  53.445543           a          b0  77.464431   1.6022591  82.486761  96.562392           a          b0  77.464431   1.6022591  82.486761  96.5623922  87.438763   2.6510023  94.637020  53.445543DataFrame转置           0          1          2          3a  77.464431  82.486761  87.438763  94.637020b   1.602259  96.562392   2.651002  53.445543</code></pre><pre><code class="lang-python">print(&quot;添加、修改数据(与Series类似)&quot;)print(&quot;添加前&quot;)print(df)df[&#39;e&#39;] = 10df.loc[4] = 20print(&quot;添加后&quot;)print(df)print(&quot;修改前&quot;)print(df)df[[&#39;a&#39;,&#39;b&#39;]]=1000print(&quot;修改后&quot;)print(df)</code></pre><pre><code>添加、修改数据(与Series类似)添加前           a          b0  77.464431   1.6022591  82.486761  96.5623922  87.438763   2.6510023  94.637020  53.445543添加后           a          b   e0  77.464431   1.602259  101  82.486761  96.562392  102  87.438763   2.651002  103  94.637020  53.445543  104  20.000000  20.000000  20修改前           a          b   e0  77.464431   1.602259  101  82.486761  96.562392  102  87.438763   2.651002  103  94.637020  53.445543  104  20.000000  20.000000  20修改后      a     b   e0  1000  1000  101  1000  1000  102  1000  1000  103  1000  1000  104  1000  1000  20</code></pre><pre><code class="lang-python">print(&quot;删除，使用del or drop()：&quot;)df = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df)print(&quot;-----------------------------------------------&quot;)print(&quot;使用del删除列&quot;)del df[&#39;a&#39;]print(df)print(&quot;-----------------------------------------------&quot;)print(&quot;使用drop()删除行,inplace=False:不改变原数据&quot;)print(df.drop(0))print(df.drop([1,2]))print(&quot;-----------------------------------------------&quot;)print(&quot;使用drop()删除列要设置axis=1,inplace=False:不改变原数据&quot;)print(df.drop([&#39;d&#39;],axis=1))</code></pre><pre><code>删除，使用del or drop()：           a          b          c          d0  97.807068  53.407032  88.333922  95.9671871   9.259551  85.246644  44.608161   4.6341622  88.149406  94.593139  50.604282  27.7852263  26.841337  30.868968  55.227238  68.527238-----------------------------------------------使用del删除列           b          c          d0  53.407032  88.333922  95.9671871  85.246644  44.608161   4.6341622  94.593139  50.604282  27.7852263  30.868968  55.227238  68.527238-----------------------------------------------使用drop()删除行,inplace=False:不改变原数据           b          c          d1  85.246644  44.608161   4.6341622  94.593139  50.604282  27.7852263  30.868968  55.227238  68.527238           b          c          d0  53.407032  88.333922  95.9671873  30.868968  55.227238  68.527238-----------------------------------------------使用drop()删除列要设置axis=1,inplace=False:不改变原数据           b          c0  53.407032  88.3339221  85.246644  44.6081612  94.593139  50.6042823  30.868968  55.227238</code></pre><pre><code class="lang-python">print(&quot;对齐：类似数据库的全连接&quot;)df1 = pd.DataFrame(np.random.randn(10, 4), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])df2 = pd.DataFrame(np.random.randn(7, 3), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])print(df1)print(df2)print(df1 + df2)</code></pre><pre><code>对齐：类似数据库的全连接          A         B         C         D0 -0.055925 -0.319745 -0.946771  2.5881411 -0.671828  0.643480  1.305409  0.1765692  1.055132  0.691310 -1.766530 -2.0746783  1.138196 -0.286035  0.478995 -0.2453234 -0.596816  2.152932 -0.693077  0.7571235 -0.328919 -0.469229 -0.573841 -0.5244546  0.057870  1.602256 -0.498194 -3.0191527 -0.830605  2.210687 -0.392986 -1.6656458  0.362456  1.454338  1.206861  0.2770269  0.043931 -0.484493 -0.969698 -0.282779          A         B         C0 -0.582988 -0.276731  0.5884201  0.944057  2.445921 -1.5167672 -1.477689 -2.013599 -1.5191063  0.096133  0.299149 -0.0419004 -0.425194 -1.316385  1.4589565  0.260500  2.130911  0.5861416  1.134267  1.364988 -0.906205          A         B         C   D0 -0.638912 -0.596476 -0.358351 NaN1  0.272230  3.089401 -0.211358 NaN2 -0.422557 -1.322288 -3.285636 NaN3  1.234329  0.013114  0.437095 NaN4 -1.022010  0.836547  0.765879 NaN5 -0.068419  1.661682  0.012300 NaN6  1.192136  2.967244 -1.404399 NaN7       NaN       NaN       NaN NaN8       NaN       NaN       NaN NaN9       NaN       NaN       NaN NaN</code></pre><pre><code class="lang-python">print(&quot;排序1：按值排序 .sort_value&quot;)df1 = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df1)print(&quot;----------------------------------------------------&quot;)print(&quot;单列排序，ascending=True默认升序，反之降序&quot;)print(df1.sort_values([&#39;a&#39;],ascending=True))print(df1.sort_values([&#39;a&#39;],ascending=False))print(&quot;----------------------------------------------------&quot;)print(&quot;多列排序，ascending=True默认升序，反之降序&quot;)print(df1.sort_values([&#39;a&#39;,&#39;b&#39;],ascending=True))print(df1.sort_values([&#39;a&#39;,&#39;b&#39;],ascending=False))</code></pre><pre><code>排序1：按值排序 .sort_value           a          b          c          d0   7.178633  91.743711  74.429973  16.9725511  19.380969  92.812296  63.897946  99.2060192  72.370776  93.850345  15.692439  40.8384483  81.406605  72.521177  16.108888  46.376406----------------------------------------------------单列排序，ascending=True默认升序，反之降序           a          b          c          d0   7.178633  91.743711  74.429973  16.9725511  19.380969  92.812296  63.897946  99.2060192  72.370776  93.850345  15.692439  40.8384483  81.406605  72.521177  16.108888  46.376406           a          b          c          d3  81.406605  72.521177  16.108888  46.3764062  72.370776  93.850345  15.692439  40.8384481  19.380969  92.812296  63.897946  99.2060190   7.178633  91.743711  74.429973  16.972551----------------------------------------------------多列排序，ascending=True默认升序，反之降序           a          b          c          d0   7.178633  91.743711  74.429973  16.9725511  19.380969  92.812296  63.897946  99.2060192  72.370776  93.850345  15.692439  40.8384483  81.406605  72.521177  16.108888  46.376406           a          b          c          d3  81.406605  72.521177  16.108888  46.3764062  72.370776  93.850345  15.692439  40.8384481  19.380969  92.812296  63.897946  99.2060190   7.178633  91.743711  74.429973  16.972551</code></pre><pre><code class="lang-python">print(&quot;排序2：索引排序 .sort_values&quot;)df1 = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                  index = [5,4,3,2],                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])df2 = pd.DataFrame(np.random.rand(16).reshape(4,4)*100,                  index = [&#39;h&#39;,&#39;s&#39;,&#39;x&#39;,&#39;g&#39;],                   columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(df1)print(df2)print(&quot;------------------------------------------------&quot;)print(df1.sort_index(ascending=True))print(df1.sort_index(ascending=False))print(df2.sort_index(ascending=True))print(df2.sort_index(ascending=False))</code></pre><pre><code>排序2：索引排序 .sort_values           a          b          c          d5  32.302513   4.063405  92.012848  69.4046654  31.365644   6.941837  39.569200  95.1990203  60.919116  66.896067   3.784809  94.6538452  28.716530  86.753768  60.392612  41.607867           a          b          c          dh  18.838502   5.284545  65.303225  65.857055s  33.518432  82.303055  72.937504  13.445320x  38.611954  50.311829  93.052196   5.560826g  55.278087  45.968994  53.819673  24.982026------------------------------------------------           a          b          c          d2  28.716530  86.753768  60.392612  41.6078673  60.919116  66.896067   3.784809  94.6538454  31.365644   6.941837  39.569200  95.1990205  32.302513   4.063405  92.012848  69.404665           a          b          c          d5  32.302513   4.063405  92.012848  69.4046654  31.365644   6.941837  39.569200  95.1990203  60.919116  66.896067   3.784809  94.6538452  28.716530  86.753768  60.392612  41.607867           a          b          c          dg  55.278087  45.968994  53.819673  24.982026h  18.838502   5.284545  65.303225  65.857055s  33.518432  82.303055  72.937504  13.445320x  38.611954  50.311829  93.052196   5.560826           a          b          c          dx  38.611954  50.311829  93.052196   5.560826s  33.518432  82.303055  72.937504  13.445320h  18.838502   5.284545  65.303225  65.857055g  55.278087  45.968994  53.819673  24.982026</code></pre><pre><code class="lang-python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Pandas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习3:多分类器和神经网络</title>
    <link href="/2020/07/11/ML_Andrew_Pex3_Multi_class_Classification_and_Neural_Network%20/"/>
    <url>/2020/07/11/ML_Andrew_Pex3_Multi_class_Classification_and_Neural_Network%20/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习3-多类别逻辑回归和神经网络"><a href="#吴恩达机器学习程序练习3-多类别逻辑回归和神经网络" class="headerlink" title="吴恩达机器学习程序练习3:多类别逻辑回归和神经网络"></a>吴恩达机器学习程序练习3:多类别逻辑回归和神经网络</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex33507</p><h2 id="1-多分类"><a href="#1-多分类" class="headerlink" title="1. 多分类"></a>1. 多分类</h2><p>需要实现手写数字(0-9)的识别。需要扩展之前的逻辑回归，并且将其运用于一对多的分类</p><h3 id="1-1-数据集"><a href="#1-1-数据集" class="headerlink" title="1.1 数据集"></a>1.1 数据集</h3><p>这是一个Matlab格式的.m文件，其中包含5000个20*20像素的手写图像，以及对应的数字。(注：数字0对应的y值为10)。<br><br>用Python读取文件需要用到Scipy</p><pre><code class="lang-python">import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport matplotlibfrom scipy.io import loadmat# #这个包是评价报告from sklearn.metrics import classification_report</code></pre><pre><code class="lang-python">data = loadmat(&#39;./andrew_ml_ex33507/ex3data1.mat&#39;)data</code></pre><pre><code>{&#39;__header__&#39;: b&#39;MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Oct 16 13:09:09 2011&#39;, &#39;__version__&#39;: &#39;1.0&#39;, &#39;__globals__&#39;: [], &#39;X&#39;: array([[0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        ...,        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.]]), &#39;y&#39;: array([[10],        [10],        [10],        ...,        [ 9],        [ 9],        [ 9]], dtype=uint8)}</code></pre><pre><code class="lang-python">data[&#39;X&#39;].shape,data[&#39;y&#39;].shape</code></pre><pre><code>((5000, 400), (5000, 1))</code></pre><h3 id="1-2-数据可视化"><a href="#1-2-数据可视化" class="headerlink" title="1.2 数据可视化"></a>1.2 数据可视化</h3><p>随机展示100个数据</p><pre><code class="lang-python">sample_idx = np.random.choice(np.arange(data[&#39;X&#39;].shape[0]),100)sample_images = data[&#39;X&#39;][sample_idx,:]sample_images</code></pre><pre><code>array([[0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       ...,       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.],       [0., 0., 0., ..., 0., 0., 0.]])</code></pre><pre><code class="lang-python"># ax_array:子图对象--&gt;可以直接绘制子图# nrows,ncols：子图的行列数# sharey,sharex=True/all 所有子图共享y,x轴# figsize()：设置图像大小fig,ax_array=plt.subplots(nrows=10,ncols=10,sharey=True,sharex=True,figsize=(12,12))for r in range(10):    for c in range(10):        # matshow()将一个矩阵或者数组绘制成图像        ax_array[r,c].matshow(np.array(sample_images[10*r+c].reshape((20,20))).T,cmap=matplotlib.cm.binary)        # 将设置x,y轴的刻度不显示        plt.xticks(np.array([]))        plt.yticks(np.array([]))</code></pre><p><img src="/img/ML_Andrew/3_1.png" srcset="/img/loading.gif" alt="png"></p><h3 id="1-3-逻辑回归向量化"><a href="#1-3-逻辑回归向量化" class="headerlink" title="1.3 逻辑回归向量化"></a>1.3 逻辑回归向量化</h3><p>由于现在有10个数字类别，所以需要训练10个不同的逻辑回归分类器。为了使训练效率更高，可以将逻辑回归向量化，可以避免循环</p><h4 id="1-3-1-向量化代价函数"><a href="#1-3-1-向量化代价函数" class="headerlink" title="1.3.1 向量化代价函数"></a>1.3.1 向量化代价函数</h4><p><strong>Sigmoid函数</strong><br><br>g代表一个常用的逻辑函数(logistic function)，即为S形函数(Sigmoid function),公式为：</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}</script><p>合并起来，可以得到逻辑回归模型的假设函数：</p><script type="math/tex; mode=display">h_\theta(x)=\frac{1}{1+e^{-\theta^TX}}</script><pre><code class="lang-python">def sigmoid(z):    return 1/(1+np.exp(-z))</code></pre><p><strong>代价函数</strong>：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)})log(1-h_\theta(x^{(i)}))]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^{2}</script><p>注：$\theta_0$是不需要正则化，故下标从1开始</p><pre><code class="lang-python">def cost(theta,X,y,learningRate):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    first = np.multiply(-y,np.log(sigmoid(X*theta.T)))    second = np.multiply((1-y),np.log(1-sigmoid(X*theta.T)))    # 此为正则化项    reg = (learningRate/2*len(X))*np.sum(np.power(theta[:,1:theta.shape[1]],2))    return np.sum(first-second)/len(X) + reg</code></pre><h4 id="1-3-2-向量化梯度"><a href="#1-3-2-向量化梯度" class="headerlink" title="1.3.2 向量化梯度"></a>1.3.2 向量化梯度</h4><p>没有正则化时，逻辑回归的梯度是一个向量，其中第j个元素定义如下：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta_j}=\frac{1}{m}\sum_{i=1}^m[(h_\theta(x^{(i)})-y^{i})x_j^{(i)}]</script><p>想要正则化，则先将它的每一行写出来:</p><script type="math/tex; mode=display">\begin{bmatrix}\frac{\partial J}{\partial \theta_0}\\\frac{\partial J}{\partial \theta_1}\\\frac{\partial J}{\partial \theta_2}\\\vdots\\\frac{\partial J}{\partial \theta_n}\\\end{bmatrix}=\frac{1}{m}\begin{bmatrix}\sum_{i=1}^m[(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}]\\\sum_{i=1}^m[(h_\theta(x^{(i)})-y^{(i)})x_1^{(i)}]\\\sum_{i=1}^m[(h_\theta(x^{(i)})-y^{(i)})x_2^{(i)}]\\\vdots\\\sum_{i=1}^m[(h_\theta(x^{(i)})-y^{(i)})x_n^{(i)}]\\\end{bmatrix}</script><script type="math/tex; mode=display">=\frac{1}{m}\sum_{i=1}^m((h_\theta(x^{(i)})-y^{(i)})x^{(i)})</script><script type="math/tex; mode=display">=\frac{1}{m}X^T(h_\theta(x)-y)</script><p>其中：</p><script type="math/tex; mode=display">h_\theta(x)-y=\begin{bmatrix}h_\theta(x^{(1)})-y^{(1)}\\h_\theta(x^{(2)})-y^{(2)}\\\vdots\\h_\theta(x^{(m)})-y^{(m)}\\\end{bmatrix}</script><p><strong>注：</strong>$x^{(i)})$是一个向量，$(h_\theta(x^{(i)})-y^{(i)})$是一个数字</p><p>解释前面式子的最后一步：令$\beta<em>i=(h</em>\theta(x^{(i)})-y^{(i)})$,故可以得出：</p><script type="math/tex; mode=display">\sum_i\beta_ix^{(i)}=\begin{bmatrix}\big| & \big| &  & \big|\\x^{(1)} & x^{(2)} & \cdots & x^{(m)}\\\big| & \big| &  & \big|\\\end{bmatrix}\begin{bmatrix}\beta_1\\\beta_2\\\vdots\\\beta_m\\\end{bmatrix}=X^T\beta</script><p>$\sum_i\beta_ix^{(i)}$是n*1的向量，与一开始等式左边的$\frac{\partial J}{\partial \theta_n}$的n*1向量对应</p><p>$X^T$为n*m，$\beta$的列向量是m*1,所以两者相乘之后是n*1</p><h4 id="1-3-3-向量化正则化逻辑回归"><a href="#1-3-3-向量化正则化逻辑回归" class="headerlink" title="1.3.3 向量化正则化逻辑回归"></a>1.3.3 向量化正则化逻辑回归</h4><p>梯度更新公式：</p><script type="math/tex; mode=display">\theta_0 := \theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}</script><script type="math/tex; mode=display">\theta_j := \theta_j-\alpha(\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}+\frac{\lambda}{m}\theta_j)</script><p>向量化后的梯度更新公式：</p><script type="math/tex; mode=display">\theta_0 := \theta_0-\alpha\frac{1}{m}(h_\theta(x)-y)x_0</script><script type="math/tex; mode=display">\theta_j := \theta_j-\alpha(\frac{1}{m}X^T(h_\theta(x)-y)+\frac{\lambda}{m}\theta_j)</script><pre><code class="lang-python">def gradient(theta,X,y,learningRate):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    patameters = int(theta.ravel().shape[1])    error = sigmoid(X*theta.T)-y    grad = ((X.T*error)/len(X)).T+((learningRate/len(X))*theta)    grad[0,0] = np.sum(np.multiply(error,X[:,0]))/len(X)    # print(&quot;grad:\n&quot;,grad)    return np.array(grad).ravel()</code></pre><h3 id="1-4-一对多分类器"><a href="#1-4-一对多分类器" class="headerlink" title="1.4 一对多分类器"></a>1.4 一对多分类器</h3><p>现在已经定义好了代价函数(cost())和梯度函数(gradient())，是时候构建分类器了。<br><br>由于我们有10个类，并且逻辑回归只能一次在两个类别之间进行分类，所以需要多类分类策略，我们的任务是实现一对一全分类方法，其中具有k个不同类的标签就有k个分类器，每个分类器在’类别i’和‘不是i’之间决定。<br><br>把分类器训练包含在一个函数中，该函数计算10个分类器中每个分类器的最终权重，并且将权重返回为k*(n+1)数组，其中n是参数数量。</p><pre><code class="lang-python">from scipy.optimize import minimizedef one_vs_all(X,y,num_labels,learning_rate):    # 样本的数量    rows = X.shape[0]    # 参数的数量    params = X.shape[1]    # k个分类器的每个theta--&gt;k*(n+1)    all_theta = np.zeros((num_labels,params+1))    # 往X中插入一列全部为1的数据，方便向量化计算    X = np.insert(X,0,values=np.ones(rows),axis=1)    # 把y：0-9 ==&gt; 1-10     for i in range(1,num_labels+1):        theta = np.zeros(params+1)        # 将类别i和不是类别i的标签分别设为1和0        y_i = np.array([1 if label == i else 0 for label in y])        y_i = np.reshape(y_i,(rows,1))        # 最小化代价函数        fmin = minimize(fun=cost,x0=theta,args=(X,y_i,learning_rate),method=&#39;TNC&#39;,jac=gradient)        all_theta[i-1,:]=fmin.x    return all_theta</code></pre><p><strong>注(上述代码)：</strong></p><blockquote><ul><li>为theta添加了一个额外的参数(与训练数据一列对应)，以计算截距项(常数项)</li><li>将y从类标签(1-10)转换为每个分类器的二进制(要不是类i，要么不是类i)</li><li>使用Scipy的较新优化API来最小化每个分类器的代价函数<br>如果指定的话，API将采用目标函数，初始参数集、优化方法和jacobian(渐变)函数。</li><li>然后将优化程序找到的参数分配给参数数组</li></ul></blockquote><p>实现向量化代码的一个更具有挑战性的部分是正确地写入所有矩阵，保证维度正确。</p><pre><code class="lang-python">rows = data[&#39;X&#39;].shape[0]params = data[&#39;X&#39;].shape[1]all_theta = np.zeros((10,params+1))X = np.insert(data[&#39;X&#39;],0,values=np.ones(rows),axis=1)theta = np.zeros(params + 1)y_0 = np.array([1 if label == 0 else 0 for label in data[&#39;y&#39;]])y_0 = np.reshape(y_0, (rows, 1))X.shape,y_0.shape,theta.shape,all_theta.shape</code></pre><pre><code>((5000, 401), (5000, 1), (401,), (10, 401))</code></pre><p><strong>注：</strong>theta是一维数组，因此当它被转换为计算梯度的代码中的矩阵时，需要变成(1x401)的矩阵。还需要检查y中的类标签，以确保它们看起来与我们想象的一致</p><pre><code class="lang-python"># 看一下有几类标签np.unique(data[&#39;y&#39;])</code></pre><pre><code>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10], dtype=uint8)</code></pre><p>确保训练函数正确运行，并且得到合理的输出</p><pre><code class="lang-python">all_theta = one_vs_all(data[&#39;X&#39;],data[&#39;y&#39;],10,1)all_theta</code></pre><pre><code>array([[-3.70247931e-05,  0.00000000e+00,  0.00000000e+00, ...,        -2.24803602e-10,  2.31962907e-11,  0.00000000e+00],       [-8.96250716e-05,  0.00000000e+00,  0.00000000e+00, ...,         7.26120810e-09, -6.19965284e-10,  0.00000000e+00],       [-8.39553386e-05,  0.00000000e+00,  0.00000000e+00, ...,        -7.61695632e-10,  4.64917655e-11,  0.00000000e+00],       ...,       [-7.00832437e-05,  0.00000000e+00,  0.00000000e+00, ...,        -6.92009026e-10,  4.29241493e-11,  0.00000000e+00],       [-7.65187937e-05,  0.00000000e+00,  0.00000000e+00, ...,        -8.09503268e-10,  5.31058718e-11,  0.00000000e+00],       [-6.63412786e-05,  0.00000000e+00,  0.00000000e+00, ...,        -3.49766206e-09,  1.13668648e-10,  0.00000000e+00]])</code></pre><h4 id="1-4-1-一对多预测"><a href="#1-4-1-一对多预测" class="headerlink" title="1.4.1 一对多预测"></a>1.4.1 一对多预测</h4><p>最后一步：使用训练完毕的分类器预测每个图像的标签<br><br>即：对于每个训练样本，将计算每个类的类概率，并且输出具有最高概率类标签的类</p><pre><code class="lang-python">def predict_all(X,all_theta):    rows = X.shape[0]    params = X.shape[1]    num_labels = all_theta.shape[0]    X = np.insert(X,0,values=np.ones(rows),axis=1)    X = np.matrix(X)    all_theta = np.matrix(all_theta)    h = sigmoid(X*all_theta.T)    # 寻找h(5000*10)中每行概率最大的类    # axis =1 对列进行最大值选取，此时对每一行进行操作    print(&quot;h.shape:&quot;,h.shape)    h_argmax = np.argmax(h,axis=1)    h_argmax = h_argmax + 1    return h_argmax</code></pre><p>现在可以使用predict_all函数为每个实例生成类预测，看看分类器是如何工作的</p><pre><code class="lang-python">y_pred = predict_all(data[&#39;X&#39;],all_theta)print(classification_report(data[&#39;y&#39;],y_pred))</code></pre><pre><code>h.shape: (5000, 10)              precision    recall  f1-score   support           1       0.80      0.96      0.87       500           2       0.92      0.65      0.76       500           3       0.78      0.70      0.74       500           4       0.86      0.76      0.81       500           5       1.00      0.17      0.30       500           6       0.63      0.94      0.75       500           7       0.85      0.87      0.86       500           8       0.55      0.90      0.68       500           9       0.90      0.55      0.68       500          10       0.69      0.96      0.80       500    accuracy                           0.75      5000   macro avg       0.80      0.75      0.73      5000weighted avg       0.80      0.75      0.73      5000</code></pre><h2 id="2-神经网络"><a href="#2-神经网络" class="headerlink" title="2. 神经网络"></a>2. 神经网络</h2><p>在此前，我们已经实现了一个多分类逻辑回归来识别手写数字，但是逻辑回归并不能承载更复杂的假设，因为它只是个线性分类器。<br><br>故在此，我们需要实现一个可以识别手写数字的神经网络。神经网络可以表示一些非线性复杂的模型。权重已经预先训练好，目标就是在现有权重的基础上，实现前馈神经网络。</p><h3 id="2-1-模型表达"><a href="#2-1-模型表达" class="headerlink" title="2.1 模型表达"></a>2.1 模型表达</h3><p>如下图：<br><img src="/img/ML_Andrew/3_2.png" srcset="/img/loading.gif" alt=""></p><p>输入的是图片的像素值，20*20像素的图片有400个输入层单元，不包括需要额外添加的常数项。材料已经提供了训练好的神经网络的参数$\Theta^{(1)},\Theta^{(2)}$,有25个隐藏层单元和10个输出层单元。</p><h3 id="2-2-前馈神经网络和预测"><a href="#2-2-前馈神经网络和预测" class="headerlink" title="2.2 前馈神经网络和预测"></a>2.2 前馈神经网络和预测</h3><p>实现前馈神经网络预测手写数字的功能，与之前的一对多分类一样，神经网络的预测会将$(h_\theta(x))_k$中的最大值作为预测输出</p><pre><code class="lang-python">weight = loadmat(&quot;./andrew_ml_ex33507/ex3weights.mat&quot;)# print(weight)theta1,theta2=weight[&#39;Theta1&#39;],weight[&#39;Theta2&#39;]theta1.shape,theta2.shape</code></pre><pre><code>((25, 401), (10, 26))</code></pre><pre><code class="lang-python"># 插入常数项# np.insert():axis=0是按行插入 ==&gt; 对比与 np.argmax()中给的axis=1也是提取列，所以是对每一行操作# axis = 1 是按列插入x2 = np.matrix(np.insert(data[&#39;X&#39;],0,values=np.ones(X.shape[0]),axis=1))# print(x2)y2 = np.matrix(data[&#39;y&#39;])x2.shape,y2.shape</code></pre><pre><code>((5000, 401), (5000, 1))</code></pre><pre><code class="lang-python">a1 = x2z2 = a1*theta1.Tz2.shape</code></pre><pre><code>(5000, 25)</code></pre><pre><code class="lang-python">a2 = sigmoid(z2)a2.shape</code></pre><pre><code>(5000, 25)</code></pre><pre><code class="lang-python">a2 = np.insert(a2,0,values=np.ones(a2.shape[0]),axis=1)z3 = a2*theta2.Tz3.shape</code></pre><pre><code>(5000, 10)</code></pre><pre><code class="lang-python">a3 = sigmoid(z3)a3</code></pre><pre><code>matrix([[1.12661530e-04, 1.74127856e-03, 2.52696959e-03, ...,         4.01468105e-04, 6.48072305e-03, 9.95734012e-01],        [4.79026796e-04, 2.41495958e-03, 3.44755685e-03, ...,         2.39107046e-03, 1.97025086e-03, 9.95696931e-01],        [8.85702310e-05, 3.24266731e-03, 2.55419797e-02, ...,         6.22892325e-02, 5.49803551e-03, 9.28008397e-01],        ...,        [5.17641791e-02, 3.81715020e-03, 2.96297510e-02, ...,         2.15667361e-03, 6.49826950e-01, 2.42384687e-05],        [8.30631310e-04, 6.22003774e-04, 3.14518512e-04, ...,         1.19366192e-02, 9.71410499e-01, 2.06173648e-04],        [4.81465717e-05, 4.58821829e-04, 2.15146201e-05, ...,         5.73434571e-03, 6.96288990e-01, 8.18576980e-02]])</code></pre><pre><code class="lang-python"># 进行预测y_pred2 = np.argmax(a3,axis=1)+1y_pred2.shape</code></pre><pre><code>(5000, 1)</code></pre><pre><code class="lang-python">print(classification_report(y2,y_pred))</code></pre><pre><code>              precision    recall  f1-score   support           1       0.80      0.96      0.87       500           2       0.92      0.65      0.76       500           3       0.78      0.70      0.74       500           4       0.86      0.76      0.81       500           5       1.00      0.17      0.30       500           6       0.63      0.94      0.75       500           7       0.85      0.87      0.86       500           8       0.55      0.90      0.68       500           9       0.90      0.55      0.68       500          10       0.69      0.96      0.80       500    accuracy                           0.75      5000   macro avg       0.80      0.75      0.73      5000weighted avg       0.80      0.75      0.73      5000</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Numpy-Advanced</title>
    <link href="/2020/07/11/Code_One_Hour2/"/>
    <url>/2020/07/11/Code_One_Hour2/</url>
    
    <content type="html"><![CDATA[<h1 id="Numpy使用-进阶篇"><a href="#Numpy使用-进阶篇" class="headerlink" title="Numpy使用-进阶篇"></a>Numpy使用-进阶篇</h1><h2 id="1-广播法则-rule"><a href="#1-广播法则-rule" class="headerlink" title="1. 广播法则(rule)"></a>1. 广播法则(rule)</h2><p>广播法则可以使通用函数有意义的处理不具有相同形状的输入</p><blockquote><ul><li>广播第一法则：如果所有的输入数组的维度数量不同，则小维度数量的数组的形状将会在最左边补1（添加一维），直至所有的数组具有相同的维度数量。</li><li>广播第二法则：如果输入的数组的维度在任何一维都不匹配，则数组的形状会沿着维度为1的维度扩展以匹配另一个数组的形状</li><li>广播第三法则：如果输入的数组的形状在任何维度上都不匹配并且没有任何一个维度为1，则会引发异常</li></ul></blockquote><h3 id="1-1-维度的数量、大小"><a href="#1-1-维度的数量、大小" class="headerlink" title="1.1 维度的数量、大小"></a>1.1 维度的数量、大小</h3><p><strong>维度的数量</strong>：numpy中指定维度都是使用元组表示。如：np.zeros((2,3,2))的维度数量是三维的，np.zeros(3,)的维度数量是1维的,区别(3)与(3,)后者才是元组<br><br><strong>维度的大小</strong>：如：np.zeros((2,3,4))维度数量是三维，第一维的维度大小是2，第二维的维度大小是3，第三维的维度大小是4</p><h3 id="1-2-广播-Broadcasting"><a href="#1-2-广播-Broadcasting" class="headerlink" title="1.2 广播(Broadcasting)"></a>1.2 广播(Broadcasting)</h3><p>通常只在对多个数组进行对应元素进行操作时，并且<strong>数组形状(维度数量)(不同维度)</strong>不同时，才会发生广播</p><pre><code class="lang-python">import numpy as npa = np.array([1,2,3])b = 2# a是一维向量，b是标量，即：形状不同# a*b == [1,2,3]*[2,2,2]a*b</code></pre><pre><code>array([2, 4, 6])</code></pre><pre><code class="lang-python">A = np.zeros((2,5,3,4))B = np.zeros((3,4))# 运用了广播第一、第二法则# 从后往前有相同维度的大小可以运用广播法则print(&quot;从后往前有相同维度的大小可以运用广播法则&quot;)print((A+B).shape)C = np.zeros((3,3))print(&quot;从后往前没有相同维度的大小，则不可以运用广播法则&quot;)print((A+C).shape)</code></pre><pre><code>从后往前有相同维度的大小可以运用广播法则(2, 5, 3, 4)从后往前没有相同维度的大小，则不可以运用广播法则---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-2-668acc6dcffb&gt; in &lt;module&gt;      7 C = np.zeros((3,3))      8 print(&quot;从后往前没有相同维度的大小，则不可以运用广播法则&quot;)----&gt; 9 print((A+C).shape)ValueError: operands could not be broadcast together with shapes (2,5,3,4) (3,3) </code></pre><pre><code class="lang-python">print(&quot;从后往前有一些相同维度的大小，并且不同的维度大小为1，则可以运用广播法则&quot;)D = np.zeros((1,3,1))print((A+D).shape)print(&quot;从后往前有一些相同维度的大小，并且不同的维度大小有一个不为1，则不可以运用广播法则&quot;)F = np.zeros((6,1,3,1))print((A+F).shape)</code></pre><pre><code>从后往前有一些相同维度的大小，并且不同的维度大小为1，则可以运用广播法则(2, 5, 3, 4)从后往前有一些相同维度的大小，并且不同的维度大小有一个不为1，则不可以运用广播法则---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-3-d5cc52d6194a&gt; in &lt;module&gt;      4 print(&quot;从后往前有一些相同维度的大小，并且不同的维度大小有一个不为1，则不可以运用广播法则&quot;)      5 F = np.zeros((6,1,3,1))----&gt; 6 print((A+F).shape)ValueError: operands could not be broadcast together with shapes (2,5,3,4) (6,1,3,1) </code></pre><h2 id="2-花式索引和索引技巧"><a href="#2-花式索引和索引技巧" class="headerlink" title="2. 花式索引和索引技巧"></a>2. 花式索引和索引技巧</h2><h3 id="2-1-通过数组索引"><a href="#2-1-通过数组索引" class="headerlink" title="2.1 通过数组索引"></a>2.1 通过数组索引</h3><p>数组、多维数组都可以当做索引进行索引</p><pre><code class="lang-python">a = np.arange(12)**2print(a)i = np.array([1,1,3,8,5])print(i)print(a[i])</code></pre><pre><code>[  0   1   4   9  16  25  36  49  64  81 100 121][1 1 3 8 5][ 1  1  9 64 25]</code></pre><pre><code class="lang-python">j = np.array([[3,4],[9,7]])print(a[j])</code></pre><pre><code>[[ 9 16] [81 49]]</code></pre><p>当被索引数组a是多维时，每一个唯一的索引数列指向a的第一维,如：</p><pre><code class="lang-python">palette = np.array([[0,0,0],[255,0,0],[0,255,0],[0,0,255],[255,255,255]])print(palette)image = np.array([[0,1,2,0],[0,3,4,0]])print(image)print(palette[image])</code></pre><pre><code>[[  0   0   0] [255   0   0] [  0 255   0] [  0   0 255] [255 255 255]][[0 1 2 0] [0 3 4 0]][[[  0   0   0]  [255   0   0]  [  0 255   0]  [  0   0   0]] [[  0   0   0]  [  0   0 255]  [255 255 255]  [  0   0   0]]]</code></pre><p>也可以不止给出一维的索引，但是每一维的索引数组必须有相同的形状</p><pre><code class="lang-python">a = np.arange(12).reshape(3,4)print(a)i = np.array([[0,1],[1,2]])print(i)j = np.array([[2,1],[2,2]])print(j)print(a[i,j])print(a[i,2])print(a[:,j])</code></pre><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]][[0 1] [1 2]][[2 1] [2 2]][[ 2  5] [ 6 10]][[ 2  6] [ 6 10]][[[ 2  1]  [ 2  2]] [[ 6  5]  [ 6  6]] [[10  9]  [10 10]]]</code></pre><p>同理，可以将i,j放入序列中，然后通过list索引(现在应该已经弃用)</p><pre><code class="lang-python">l = [i,j]print(l)print(a[l])</code></pre><pre><code>[array([[0, 1],       [1, 2]]), array([[2, 1],       [2, 2]])][[ 2  5] [ 6 10]]d:\dl\minconda3\envs\ml_dl_andrewng\lib\site-packages\ipykernel_launcher.py:3: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result.  This is separate from the ipykernel package so we can avoid doing imports until</code></pre><p>但是，不可以将i,j放入np.array数组中，因为将会被解释成索引a的第一维</p><pre><code class="lang-python">s = np.array([i,j])print(s)print(a[s])print(a[tuple(s)])</code></pre><pre><code>[[[0 1]  [1 2]] [[2 1]  [2 2]]][[[[ 0  1  2  3]   [ 4  5  6  7]]  [[ 4  5  6  7]   [ 8  9 10 11]]] [[[ 8  9 10 11]   [ 4  5  6  7]]  [[ 8  9 10 11]   [ 8  9 10 11]]]][[ 2  5] [ 6 10]]</code></pre><p>也可以用来搜索时间序列最大值</p><pre><code class="lang-python">time = np.linspace(20,145,5)data = np.sin(np.arange(20)).reshape(5,4)print(&quot;time:\n{}&quot;.format(time))print(&quot;data:\n{}&quot;.format(data))ind = data.argmax(axis=0)print(&quot;ind:\n{}&quot;.format(ind))time_max = time[ind]data_max = data[ind,range(data.shape[1])]print(&quot;time_max:\n{}&quot;.format(time_max))print(&quot;data_max:\n{}&quot;.format(data_max))all(data_max == data.max(axis=0))</code></pre><pre><code>time:[ 20.    51.25  82.5  113.75 145.  ]data:[[ 0.          0.84147098  0.90929743  0.14112001] [-0.7568025  -0.95892427 -0.2794155   0.6569866 ] [ 0.98935825  0.41211849 -0.54402111 -0.99999021] [-0.53657292  0.42016704  0.99060736  0.65028784] [-0.28790332 -0.96139749 -0.75098725  0.14987721]]ind:[2 0 3 1]time_max:[ 82.5   20.   113.75  51.25]data_max:[0.98935825 0.84147098 0.99060736 0.6569866 ]True</code></pre><p>也可以使用数组索引作为目标进行赋值</p><pre><code class="lang-python">a = np.arange(5)print(&quot;a:\n{}&quot;.format(a))a[[1,3,4]]=0print(&quot;a:\n{}&quot;.format(a))a[[0,0,2]]=[1,2,3]print(&quot;a:\n{}&quot;.format(a))a[[0,0,2]]+=1print(&quot;a:\n{}&quot;.format(a))</code></pre><pre><code>a:[0 1 2 3 4]a:[0 0 2 0 0]a:[2 0 3 0 0]a:[3 0 4 0 0]</code></pre><p><strong>注</strong>：Python的+=结构，即使0在索引列表中出现两次，索引为0的元素也仅仅增加一次，这是因为Python中要求 a+=1 和 a=a+1等同</p><h3 id="2-2-通过布尔数组索引"><a href="#2-2-通过布尔数组索引" class="headerlink" title="2.2 通过布尔数组索引"></a>2.2 通过布尔数组索引</h3><p>当我们使用整数数组索引数组时，我们是提供一个索引列表进行索引。<br><br>通过布尔数组索引可以显式的选择想要和不想要的元素</p><pre><code class="lang-python">a = np.arange(12).reshape(3,4)b = a&gt;4print(&quot;b:\n{}&quot;.format(b))print(&quot;a[b]:\n{}&quot;.format(a[b]))</code></pre><pre><code>b:[[False False False False] [False  True  True  True] [ True  True  True  True]]a[b]:[ 5  6  7  8  9 10 11]</code></pre><p>通过布尔数组索引在赋值时非常有用</p><pre><code class="lang-python">a[b]=0print(&quot;a:\n{}&quot;.format(a))</code></pre><pre><code>a:[[0 1 2 3] [4 0 0 0] [0 0 0 0]]</code></pre><p>与整数索引类似，也可以对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p><pre><code class="lang-python">a = np.arange(12).reshape(3,4)b1 = np.array([False,True,True])b2 = np.array([True,False,True,False])print(&quot;a[b1,:]:\n{}&quot;.format(a[b1,:]))print(&quot;a[b1]:\n{}&quot;.format(a[b1]))print(&quot;a[:,b2]:\n{}&quot;.format(a[:,b2]))print(&quot;a[b1,b2]:\n{}&quot;.format(a[b1,b2]))</code></pre><pre><code>a[b1,:]:[[ 4  5  6  7] [ 8  9 10 11]]a[b1]:[[ 4  5  6  7] [ 8  9 10 11]]a[:,b2]:[[ 0  2] [ 4  6] [ 8 10]]a[b1,b2]:[ 4 10]</code></pre><p><strong>注:</strong> 一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，b1是一个秩为1长度为三的数组(a的行数)，b2(长度为4)与a的第二秩(列)相一致。</p><h3 id="2-3-np-ix-函数"><a href="#2-3-np-ix-函数" class="headerlink" title="2.3 np.ix_()函数"></a>2.3 np.ix_()函数</h3><p><strong>待判断</strong><br>将输入的数组，产生笛卡尔积的映射关系，根据关系寻找对应位置的元素(也就是产生一个索引)<br><br>另一种解释：为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算a+b*c,</p><pre><code class="lang-python">a = np.array([2,3,4,5])b = np.array([8,5,4])c = np.array([5,4,6,8,3])ax,bx,cx = np.ix_(a,b,c)print(&quot;ax:\n{}&quot;.format(ax))print(&quot;bx:\n{}&quot;.format(bx))print(&quot;cx:\n{}&quot;.format(cx))print(&quot;shape:\n{}{}{}&quot;.format(ax.shape,bx.shape,cx.shape))</code></pre><pre><code>ax:[[[2]] [[3]] [[4]] [[5]]]bx:[[[8]  [5]  [4]]]cx:[[[5 4 6 8 3]]]shape:(4, 1, 1)(1, 3, 1)(1, 1, 5)</code></pre><pre><code class="lang-python">result = ax + bx*cxprint(&quot;result:\n{}&quot;.format(result))result[3,2,4] == a[3]+b[2]*c[4]</code></pre><pre><code>result:[[[42 34 50 66 26]  [27 22 32 42 17]  [22 18 26 34 14]] [[43 35 51 67 27]  [28 23 33 43 18]  [23 19 27 35 15]] [[44 36 52 68 28]  [29 24 34 44 19]  [24 20 28 36 16]] [[45 37 53 69 29]  [30 25 35 45 20]  [25 21 29 37 17]]]True</code></pre><pre><code class="lang-python"># 另一种计算方式def ufunc_reduce(ufct,*vectors):    vs = np.ix_(*vectors)    r = ufct.identity    for v in vs:        r = ufct(r,v)    return rufunc_reduce(np.add,a,b,c)</code></pre><pre><code>array([[[15, 14, 16, 18, 13],        [12, 11, 13, 15, 10],        [11, 10, 12, 14,  9]],       [[16, 15, 17, 19, 14],        [13, 12, 14, 16, 11],        [12, 11, 13, 15, 10]],       [[17, 16, 18, 20, 15],        [14, 13, 15, 17, 12],        [13, 12, 14, 16, 11]],       [[18, 17, 19, 21, 16],        [15, 14, 16, 18, 13],        [14, 13, 15, 17, 12]]])</code></pre><h3 id="2-4-用字符串索引"><a href="#2-4-用字符串索引" class="headerlink" title="2.4 用字符串索引"></a>2.4 用字符串索引</h3><p>详情可以参考<a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.rec.html" target="_blank" rel="noopener">RecordArray</a></p><h2 id="3-线性代数"><a href="#3-线性代数" class="headerlink" title="3. 线性代数"></a>3. 线性代数</h2><h3 id="3-1-简单的矩阵-ndarray数组-运算"><a href="#3-1-简单的矩阵-ndarray数组-运算" class="headerlink" title="3.1 简单的矩阵(ndarray数组)运算"></a>3.1 简单的矩阵(ndarray数组)运算</h3><p>矩阵的转置(transpose())、逆(inv())、伪逆(pinv())、迹(trace())、矩阵方程的解(solve())、特征值和特征向量(eig())。</p><pre><code class="lang-python">import numpy as npa = np.array([[1.0,2.0],[3.0,4.0]])print(&quot;a:\n{}&quot;.format(a))print(&quot;a的转置:\n{}&quot;.format(a.transpose()))ainv=np.linalg.inv(a)print(&quot;a的逆:\n{}&quot;.format(ainv))# np.dot()矩阵的乘法(区别于矩阵元素的乘法！)print(&quot;a*a^-1:\n{}&quot;.format(np.dot(a,ainv)))# &quot;eye&quot; represents &quot;I&quot; or math &quot;E&quot;u = np.eye(2)print(&quot;u:\n{}&quot;.format(u))print(&quot;u的迹:\n{}&quot;.format(np.trace(u)))# 求解ax=y的线性矩阵方程y = np.array([[5.],[7.]])print(&quot;ax=y的解x为:\n{}&quot;.format(np.linalg.solve(a,y)))j = np.array([[0.0,-1.0],[1.0,0.0]])# Parameters:#     square matrix# Returns#     The eigenvalues, each repeated according to its multiplicity.#     The normalized (unit &quot;length&quot;) eigenvectors, such that the#     column ``v[:,i]`` is the eigenvector corresponding to the#     eigenvalue ``w[i]`` print(&quot;矩阵j的特征值和特征向量:\n{}&quot;.format(np.linalg.eig(j)))</code></pre><pre><code>a:[[1. 2.] [3. 4.]]a的转置:[[1. 3.] [2. 4.]]a的逆:[[-2.   1. ] [ 1.5 -0.5]]a*a^-1:[[1.0000000e+00 0.0000000e+00] [8.8817842e-16 1.0000000e+00]]u:[[1. 0.] [0. 1.]]u的迹:2.0ax=y的解x为:[[-3.] [ 4.]]矩阵j的特征值和特征向量:(array([0.+1.j, 0.-1.j]), array([[0.70710678+0.j        , 0.70710678-0.j        ],       [0.        -0.70710678j, 0.        +0.70710678j]]))</code></pre><h3 id="3-2-矩阵类"><a href="#3-2-矩阵类" class="headerlink" title="3.2 矩阵类"></a>3.2 矩阵类</h3><p>关于矩阵类的简短介绍<br><br>矩阵类的：创建、类型、转置(A.T)、乘法(A*B)、逆(A.I)、矩阵方程的解</p><pre><code class="lang-python">A = np.matrix(&#39;1.0 2.0; 3.0 4.0&#39;)print(&quot;矩阵A:\n{}&quot;.format(A))print(&quot;A的类型为;\n{}&quot;.format(type(A)))print(&quot;A的转置:\n{}&quot;.format(A.T))X = np.matrix(&#39;5.0 7.0&#39;)Y = X.Tprint(&quot;矩阵Y:\n{}&quot;.format(Y))print(&quot;矩阵类型的乘法(矩阵的乘法):A*Y=:\n{}&quot;.format(A*Y))Ainv=A.Iprint(&quot;A的逆:\n{}&quot;.format(Ainv))print(&quot;验证:A*Ainv==I:\n{}&quot;.format(A*Ainv))print(&quot;矩阵方程AX=Y的解X=\n{}&quot;.format(np.linalg.solve(A,Y)))</code></pre><pre><code>矩阵A:[[1. 2.] [3. 4.]]A的类型为;&lt;class &#39;numpy.matrix&#39;&gt;A的转置:[[1. 3.] [2. 4.]]矩阵Y:[[5.] [7.]]矩阵类型的乘法(矩阵的乘法):A*Y=:[[19.] [43.]]A的逆:[[-2.   1. ] [ 1.5 -0.5]]验证:A*Ainv==I:[[1.0000000e+00 0.0000000e+00] [8.8817842e-16 1.0000000e+00]]矩阵方程AX=Y的解X=[[-3.] [ 4.]]</code></pre><h3 id="3-3-索引：比较矩阵和二维数组"><a href="#3-3-索引：比较矩阵和二维数组" class="headerlink" title="3.3 索引：比较矩阵和二维数组"></a>3.3 索引：比较矩阵和二维数组</h3><p><strong>注：</strong>Numpy中数组和矩阵有些重要的区别<br><br>Numpy提供了两个基本的对象：N维数组对象和通用函数对象。其他的对象都是构建在它们的基础之上。<br><br>矩阵就是继承自Numpy的二维数组对象。所以对于数组和矩阵，索引都必须包含函数的组合：整数标量、省略号(ellipses)、整数列表、整数或布尔值构成的元组或数组。<br><br>矩阵可以被用作矩阵的索引，但是通常需要数组、列表或者其他形式来完成<br><br>并且索引都是从0开始，传统上沿着0轴的方向被称为行，1轴方向被称为列。</p><pre><code class="lang-python">A = np.arange(12)print(&quot;A:\n{}&quot;.format(A))A.shape = (3,4)print(&quot;A:\n{}&quot;.format(A))# np.mat()可以从字符串或者列表中生成矩阵M = np.mat(A.copy())print(type(A),&quot; &quot;,type(M))</code></pre><pre><code>A:[ 0  1  2  3  4  5  6  7  8  9 10 11]A:[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]&lt;class &#39;numpy.ndarray&#39;&gt;   &lt;class &#39;numpy.matrix&#39;&gt;</code></pre><h4 id="3-3-1-切片"><a href="#3-3-1-切片" class="headerlink" title="3.3.1 切片"></a>3.3.1 切片</h4><p>基本的切片使用切片对象或整数，如：A[:]和M[:]。<br><br><strong>注：</strong>Numpy切片数组不会创建数据副本，而是提供统一的数据的视图</p><pre><code class="lang-python">print(&quot;A[:]:\n&quot;,A[:])print(&quot;A[:].shape:&quot;,A[:].shape)print(&quot;M[:]:\n&quot;,M[:])print(&quot;M[:].shape:&quot;,M[:].shape)</code></pre><pre><code>A[:]: [[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]A[:].shape: (3, 4)M[:]: [[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]M[:].shape: (3, 4)</code></pre><p>现在有些不同啦！可以使用逗号分割索引来沿着多个轴索引</p><pre><code class="lang-python">print(&quot;A[:,1]:\n&quot;,A[:,1])print(&quot;A[:,1].shape:&quot;,A[:,1].shape)print(&quot;M[:,1]:\n&quot;,M[:,1])print(&quot;M[:,1].shape:&quot;,M[:,1].shape)</code></pre><pre><code>A[:,1]: [1 5 9]A[:,1].shape: (3,)M[:,1]: [[1] [5] [9]]M[:,1].shape: (3, 1)</code></pre><p><strong>注：</strong>对二维数组使用一个冒号产生一个一维数组，然而矩阵产生了一个二维矩阵</p><p>获取一个数组的第一列和第三列</p><pre><code class="lang-python">print(&quot;方法一：使用列表切片&quot;)print(&quot;A[:,[1,3]]:\n&quot;,A[:,[1,3]])print(&quot;方法二：使用take()&quot;)print(&quot;A[:,].take([1,3],axis=1):\n&quot;,A[:,].take([1,3],axis=1))print(&quot;如果想跳过第0行&quot;)print(&quot;A[1:,[1,3]]:\n&quot;,A[1:,[1,3]])print(&quot;A[1:,].take([1,3],axis=1):\n&quot;,A[1:,].take([1,3],axis=1))print(&quot;方法三：通过矩阵向量积(叉积)&quot;)print(&quot;A[np.ix_((1,2),(1,3))]:\n&quot;,A[np.ix_((1,2),(1,3))])</code></pre><pre><code>方法一：使用列表切片A[:,[1,3]]: [[ 1  3] [ 5  7] [ 9 11]]方法二：使用take()A[:,].take([1,3],axis=1): [[ 1  3] [ 5  7] [ 9 11]]如果想跳过第0行A[1:,[1,3]]: [[ 5  7] [ 9 11]]A[1:,].take([1,3],axis=1): [[ 5  7] [ 9 11]]方法三：通过矩阵向量积(叉积)A[np.ix_((1,2),(1,3))]: [[ 5  7] [ 9 11]]</code></pre><p>做一些更复杂的，如：保留第一行大于1的列</p><pre><code class="lang-python">print(&quot;方法一：创建布尔索引&quot;)B = A[0,:]&gt;1print(&#39;A[0,:]&gt;1:\n&#39;,A[0,:]&gt;1)print(&quot;A[:,A[0,:]&gt;1]:\n&quot;,A[:,A[0,:]&gt;1])print(&quot;但是索引矩阵没这么方便&quot;)print(&quot;M[0,:]&gt;1:&quot;,M[0,:]&gt;1)M[0,:]&gt;1</code></pre><pre><code>方法一：创建布尔索引A[0,:]&gt;1: [False False  True  True]A[:,A[0,:]&gt;1]: [[ 2  3] [ 6  7] [10 11]]但是索引矩阵没这么方便M[0,:]&gt;1: [[False False  True  True]]matrix([[False, False,  True,  True]])</code></pre><pre><code class="lang-python">M[:,M[0,:]&gt;1]</code></pre><pre><code>---------------------------------------------------------------------------IndexError                                Traceback (most recent call last)&lt;ipython-input-25-4d44b986840f&gt; in &lt;module&gt;----&gt; 1 M[:,M[0,:]&gt;1]d:\dl\minconda3\envs\ml_dl_andrewng\lib\site-packages\numpy\matrixlib\defmatrix.py in __getitem__(self, index)    191     192         try:--&gt; 193             out = N.ndarray.__getitem__(self, index)    194         finally:    195             self._getitem = FalseIndexError: too many indices for array: array is 2-dimensional, but 3 were indexed</code></pre><p>所以不能使用矩阵切片来切片产生一个矩阵。<br><br>换一种方法：矩阵有个A属性：其值是数组呈现的</p><pre><code class="lang-python">M[:,M.A[0,:]&gt;1]</code></pre><pre><code>matrix([[ 2,  3],        [ 6,  7],        [10, 11]])</code></pre><p>对矩阵两个方向有条件的切片</p><pre><code class="lang-python">A[A[:,0]&gt;2,A[0,:]&gt;1]</code></pre><pre><code>array([ 6, 11])</code></pre><pre><code class="lang-python">M[M.A[:,0]&gt;2,M.A[0,:]&gt;1]</code></pre><pre><code>matrix([[ 6, 11]])</code></pre><p>使用向量积ix_()；即对输入的数组进行笛卡尔积，然后可以作为索引。</p><pre><code class="lang-python">print(&quot;A:\n&quot;,A)print(&quot;np.ix_(A[:,0]&gt;2,A[0,:]&gt;1):\n&quot;,np.ix_(A[:,0]&gt;2,A[0,:]&gt;1))print(&quot;A[np.ix_(A[:,0]&gt;2,A[0,:]&gt;1)]:\n&quot;,A[np.ix_(A[:,0]&gt;2,A[0,:]&gt;1)])print(&quot;M[np.ix_(M.A[:,0]&gt;2,M.A[0,:]&gt;1):\n]&quot;,M[np.ix_(M.A[:,0]&gt;2,M.A[0,:]&gt;1)])</code></pre><pre><code>A: [[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]np.ix_(A[:,0]&gt;2,A[0,:]&gt;1): (array([[1],       [2]], dtype=int64), array([[2, 3]], dtype=int64))A[np.ix_(A[:,0]&gt;2,A[0,:]&gt;1)]: [[ 6  7] [10 11]]M[np.ix_(M.A[:,0]&gt;2,M.A[0,:]&gt;1):] [[ 6  7] [10 11]]</code></pre><h2 id="4-技巧和提示"><a href="#4-技巧和提示" class="headerlink" title="4. 技巧和提示"></a>4. 技巧和提示</h2><p>以下给出一些简短和有用的提示</p><h3 id="4-1-“自动”改变形状"><a href="#4-1-“自动”改变形状" class="headerlink" title="4.1 “自动”改变形状"></a>4.1 “自动”改变形状</h3><p>更改数组的维度，可以省略一个尺寸，系统会自动推导出来。</p><pre><code class="lang-python">a = np.arange(30)# 只要是负数，即可表示省略该尺寸，需要系统自动推导a.shape = 2,-100,3a.shape</code></pre><pre><code>(2, 5, 3)</code></pre><pre><code class="lang-python">a</code></pre><pre><code>array([[[ 0,  1,  2],        [ 3,  4,  5],        [ 6,  7,  8],        [ 9, 10, 11],        [12, 13, 14]],       [[15, 16, 17],        [18, 19, 20],        [21, 22, 23],        [24, 25, 26],        [27, 28, 29]]])</code></pre><h3 id="4-2-向量组合-stacking"><a href="#4-2-向量组合-stacking" class="headerlink" title="4.2 向量组合(stacking)"></a>4.2 向量组合(stacking)</h3><p>如何使用两个相同形状的列表构建一个二维数组。<br><br>在MATLAB中这十分简单：x,y是相同长度的两个向量，只需要：m = [x;y]<br><br>在Python的Numpy中：通过函数:column_stack、dstack、hstack、vstack来完成。</p><pre><code class="lang-python">x = np.arange(0,10,2)y = np.arange(5)print(&quot;x:&quot;,x)print(&quot;y:&quot;,y)print(&quot;np.vstack([x,y]):\n&quot;,np.vstack([x,y]))print(&quot;np.hstack([x,y]):\n&quot;,np.hstack([x,y]))</code></pre><pre><code>x: [0 2 4 6 8]y: [0 1 2 3 4]np.vstack([x,y]): [[0 2 4 6 8] [0 1 2 3 4]]np.hstack([x,y]): [0 2 4 6 8 0 1 2 3 4]</code></pre><h3 id="4-3-直方图-histogram"><a href="#4-3-直方图-histogram" class="headerlink" title="4.3 直方图(histogram)"></a>4.3 直方图(histogram)</h3><p>Numpy中的histogram函数是通过一个数组，返回一对变量：直方图数组和箱式向量。<br><br><strong>注：</strong>matplotlib也有一个用来建立直方图的函数(hist,与MATLAB一样)，并且与Numpy不同。主要的差别是：matplotlib.hist会自动绘制直方图，而numpy.histogram仅仅产生数据</p><pre><code class="lang-python">import numpyimport pylab# 创建一个正态分布的平均值和标准差mu,sigma = 2,0.5# 随机创建10000个符合正态分布的样本v = numpy.random.normal(mu,sigma,10000)print(v)# 使用pylab的hist# 自己调整bins的值即可知道其作用pylab.hist(v,bins=100)pylab.title(&quot;Matplotlib Version&quot;)pylab.show()# 使用numpy的histogram&#39;&#39;&#39;histogram(a,bins=10,range=None,weights=None,density=False);    a是待统计数据的数组；    bins指定统计的区间个数；    range是一个长度为2的元组，表示统计范围的最小值和最大值，默认值None，表示范围由数据的范围决定    weights为数组的每个元素指定了权值,histogram()会对区间中数组所对应的权值进行求和    density为True时，返回每个区间的概率密度；为False，返回每个区间中元素的个数&#39;&#39;&#39;(n,bins) = numpy.histogram(v,bins=100,density=False)# print(&quot;n,bins:&quot;,(n,bins))pylab.plot(.5*(bins[1:]+bins[:-1]),n)pylab.title(&quot;Numpy Version&quot;)pylab.show()</code></pre><pre><code>[1.45504749 1.84171988 1.39863619 ... 0.59289162 2.20937138 2.11719324]</code></pre><p><img src="/img/code_one_hour/2_1.png" srcset="/img/loading.gif" alt="png"></p><p><img src="/img/code_one_hour/2_2.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Numpy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习2:逻辑回归和正则化</title>
    <link href="/2020/07/08/ML_Andrew_Pex2_Logistic_Regression/"/>
    <url>/2020/07/08/ML_Andrew_Pex2_Logistic_Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习2-逻辑回归与正则化"><a href="#吴恩达机器学习程序练习2-逻辑回归与正则化" class="headerlink" title="吴恩达机器学习程序练习2:逻辑回归与正则化"></a>吴恩达机器学习程序练习2:逻辑回归与正则化</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex22391</p><h2 id="1-逻辑回归"><a href="#1-逻辑回归" class="headerlink" title="1.逻辑回归"></a>1.逻辑回归</h2><p>构建一个逻辑回归模型来预测学生是否被大学录取<br>假设你是大学相关的管理者，想通过申请学生两次测试的评分，来决定是否被录取，现在你拥有申请学生的可用于训练逻辑回归的训练样本集。<br>对于每一个样本：两次测试的评分与最后是否被录取结果</p><h3 id="1-1-数据可视化"><a href="#1-1-数据可视化" class="headerlink" title="1.1 数据可视化"></a>1.1 数据可视化</h3><pre><code class="lang-python">import numpy as npimport pandas as pdimport matplotlib.pyplot as plt</code></pre><pre><code class="lang-python">path = &#39;./andrew_ml_ex22391/ex2data1.txt&#39;data = pd.read_csv(path,header=None,names=[&#39;Exam 1&#39;,&#39;Exam 2&#39;,&#39;Admitted&#39;])data.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Exam 1</th>      <th>Exam 2</th>      <th>Admitted</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>34.623660</td>      <td>78.024693</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>30.286711</td>      <td>43.894998</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>35.847409</td>      <td>72.902198</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>60.182599</td>      <td>86.308552</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>79.032736</td>      <td>75.344376</td>      <td>1</td>    </tr>  </tbody></table></div><pre><code class="lang-python"># 获取Admitted为1的data所有的数据# pandas库中的isin()用于数据筛选# isin()接收一个列表，判断该列中元素是否在列表中positive = data[data[&#39;Admitted&#39;].isin([1])]negative = data[data[&#39;Admitted&#39;].isin([0])]# print(positive)fig,ax = plt.subplots(figsize=(12,8))ax.scatter(positive[&#39;Exam 1&#39;],positive[&#39;Exam 2&#39;],s = 50,c=&#39;b&#39;,marker=&#39;o&#39;,label=&#39;Admitted&#39;)ax.scatter(negative[&#39;Exam 1&#39;],negative[&#39;Exam 2&#39;],s=50,c=&#39;r&#39;,marker=&#39;x&#39;,label=&#39;Nor Admitted&#39;)ax.legend()ax.set_xlabel(&#39;Exam 1 Score&#39;)ax.set_ylabel(&#39;Exam 2 Score&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/lg6.png" srcset="/img/loading.gif" alt="png"></p><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h3><h4 id="1-2-1-sigmoid函数"><a href="#1-2-1-sigmoid函数" class="headerlink" title="1.2.1 sigmoid函数"></a>1.2.1 sigmoid函数</h4><p>逻辑回归函数 (选择的模型) (hypothesis函数) 为</p><script type="math/tex; mode=display">h_\theta=g(\theta^Tx)</script><p>g()代表一个常用的逻辑函数(logistic function) ，即 Sigmoid 函数(Sigmoid function)(Logistic function),公式为:</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}</script><p>所以合起来，得到的逻辑回归模型的假设函数为：</p><script type="math/tex; mode=display">h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}</script><pre><code class="lang-python"># 实现sigmoid函数def sigmoid(z):    return 1/(1+np.exp(-z))</code></pre><h4 id="1-2-2-代价函数和梯度"><a href="#1-2-2-代价函数和梯度" class="headerlink" title="1.2.2 代价函数和梯度"></a>1.2.2 代价函数和梯度</h4><p>代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)})log(1-h_\theta(x^{(i)}))]</script><p>梯度：</p><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial \theta_j}=\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>虽然这个梯度与线性回归的梯度一模一样，但是$h_\theta(x)$是不一样的！</p><pre><code class="lang-python"># 实现代价函数def cost(theta,X,y):    theta = np.matrix(theta)    X=np.matrix(X)    y = np.matrix(y)    first = np.multiply(-y,np.log(sigmoid(X*theta.T)))    second = np.multiply((1-y),np.log(1-sigmoid(X*theta.T)))    return np.sum(first-second)/(len(X))</code></pre><p>初始化X,y,$\theta$</p><pre><code class="lang-python"># 添加一列常数列data.insert(0,&#39;Ones&#39;,1)# 初始化X,y,thetacols = data.shape[1]X = data.iloc[:,0:cols-1]y = data.iloc[:,cols-1:cols]theta = np.zeros(3)# 转换类型X = np.array(X.values)y = np.array(y.values)# print(&quot;X为：&quot;)# print(X)# print(&quot;y为：&quot;)# print(y)</code></pre><pre><code class="lang-python"># 检查矩阵的维度X.shape,theta.shape,y.shape</code></pre><pre><code>((100, 3), (3,), (100, 1))</code></pre><pre><code class="lang-python"># 用初始theta来计算代价(验证正确性)cost(theta,X,y)</code></pre><pre><code>0.6931471805599453</code></pre><pre><code class="lang-python"># 实现梯度计算的函数(由于使用第三方库来计算theta，故不进行梯度下降)def gradient(theta,X,y):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    parameters = int(theta.ravel().shape[1])    grad = np.zeros(parameters)    # 迭代计算-------------------------------    error = sigmoid(X*theta.T)-y    for i in range(parameters):        term = np.multiply(error,X[:,i])        # 求解梯度        grad[i] = np.sum(term)/len(X)        # 梯度下降        # theta[0][i]=theta[0][i]-alpha*grad[i]    # ----------------------------------------    return grad</code></pre><h4 id="1-2-3-用工具库计算-theta-的值"><a href="#1-2-3-用工具库计算-theta-的值" class="headerlink" title="1.2.3 用工具库计算$\theta$的值"></a>1.2.3 用工具库计算$\theta$的值</h4><p>在之前的线性回归中，我们自己写代码实现梯度下降：代价函数、计算梯度、梯度下降。<br><br>此次，我们通过调用已有的库来进行梯度下降（即：不用自己定义迭代次数和步长，功能会直接告诉我们最优解。正如：Andrew Ng介绍的Octave的’fminunc’函数）。<br><br>在python中，可以使用scipy.optimize.fmin_tnc做同样的事情</p><pre><code class="lang-python">import scipy.optimize as optresult = opt.fmin_tnc(func=cost,x0=theta,fprime=gradient,args=(X,y))result</code></pre><pre><code>(array([-25.16131872,   0.20623159,   0.20147149]), 36, 0)</code></pre><pre><code class="lang-python"># 使用第三方库计算的结果带回代价函数计算cost(result[0],X,y)</code></pre><pre><code>0.20349770158947425</code></pre><pre><code class="lang-python"># 画出决策曲线plotting_x1 = np.linspace(30,100,100)plotting_h1 = ( - result[0][0]-result[0][1]*plotting_x1)/result[0][2]fig,ax = plt.subplots(figsize=(12,8))ax.plot(plotting_x1,plotting_h1,&#39;y&#39;,label = &#39;Prediction&#39;)ax.scatter(positive[&#39;Exam 1&#39;], positive[&#39;Exam 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Admitted&#39;)ax.scatter(negative[&#39;Exam 1&#39;], negative[&#39;Exam 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Not Admitted&#39;)ax.legend()ax.set_xlabel(&#39;Exam 1 Score&#39;)ax.set_ylabel(&#39;Exam 2 Score&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/lg26.png" srcset="/img/loading.gif" alt="png"></p><h4 id="1-2-4-评价逻辑回归模型"><a href="#1-2-4-评价逻辑回归模型" class="headerlink" title="1.2.4 评价逻辑回归模型"></a>1.2.4 评价逻辑回归模型</h4><p>在确定参数之后，可以使用这个模型来预测一个学生是否被录取</p><pre><code class="lang-python"># 实现h(x)def hfunc1(theta,X):    return sigmoid(np.dot(theta.T,X))hfunc1(result[0],[1,45,85])</code></pre><pre><code>0.776290625526598</code></pre><h5 id="评价-theta"><a href="#评价-theta" class="headerlink" title="评价$\theta$"></a>评价$\theta$</h5><p>看模型在训练集上的正确率怎么样。写一个predict的函数，给出数据以及参数后，会返回0或者1.然后在把这个priedict函数用于训练集上，看准确率怎样</p><pre><code class="lang-python"># 定义预测函数def predict(theta,X):    probability = sigmoid(X*theta.T)    return [1 if x &gt;= 0.5 else 0 for x in probability]</code></pre><pre><code class="lang-python"># 添加预测准确率theta_min = np.matrix(result[0])predictions = predict(theta_min,X)# zip()，打包成一个一个的元组correct = [1 if ((a==1 and b == 1) or (a == 0 and b==0)) else 0 for (a,b) in zip(predictions,y)]accuracy = (sum(map(int,correct))% len(correct))print(&#39;accuracy = {0}%&#39;.format(accuracy))</code></pre><pre><code>accuracy = 89%</code></pre><p>画出对应曲线(有缘再续)</p><h2 id="2-逻辑回归-正则化"><a href="#2-逻辑回归-正则化" class="headerlink" title="2.逻辑回归+正则化"></a>2.逻辑回归+正则化</h2><p>实现加入正则项来提升逻辑回归算法。<br><br>假设你是工厂的生产主管，你有一些芯片在两次测试中的测试结果，测试结果决定芯片是否接受或抛弃。有一些历史数据，可以帮助构建一个逻辑回归模型。</p><h3 id="2-1-数据可视化"><a href="#2-1-数据可视化" class="headerlink" title="2.1 数据可视化"></a>2.1 数据可视化</h3><pre><code class="lang-python">path = &#39;./andrew_ml_ex22391/ex2data2.txt&#39;data_init = pd.read_csv(path,header=None,names = [&#39;Test 1&#39;,&#39;Test 2&#39;,&#39;Accepted&#39;])data_init.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Test 1</th>      <th>Test 2</th>      <th>Accepted</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.051267</td>      <td>0.69956</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>-0.092742</td>      <td>0.68494</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>-0.213710</td>      <td>0.69225</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>-0.375000</td>      <td>0.50219</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>-0.513250</td>      <td>0.46564</td>      <td>1</td>    </tr>  </tbody></table></div><pre><code class="lang-python">positive2 = data_init[data_init[&#39;Accepted&#39;].isin([1])]negative2 = data_init[data_init[&#39;Accepted&#39;].isin([0])]fig,ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;],positive2[&#39;Test 2&#39;],s=50,c=&#39;b&#39;,marker=&#39;o&#39;,label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;],negative2[&#39;Test 2&#39;],s=50,c=&#39;r&#39;,marker=&#39;x&#39;,label=&#39;Rejected&#39;)ax.legend()ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)plt.show()</code></pre><p><img src="/img/ML_Andrew/lg37.png" srcset="/img/loading.gif" alt="png"></p><p>如上图所示，这个数据集不可使用直线进行分割，而之前的逻辑回归只适用于线性的分割，故另想它法</p><h3 id="2-2-特征映射"><a href="#2-2-特征映射" class="headerlink" title="2.2 特征映射"></a>2.2 特征映射</h3><p>一种更好的使用数据集的方式是为每组数据创造更多的特征。所以我们为每一组$x_1,x_2$添加了最高到6次幂的特征</p><pre><code class="lang-python">degree = 6data2 = data_initx1 = data2[&#39;Test 1&#39;]x2 = data2[&#39;Test 2&#39;]data2.insert(3,&#39;Ones&#39;,1)for i in range(1,degree+1):    for j in range(0,i+1):        data2[&#39;F&#39;+str(i-j)+str(j)]=np.power(x1,i-j)*np.power(x2,j)data2.drop(&#39;Test 1&#39;,axis=1,inplace=True)data2.drop(&#39;Test 2&#39;,axis = 1,inplace=True)data2.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Accepted</th>      <th>Ones</th>      <th>F10</th>      <th>F01</th>      <th>F20</th>      <th>F11</th>      <th>F02</th>      <th>F30</th>      <th>F21</th>      <th>F12</th>      <th>...</th>      <th>F23</th>      <th>F14</th>      <th>F05</th>      <th>F60</th>      <th>F51</th>      <th>F42</th>      <th>F33</th>      <th>F24</th>      <th>F15</th>      <th>F06</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>1</td>      <td>0.051267</td>      <td>0.69956</td>      <td>0.002628</td>      <td>0.035864</td>      <td>0.489384</td>      <td>0.000135</td>      <td>0.001839</td>      <td>0.025089</td>      <td>...</td>      <td>0.000900</td>      <td>0.012278</td>      <td>0.167542</td>      <td>1.815630e-08</td>      <td>2.477505e-07</td>      <td>0.000003</td>      <td>0.000046</td>      <td>0.000629</td>      <td>0.008589</td>      <td>0.117206</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>1</td>      <td>-0.092742</td>      <td>0.68494</td>      <td>0.008601</td>      <td>-0.063523</td>      <td>0.469143</td>      <td>-0.000798</td>      <td>0.005891</td>      <td>-0.043509</td>      <td>...</td>      <td>0.002764</td>      <td>-0.020412</td>      <td>0.150752</td>      <td>6.362953e-07</td>      <td>-4.699318e-06</td>      <td>0.000035</td>      <td>-0.000256</td>      <td>0.001893</td>      <td>-0.013981</td>      <td>0.103256</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>1</td>      <td>-0.213710</td>      <td>0.69225</td>      <td>0.045672</td>      <td>-0.147941</td>      <td>0.479210</td>      <td>-0.009761</td>      <td>0.031616</td>      <td>-0.102412</td>      <td>...</td>      <td>0.015151</td>      <td>-0.049077</td>      <td>0.158970</td>      <td>9.526844e-05</td>      <td>-3.085938e-04</td>      <td>0.001000</td>      <td>-0.003238</td>      <td>0.010488</td>      <td>-0.033973</td>      <td>0.110047</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>1</td>      <td>-0.375000</td>      <td>0.50219</td>      <td>0.140625</td>      <td>-0.188321</td>      <td>0.252195</td>      <td>-0.052734</td>      <td>0.070620</td>      <td>-0.094573</td>      <td>...</td>      <td>0.017810</td>      <td>-0.023851</td>      <td>0.031940</td>      <td>2.780914e-03</td>      <td>-3.724126e-03</td>      <td>0.004987</td>      <td>-0.006679</td>      <td>0.008944</td>      <td>-0.011978</td>      <td>0.016040</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>1</td>      <td>-0.513250</td>      <td>0.46564</td>      <td>0.263426</td>      <td>-0.238990</td>      <td>0.216821</td>      <td>-0.135203</td>      <td>0.122661</td>      <td>-0.111283</td>      <td>...</td>      <td>0.026596</td>      <td>-0.024128</td>      <td>0.021890</td>      <td>1.827990e-02</td>      <td>-1.658422e-02</td>      <td>0.015046</td>      <td>-0.013650</td>      <td>0.012384</td>      <td>-0.011235</td>      <td>0.010193</td>    </tr>  </tbody></table><p>5 rows × 29 columns</p></div><h3 id="2-3-代价函数和梯度"><a href="#2-3-代价函数和梯度" class="headerlink" title="2.3 代价函数和梯度"></a>2.3 代价函数和梯度</h3><p>代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m[-y^{(i)}log(h_\theta(x^{(i)}))-(1-y^{(i)})log(1-h_\theta(x^{(i)}))]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^{2}</script><p>注：$\theta_0$是不需要正则化，故下标从1开始</p><p>梯度的第j个元素的更新公式：</p><script type="math/tex; mode=display">\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]x_0^{(i)}</script><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]x_j^{(i)}+\frac{\lambda}{m}\theta_j</script><p>对j=1,2,…….n时的式子重新调整：</p><script type="math/tex; mode=display">\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^m[h_\theta(x^{(i)})-y^{(i)}]x_j^{(i)}</script><pre><code class="lang-python"># 实现正则化的代价函数def costReg(theta,X,y,learningRate):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    first = np.multiply(-y,np.log(sigmoid(X*theta.T)))    second = np.multiply((1-y),np.log(1-sigmoid(X*theta.T)))    reg = (learningRate/(2*len(X)))*np.sum(np.power(theta[:,1:theta.shape[1]],2))    return np.sum(first-second)/len(X)+reg</code></pre><pre><code class="lang-python"># 实现正则化的梯度函数def gradientReg(theta,X,y,learningRate):    theta = np.matrix(theta)    X = np.matrix(X)    y = np.matrix(y)    patameters = int(theta.ravel().shape[1])    grad = np.zeros(patameters)    error = sigmoid(X*theta.T)-y    for i in range(patameters):        term = np.multiply(error,X[:,i])        if i==0 :            grad[i] = np.sum(term)/len(X)        else :            grad[i] = (np.sum(term)/len(X))+((learningRate/len(X))*theta[:,i])    return grad</code></pre><pre><code class="lang-python"># 初始化X,y.thetacols = data2.shape[1]X2 = data2.iloc[:,1:cols]y2 = data2.iloc[:,0:1]theta2 = np.zeros(cols-1)# 类型转换X2 = np.array(X2.values)y2 = np.array(y2.values)# lambda设为1learningRate = 1</code></pre><pre><code class="lang-python"># 计算初始代价costReg(theta2,X2,y2,learningRate)</code></pre><pre><code>0.6931471805599454</code></pre><h4 id="2-3-1-使用工具库求解-theta-等参数"><a href="#2-3-1-使用工具库求解-theta-等参数" class="headerlink" title="2.3.1 使用工具库求解$\theta$等参数"></a>2.3.1 使用工具库求解$\theta$等参数</h4><pre><code class="lang-python">result2 = opt.fmin_tnc(func=costReg,x0=theta2,fprime=gradientReg,args=(X2,y2,learningRate))result2</code></pre><pre><code>(array([ 1.27271027,  0.62529965,  1.18111687, -2.01987399, -0.91743189,        -1.43166928,  0.12393228, -0.36553118, -0.35725403, -0.17516292,        -1.45817009, -0.05098418, -0.61558554, -0.27469165, -1.19271298,        -0.2421784 , -0.20603299, -0.04466178, -0.27778951, -0.29539513,        -0.45645982, -1.04319155,  0.02779373, -0.2924487 ,  0.0155576 ,        -0.32742405, -0.1438915 , -0.92467487]), 32, 1)</code></pre><p>最后，我们可以使用第1部分中的预测函数来查看我们的方案在训练数据上的准确度。</p><pre><code class="lang-python">theta_min = np.matrix(result2[0])predictions = predict(theta_min, X2)correct = [1 if ((a == 1 and b == 1) or (a == 0 and b == 0)) else 0 for (a, b) in zip(predictions, y2)]accuracy = (sum(map(int, correct)) % len(correct))print (&#39;accuracy = {0}%&#39;.format(accuracy))</code></pre><pre><code>accuracy = 98%</code></pre><h3 id="2-4-画出决策曲线"><a href="#2-4-画出决策曲线" class="headerlink" title="2.4 画出决策曲线"></a>2.4 画出决策曲线</h3><pre><code class="lang-python"># 预测函数h(x)def hfunc2(theta, x1, x2):    temp = theta[0][0]    place = 0    for i in range(1, degree+1):        for j in range(0, i+1):            temp+= np.power(x1, i-j) * np.power(x2, j) * theta[0][place+1]            place+=1    return temp</code></pre><pre><code class="lang-python"># 找出边界def find_decision_boundary(theta):    t1 = np.linspace(-1,1.5,1000)    t2 = np.linspace(-1,1.5,1000)    # 获取(t1,t2)这样的数组对    cordinates=[(x,y) for x in t1 for y in t2]    # print(&quot;cordinates是：\n{}&quot;.format(cordinates))    # 一个一个抽取(x.y)的数组对    x_cord,y_cord = zip(*cordinates)    # print(&quot;cx_cord,y_cord是：\n{}，{}&quot;.format(x_cord,y_cord))    h_val = pd.DataFrame({&#39;x1&#39;:x_cord,&#39;x2&#39;:y_cord})    print(&quot;h_val是：\n{}&quot;.format(h_val))    h_val[&#39;hval&#39;]=hfunc2(theta,h_val[&#39;x1&#39;],h_val[&#39;x2&#39;])    decision=h_val[np.abs(h_val[&#39;hval&#39;])&lt;2*10**-3]    return decision.x1, decision.x2</code></pre><pre><code class="lang-python"># 画图fig,ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;], positive2[&#39;Test 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;], negative2[&#39;Test 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Rejected&#39;)ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)x,y =find_decision_boundary(result2)plt.scatter(x, y, c=&#39;y&#39;, s=10, label=&#39;Prediction&#39;)ax.legend()plt.show()</code></pre><pre><code>h_val是：         x1        x20      -1.0 -1.0000001      -1.0 -0.9974972      -1.0 -0.9949953      -1.0 -0.9924924      -1.0 -0.989990...     ...       ...999995  1.5  1.489990999996  1.5  1.492492999997  1.5  1.494995999998  1.5  1.497497999999  1.5  1.500000[1000000 rows x 2 columns]</code></pre><p><img src="/img/ML_Andrew/lg55.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-5-改变-lambda-，观察决策曲线"><a href="#2-5-改变-lambda-，观察决策曲线" class="headerlink" title="2.5 改变$\lambda$，观察决策曲线"></a>2.5 改变$\lambda$，观察决策曲线</h3><h4 id="2-5-1-过拟合"><a href="#2-5-1-过拟合" class="headerlink" title="2.5.1 过拟合"></a>2.5.1 过拟合</h4><p>当$\lambda=0$可以得出，使正则化项为0，使得$\theta$值不受$\lambda$影响，从而特征过多，方差过高，出现过拟合(对每一个训练集样本都尽可能拟合)</p><pre><code class="lang-python">learningRate2 = 0result3 = opt.fmin_tnc(func=costReg, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate2))result3</code></pre><pre><code>(array([  13.21662791,   17.63904891,    5.27881592, -136.13732177,         -67.12242042,  -52.94668399, -147.43086589,  -91.68410686,         -38.38361129,    6.59822331,  495.35657992,  402.46736709,         511.3069028 ,  206.24695325,   66.55863181,  273.9167483 ,         304.90920777,  318.45935938,  157.30786853,   54.95286981,           1.80807367, -601.66243281, -692.5740057 , -962.14314287,        -654.83889729, -639.88930817, -262.03506162,  -50.59000875]), 280, 3)</code></pre><pre><code class="lang-python">fig, ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;], positive2[&#39;Test 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;], negative2[&#39;Test 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Rejected&#39;)ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)x, y = find_decision_boundary(result3)plt.scatter(x, y, c=&#39;y&#39;, s=10, label=&#39;Prediction&#39;)ax.legend()plt.show()</code></pre><pre><code>h_val是：         x1        x20      -1.0 -1.0000001      -1.0 -0.9974972      -1.0 -0.9949953      -1.0 -0.9924924      -1.0 -0.989990...     ...       ...999995  1.5  1.489990999996  1.5  1.492492999997  1.5  1.494995999998  1.5  1.497497999999  1.5  1.500000[1000000 rows x 2 columns]</code></pre><p><img src="/img/ML_Andrew/lg59.png" srcset="/img/loading.gif" alt="png"></p><h4 id="2-5-2-欠拟合"><a href="#2-5-2-欠拟合" class="headerlink" title="2.5.2 欠拟合"></a>2.5.2 欠拟合</h4><p>当$\lambda=100$可以得出，使得$\theta$值更容易受$\lambda$影响，从而使$\theta$过小，偏差过高，出现欠拟合(对整个一个训练集样本都勉强拟合)</p><pre><code class="lang-python">learningRate3 = 100result4 = opt.fmin_tnc(func=costReg, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate3))result4</code></pre><pre><code>(array([ 0.02187847, -0.0174817 ,  0.00571065, -0.05516901, -0.01314874,        -0.03859873, -0.01846356, -0.00773219, -0.00892429, -0.02280461,        -0.04343846, -0.00235623, -0.01415612, -0.00349507, -0.04143595,        -0.02100593, -0.00471917, -0.00359131, -0.00632226, -0.0050244 ,        -0.03197683, -0.03416334, -0.00107629, -0.00702615, -0.00038507,        -0.0079823 , -0.00154779, -0.04108683]), 11, 1)</code></pre><pre><code class="lang-python">fig, ax = plt.subplots(figsize=(12,8))ax.scatter(positive2[&#39;Test 1&#39;], positive2[&#39;Test 2&#39;], s=50, c=&#39;b&#39;, marker=&#39;o&#39;, label=&#39;Accepted&#39;)ax.scatter(negative2[&#39;Test 1&#39;], negative2[&#39;Test 2&#39;], s=50, c=&#39;r&#39;, marker=&#39;x&#39;, label=&#39;Rejected&#39;)ax.set_xlabel(&#39;Test 1 Score&#39;)ax.set_ylabel(&#39;Test 2 Score&#39;)x, y = find_decision_boundary(result4)plt.scatter(x, y, c=&#39;y&#39;, s=10, label=&#39;Prediction&#39;)ax.legend()plt.show()</code></pre><pre><code>h_val是：         x1        x20      -1.0 -1.0000001      -1.0 -0.9974972      -1.0 -0.9949953      -1.0 -0.9924924      -1.0 -0.989990...     ...       ...999995  1.5  1.489990999996  1.5  1.492492999997  1.5  1.494995999998  1.5  1.497497999999  1.5  1.500000[1000000 rows x 2 columns]</code></pre><p><img src="/img/ML_Andrew/lg62.png" srcset="/img/loading.gif" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code One Hour：Numpy-Base</title>
    <link href="/2020/06/27/Code_One_Hour1/"/>
    <url>/2020/06/27/Code_One_Hour1/</url>
    
    <content type="html"><![CDATA[<h1 id="Numpy使用-基础篇"><a href="#Numpy使用-基础篇" class="headerlink" title="Numpy使用-基础篇"></a>Numpy使用-基础篇</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Numpy的主要对象是相同类型的多维数组，也即：所有元素都是一种类型、通过整数索引对应元素。<br>在Numpy中维度(Dimensions)称为轴(axes、axis)<br>轴的个数称为秩(rank)</p><p>eg:[1,2,3]是一个一维(轴)数组，秩为1，轴的长度为3<br>  [[1,2,3],[4,5,6]]是一个二维数组，轴为2，秩为2，第一维度长度为2，第二维度长度为3</p><p>Numpy的数组类型称为ndarray，通常被称为数组。(numpy.array与标准python库中的array.array不同，后者只处理一维数组和提供一些功能)</p><h3 id="1-1-ndarray对象属性"><a href="#1-1-ndarray对象属性" class="headerlink" title="1.1 ndarray对象属性"></a>1.1 ndarray对象属性</h3><p>ndarray.ndim :获取ndarray的轴的个数，也即是秩<br><br>ndarray.shape:获取ndarray的维度<br><br>ndarray.size:获取ndarray的元素总个数=ndarray.shape的乘积<br><br>ndarray.dtype:描述ndarray中元素的类型<br><br>ndarray.itemsize:获取ndarray中每个元素的字节大小<br><br>ndarray.data:包含实际ndarray元素的缓冲区<br></p><pre><code class="lang-python">from numpy import *a = arange(15).reshape(3,5)print(a)print(a.shape)print(a.ndim)print(a.dtype.name)print(a.itemsize)print(a.size)print(type(a))b = array([6,7,8])print(b)print(type(b))</code></pre><pre><code>[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]](3, 5)2int32415&lt;class &#39;numpy.ndarray&#39;&gt;[6 7 8]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h2 id="2-创建ndarray"><a href="#2-创建ndarray" class="headerlink" title="2.创建ndarray"></a>2.创建ndarray</h2><p>有几种方式创建ndarray</p><pre><code class="lang-python">import numpy# 1.通过numpy.array()创建print(&quot;法一创建ndarray&quot;)a = numpy.array([1,2,3,4])print(a)print(a.dtype)print(type(a))# 类型可以创建时显示指定b = numpy.array([[1,2],[3,4]],dtype=complex)print(b)# 2.numpy.zeros()创建一个全是0的ndarrayprint(&quot;法二创建ndarray&quot;)c = numpy.zeros((3,4))print(c)print(type(c))# 3.numpy.ones()创建一个全是1的ndarrayd = numpy.ones((1,2,3),dtype=int16)print(&quot;法三创建&quot;)print(d)print(d.dtype)print(type(d))# 4.numpy.empty()创建一个内容随机并且依赖内存状态的ndarrayprint(&quot;法四创建&quot;)e = numpy.empty((3,1))print(e)print(e.dtype)print(type(e))print(&quot;法五创建&quot;)# 10-30的公差为5的ndarray# 结果不包含终值f = numpy.arange(10,30,5)print(f)print(f.dtype)print(type(f))# 结果可包含终值# 0-20的等差数列，一共6个g = numpy.linspace(0,20,6)print(g)print(type(g))</code></pre><pre><code>法一创建ndarray[1 2 3 4]int32&lt;class &#39;numpy.ndarray&#39;&gt;[[1.+0.j 2.+0.j] [3.+0.j 4.+0.j]]法二创建ndarray[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]&lt;class &#39;numpy.ndarray&#39;&gt;法三创建[[[1 1 1]  [1 1 1]]]int16&lt;class &#39;numpy.ndarray&#39;&gt;法四创建[[2.28386032e+242] [6.01346953e-154] [6.01347002e-154]]float64&lt;class &#39;numpy.ndarray&#39;&gt;法五创建[10 15 20 25]int32&lt;class &#39;numpy.ndarray&#39;&gt;[ 0.  4.  8. 12. 16. 20.]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><h2 id="3-打印Ndarray"><a href="#3-打印Ndarray" class="headerlink" title="3.打印Ndarray"></a>3.打印Ndarray</h2><p>当打印一个数组时,Numpy是以类似嵌套列表的形式显示，<br><br>布局如下：<br><br>最后的轴从左到右打印<br><br>次后的轴从顶向下打印<br><br>剩下的轴从顶向下打印，每个切片通过一个空行与下一个隔开<br></p><pre><code class="lang-python">a = arange(6)print(a)b = arange(12).reshape(4,3)print(b)c = arange(24).reshape(2,3,4)print(c)# 太大会自动省略print(arange(100000))print(arange(10000).reshape(100,100))# 禁用NumPy的这种行为并强制打印整个数组，# 你可以设置printoptions参数来更改打印选项。set_printoptions(threshold=0)# print(arange(100000))</code></pre><pre><code>[0 1 2 3 4 5][[ 0  1  2] [ 3  4  5] [ 6  7  8] [ 9 10 11]][[[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] [[12 13 14 15]  [16 17 18 19]  [20 21 22 23]]][    0     1     2 ... 99997 99998 99999][[   0    1    2 ...   97   98   99] [ 100  101  102 ...  197  198  199] [ 200  201  202 ...  297  298  299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]]</code></pre><h2 id="4-基本运算"><a href="#4-基本运算" class="headerlink" title="4.基本运算"></a>4.基本运算</h2><p>ndarray的算术运算是按元素计算，新的数组被创建并且被结果填充</p><pre><code class="lang-python">import numpya = numpy.array([20,30,40,50])b = numpy.arange(4)c = a - bprint(&quot;a-b的结果是{}&quot;.format(c))print(&quot;b**2的结果是{}&quot;.format(b**2))print(&quot;10*sin(a)的结果是{}&quot;.format(10*sin(a)))print(&quot;a&lt;35的结果是{}&quot;.format(a&lt;35))</code></pre><pre><code>a-b的结果是[20 29 38 47]b**2的结果是[0 1 4 9]10*sin(a)的结果是[ 9.12945251 -9.88031624  7.4511316  -2.62374854]a&lt;35的结果是[ True  True False False]</code></pre><p>Numpy中的乘法运算符*是按元素进行计算<br>dot()才是真正数学上的矩阵的乘法</p><pre><code class="lang-python">A = numpy.array([[1,1],[0,1]])B = numpy.array([[2,0],[3,4]])print(&quot;A*b的结果是\n{}&quot;.format(A*B))# 真正的矩阵乘法print(&quot;AXB={}\n&quot;.format(dot(A,B)))</code></pre><pre><code>A*b的结果是[[2 0] [0 4]]AXB=[[5 4] [3 4]]</code></pre><p>一些操作符eg:+=,*=是用来改变已存在的数组，而不是重新创建一个新的数组</p><pre><code class="lang-python">a = numpy.ones((2,3),dtype=int)b =numpy.random.random((2,3))a *= 3print(&quot;改变a为a *= 3 :{}&quot;.format(a))print(&quot;之前的b:{}&quot;.format(b))b += aprint(&quot;b += a之后的b:{}&quot;.format(b))# 报错 a += b，因为类型不匹配，并且小类型不可以加大类型</code></pre><pre><code>改变a为a *= 3 :[[3 3 3] [3 3 3]]之前的b:[[0.48206941 0.82075551 0.20677084] [0.40972474 0.1612522  0.40600564]]b += a之后的b:[[3.48206941 3.82075551 3.20677084] [3.40972474 3.1612522  3.40600564]]</code></pre><p>找最值、求和</p><pre><code class="lang-python">a = numpy.random.random((3,3))print(a)print(&quot;a的全部和:{}&quot;.format(a.sum()))print(&quot;a的全部元素里的最小值:{}&quot;.format(a.min()))print(&quot;a的全部元素里的最大值:{}&quot;.format(a.max()))</code></pre><pre><code>[[0.3284271  0.14197324 0.7038814 ] [0.65741107 0.14568861 0.60085068] [0.62157778 0.60594248 0.19610351]]a的全部和:4.0018558644883155a的全部元素里的最小值:0.1419732429134546a的全部元素里的最大值:0.703881395273379</code></pre><p>指定轴的找最值，求和，使用axis来指定</p><pre><code class="lang-python">b = numpy.arange(9).reshape(3,3)print(b)print(&quot;指定每列求和{}&quot;.format(b.sum(axis=0)))print(&quot;指定每行求最小值{}&quot;.format(b.min(axis=1)))# 看成数组，前项累加print(&quot;指定行累加\n{}&quot;.format(b.cumsum(axis=1)))</code></pre><pre><code>[[0 1 2] [3 4 5] [6 7 8]]指定每列求和[ 9 12 15]指定每行求最小值[0 3 6]指定行累加[[ 0  1  3] [ 3  7 12] [ 6 13 21]]</code></pre><h2 id="5-通用函数ufunc"><a href="#5-通用函数ufunc" class="headerlink" title="5.通用函数ufunc"></a>5.通用函数ufunc</h2><p>Numpy提供常见的数学函数如：sin,cos和exp。在Numpy中，这些叫<strong>通用函数ufunc</strong>。在Numpy里这些函数作用按数组元素运算，产生一个数组作为输出。</p><pre><code class="lang-python">B = numpy.arange(3)print(B)</code></pre><pre><code>[0 1 2]</code></pre><pre><code class="lang-python">exp(B)</code></pre><pre><code>array([1.        , 2.71828183, 7.3890561 ])</code></pre><pre><code class="lang-python">sqrt(B)</code></pre><pre><code>array([0.        , 1.        , 1.41421356])</code></pre><pre><code class="lang-python">C = array([2.,-1.,4.])add(B,C)</code></pre><pre><code>array([2., 0., 6.])</code></pre><p>更多函数：<br><br>all, alltrue, any, apply along axis, argmax, argmin, argsort, average,<br>bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum,<br>diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum,<br>nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose,<br>var, vdot, vectorize, where</p><p><strong>索引、切片、迭代</strong></p><pre><code class="lang-python">a = arange(10)**3a</code></pre><pre><code>array([  0,   1,   8, ..., 343, 512, 729], dtype=int32)</code></pre><pre><code class="lang-python">a[2]</code></pre><pre><code>8</code></pre><pre><code class="lang-python">a[2:5]</code></pre><pre><code>array([ 8, 27, 64], dtype=int32)</code></pre><pre><code class="lang-python"># 从头(:)到索引7，间隔为2赋值a[:7:2]=-1000print(a)print(a[2],a[4],a[6])</code></pre><pre><code>[-1000     1 -1000 ...   343   512   729]-1000 -1000 -1000</code></pre><pre><code class="lang-python"># 逆序索引a[::-1]</code></pre><pre><code>array([  729,   512,   343, ..., -1000,     1, -1000], dtype=int32)</code></pre><pre><code class="lang-python">for i in a:    print(i**(1/3.),end=&quot;,&quot;)</code></pre><pre><code>nan,1.0,nan,3.0,nan,5.0,nan,6.999999999999999,7.999999999999999,8.999999999999998,d:\dl\minconda3\envs\ml_andrewng\lib\site-packages\ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power</code></pre><p>多维数组每个轴有一个索引。这些索引由一个逗号分割的元组给出</p><pre><code class="lang-python">def f(x,y):    return 10*x+y# 从函数规则创建数组（使用索引与元素的对应关系(自定义的function)进行创建）b = fromfunction(f,(5,4),dtype=int)b</code></pre><pre><code>array([[ 0,  1,  2,  3],       [10, 11, 12, 13],       [20, 21, 22, 23],       [30, 31, 32, 33],       [40, 41, 42, 43]])</code></pre><pre><code class="lang-python">b[0:5,1]</code></pre><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><pre><code class="lang-python">b[:,1]</code></pre><pre><code>array([ 1, 11, 21, 31, 41])</code></pre><pre><code class="lang-python">b[1:3,:]</code></pre><pre><code>array([[10, 11, 12, 13],       [20, 21, 22, 23]])</code></pre><pre><code class="lang-python"># 当少于轴数的索引被提供时，确失的索引被认为是整个切片：b[-1]</code></pre><pre><code>array([40, 41, 42, 43])</code></pre><p>b[i]中括号中的表达式被当作i和一系列:，来代表剩下的轴。NumPy也允许你使用“点”像b[i,…]。</p><p>点(…)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴)，那么:</p><pre><code>x[1,2,…] 等同于 x[1,2,:,:,:]x[…,3] 等同于 x[:,:,:,:,3]x[4,…,5,:] 等同于 x[4,:,:,5,:]</code></pre><pre><code class="lang-python"># c = array( [ [[  0,  1,  2],  # a 3D array (two stacked 2D arrays) ... [ 10, 12, 13]]... # [[100,101,102], ... [110,112,113]] ] ) # c.shape (2, 2, 3) # c[1,...]    # same as c[1,:,:] or c[1] array([[100, 101, 102], [110, 112, 113]]) # c[...,2]      # same as c[:,:,2] array([[  2,  13], [102, 113]])</code></pre><p>迭代多维数组是就第一个轴而言的</p><pre><code class="lang-python">for row in b:    print (row)</code></pre><pre><code>[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]</code></pre><p>如果想对每个数组中元素进行运算，我们可以使用flat属性，该属性是数组元素的一个迭代器:</p><pre><code class="lang-python">for element in b.flat:    print (element,end=&quot;,&quot;)</code></pre><pre><code>0,1,2,3,10,11,12,13,20,21,22,23,30,31,32,33,40,41,42,43,</code></pre><p>更多newaxis, ndenumerate, indices, index exp 可以参考Numpy示例</p><h2 id="6-形状操作"><a href="#6-形状操作" class="headerlink" title="6.形状操作"></a>6.形状操作</h2><p><strong>改变数组的形状</strong></p><pre><code class="lang-python">a = floor(10*random.random((3,4)))a</code></pre><pre><code>array([[7., 4., 5., 7.],       [7., 8., 7., 4.],       [2., 5., 3., 4.]])</code></pre><pre><code class="lang-python">a.shape</code></pre><pre><code>(3, 4)</code></pre><pre><code class="lang-python"># 矩阵扁平化a.ravel()</code></pre><pre><code>array([7., 4., 5., ..., 5., 3., 4.])</code></pre><pre><code class="lang-python"># 改变形状a.shape=(6,2)print(a)# 矩阵转置a.transpose()print(a)</code></pre><pre><code>[[7. 4.] [5. 7.] [7. 8.] [7. 4.] [2. 5.] [3. 4.]][[7. 4.] [5. 7.] [7. 8.] [7. 4.] [2. 5.] [3. 4.]]</code></pre><p>reshape()根据参数改变形状并返回<br><br>resize()根据参数改变自身形状</p><pre><code class="lang-python">aprint(a)a.resize((2,6))print(a)</code></pre><pre><code>[[7. 4.] [5. 7.] [7. 8.] [7. 4.] [2. 5.] [3. 4.]][[7. 4. 5. 7. 7. 8.] [7. 4. 2. 5. 3. 4.]]</code></pre><p>如果在改变形状操作中一个维度被给做-1，其维度将自动被计算<br>更多 shape, reshape, resize, ravel 参考Numpy示例</p><p><strong>组合不同的数组(stack)</strong></p><pre><code class="lang-python">a = floor(10*random.random((2,2)))b = floor(10*random.random((2,2)))print(a)print(b)</code></pre><pre><code>[[5. 1.] [1. 6.]][[4. 9.] [3. 6.]]</code></pre><pre><code class="lang-python"># 一行一行的合并，矩阵变化方向是按vertical的方向vstack((a,b))</code></pre><pre><code>array([[5., 1.],       [1., 6.],       [4., 9.],       [3., 6.]])</code></pre><pre><code class="lang-python"># 一列一列的合并，矩阵变化方向是按horizontal的方向hstack((a,b))</code></pre><pre><code>array([[5., 1., 4., 9.],       [1., 6., 3., 6.]])</code></pre><pre><code class="lang-python"># 以列将一维数组合成二维数组,类似hstack()column_stack((a,b))</code></pre><pre><code>array([[5., 1., 4., 9.],       [1., 6., 3., 6.]])</code></pre><pre><code class="lang-python">a = array([4.,3.])b = array([2.,8.])# np.newaxis==newaxis：增加一个维度a[:,newaxis]column_stack((a[:,newaxis],b[:,newaxis]))</code></pre><pre><code>array([[4., 2.],       [3., 8.]])</code></pre><p>row<em>stack()将一维数组以行组合成二维数组。<br>对那些维度比二维更高的数组，hstack沿着第二个轴组合，vstack沿着第一个轴组合,concatenate允许可选参数给出组合时沿着的轴。<br>在复杂情况下，r</em>[]和c_[]对创建沿着一个方向组合的数很有用，它们允许范围符号(“:”):</p><pre><code class="lang-python">r_[1:4,0,4]</code></pre><pre><code>array([1, 2, 3, 0, 4])</code></pre><pre><code class="lang-python">c_[1,2,3,4,5]</code></pre><pre><code>array([[1, 2, 3, 4, 5]], dtype=int32)</code></pre><p>当使用数组作为参数时，r<em>和c</em>的默认行为和vstack和hstack很像，但是允许可选的参数给出组合所沿着的轴的代号。<br><br>更多函数hstack, vstack, column<em>stack, row_stack, concatenate, c</em>, r_ 参见Numpy示例.</p><p><strong>将一个数组分割(split)成几个小数组</strong><br><br>使用hsplit你能将数组沿着它的水平轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割:</p><pre><code class="lang-python">a = floor(10*random.random((2,12)))print(a)</code></pre><pre><code>[[1. 4. 9. ... 8. 9. 4.] [1. 5. 7. ... 2. 6. 8.]]</code></pre><pre><code class="lang-python">hsplit(a,3)</code></pre><pre><code>[array([[1., 4., 9., 6.],        [1., 5., 7., 5.]]), array([[4., 6., 3., 4.],        [4., 7., 2., 7.]]), array([[0., 8., 9., 4.],        [5., 2., 6., 8.]])]</code></pre><pre><code class="lang-python"># 水平分割从第3列到第五列(不包括)hsplit(a,(3,5))</code></pre><pre><code>[array([[1., 4., 9.],        [1., 5., 7.]]), array([[6., 4.],        [5., 4.]]), array([[6., 3., 4., ..., 8., 9., 4.],        [7., 2., 7., ..., 2., 6., 8.]])]</code></pre><p>vsplit沿着纵向的轴分割，array split允许指定沿哪个轴分割。</p><p><strong>复制和视图</strong></p><p><strong>完全不拷贝</strong><br><br>简单的复制(=)并不会拷贝数据，即只是不同指针指向同一个地方</p><pre><code class="lang-python">a = arange(12)b = ab is a</code></pre><pre><code>True</code></pre><pre><code class="lang-python">b.shape=(3,4)print(a.shape)</code></pre><pre><code>(3, 4)</code></pre><p>Python 传递不定对象作为参考，所以函数调用不拷贝数组。</p><pre><code class="lang-python">def f(x):    print (id(x))print(id(a))     f(a)</code></pre><pre><code>101697936101697936</code></pre><p><strong>视图(view)和浅复制</strong><br><br>不同的数组对象共享一个数据，视图方法创造一个新的数组对象指向同一数据</p><pre><code class="lang-python">c = a.view()c is a</code></pre><pre><code>False</code></pre><pre><code class="lang-python">c.base is a</code></pre><pre><code>True</code></pre><pre><code class="lang-python">c.flags.owndata</code></pre><pre><code>False</code></pre><pre><code class="lang-python"># view_c的形状改变不会影响a的形状c.shape = 2,6print(c)print(a)</code></pre><pre><code>[[ 0  1  2  3  4  5] [ 6  7  8  9 10 11]][[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]</code></pre><pre><code class="lang-python"># view_c的数据改变会改变ac[0,4]=11111a</code></pre><pre><code>array([[    0,     1,     2,     3],       [11111,     5,     6,     7],       [    8,     9,    10,    11]])</code></pre><pre><code class="lang-python"># 切片数组返回它的一个视图：s = a[:,1:3]print(s)s[:]=10print(a)</code></pre><pre><code>[[ 1  2] [ 5  6] [ 9 10]][[    0    10    10     3] [11111    10    10     7] [    8    10    10    11]]</code></pre><p><strong>深复制</strong><br><br>这个方法完全复制数组和它的数据</p><pre><code class="lang-python">d = a.copy()d is a</code></pre><pre><code>False</code></pre><pre><code class="lang-python">d.base is a</code></pre><pre><code>False</code></pre><pre><code class="lang-python">d[0,0]=9999a</code></pre><pre><code>array([[    0,    10,    10,     3],       [11111,    10,    10,     7],       [    8,    10,    10,    11]])</code></pre><h2 id="7-函数和方法-method-总览"><a href="#7-函数和方法-method-总览" class="headerlink" title="7.函数和方法(method)总览"></a>7.函数和方法(method)总览</h2><p>这是个Numpy函数和方法分类排列目录。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity,<br>linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like</p><h3 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h3><p>astype, atleast 1d, atleast 2d, atleast 3d, mat</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item,<br>newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</p><h3 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h3><p>all, any, nonzero, where</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>argmax, argmin, argsort, max, min, ptp, searchsorted, sort</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum</p><h3 id="基本统计"><a href="#基本统计" class="headerlink" title="基本统计"></a>基本统计</h3><p>cov, mean, std, var</p><h3 id="基本线性代数"><a href="#基本线性代数" class="headerlink" title="基本线性代数"></a>基本线性代数</h3><p>cross, dot, outer, svd, vdot</p>]]></content>
    
    
    <categories>
      
      <category>Code One Hour</category>
      
      <category>Numpy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Code</tag>
      
      <tag>Code One Huor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习程序练习1:线性回归</title>
    <link href="/2020/06/20/ML_Andrew_Pex1_Linear_Regression%20/"/>
    <url>/2020/06/20/ML_Andrew_Pex1_Linear_Regression%20/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达机器学习程序练习1-线性回归"><a href="#吴恩达机器学习程序练习1-线性回归" class="headerlink" title="吴恩达机器学习程序练习1:线性回归"></a>吴恩达机器学习程序练习1:线性回归</h1><p>更多详细信息可参考同文件夹下的andrew_ml_ex14179</p><pre><code class="lang-python"># 导入对应的第三方库import numpy as npimport pandas as pdimport matplotlib.pyplot as plt</code></pre><h2 id="1-简单练习"><a href="#1-简单练习" class="headerlink" title="1.简单练习"></a>1.简单练习</h2><pre><code class="lang-python">A = np.eye(6)A</code></pre><pre><code>array([[1., 0., 0., 0., 0., 0.],       [0., 1., 0., 0., 0., 0.],       [0., 0., 1., 0., 0., 0.],       [0., 0., 0., 1., 0., 0.],       [0., 0., 0., 0., 1., 0.],       [0., 0., 0., 0., 0., 1.]])</code></pre><h2 id="2-单变量的线性回归"><a href="#2-单变量的线性回归" class="headerlink" title="2.单变量的线性回归"></a>2.单变量的线性回归</h2><p>根据城市人口数量，预测开小吃店的利润。<br>数据在ex1data1.txt中，第一列是城市人口数量，第二列是该城市小吃店利润</p><h3 id="2-1-Plotting-the-data"><a href="#2-1-Plotting-the-data" class="headerlink" title="2.1 Plotting the data"></a>2.1 Plotting the data</h3><pre><code class="lang-python"># 读入数据并且显示path = &#39;./andrew_ml_ex14179/ex1data1.txt&#39;# header=1：以第一行数据作为列索引(列名)# names = [...]:给定列名# 返回DataFrame类型,Population：人口(万)data = pd.read_csv(path,header=None,names=[&#39;Population&#39;,&#39;Profit&#39;])# DataFrame.head([N]):返回前N行data.head(94)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Population</th>      <th>Profit</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>6.1101</td>      <td>17.5920</td>    </tr>    <tr>      <th>1</th>      <td>5.5277</td>      <td>9.1302</td>    </tr>    <tr>      <th>2</th>      <td>8.5186</td>      <td>13.6620</td>    </tr>    <tr>      <th>3</th>      <td>7.0032</td>      <td>11.8540</td>    </tr>    <tr>      <th>4</th>      <td>5.8598</td>      <td>6.8233</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>89</th>      <td>5.0594</td>      <td>2.8214</td>    </tr>    <tr>      <th>90</th>      <td>5.7077</td>      <td>1.8451</td>    </tr>    <tr>      <th>91</th>      <td>7.6366</td>      <td>4.2959</td>    </tr>    <tr>      <th>92</th>      <td>5.8707</td>      <td>7.2029</td>    </tr>    <tr>      <th>93</th>      <td>5.3054</td>      <td>1.9869</td>    </tr>  </tbody></table><p>94 rows × 2 columns</p></div><pre><code class="lang-python"># 将数据绘图成散点图data.plot(kind=&#39;scatter&#39;,x=&#39;Population&#39;,y=&#39;Profit&#39;,figsize=(12,8))plt.show()</code></pre><p><img src="/img/ML_Andrew/pex1_1.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-2-梯度下降"><a href="#2-2-梯度下降" class="headerlink" title="2.2 梯度下降"></a>2.2 梯度下降</h3><p>使用传统的线性回归的代价函数</p><h4 id="2-2-1-公式"><a href="#2-2-1-公式" class="headerlink" title="2.2.1 公式"></a>2.2.1 公式</h4><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m{(h_{\theta}(x^{(i)})-y^{(i)})^2}</script><pre><code class="lang-python"># X是矩阵def computeCost(X,y,theta):    # *对应元素相乘    inner = np.power(((X*theta.T)-y),2)    return np.sum(inner)/(2*len(X))</code></pre><pre><code class="lang-python"># 验证矩阵间的乘法(*)是对应元素相乘x=np.array([[1,2],[3,4]])y=np.array([[1,2],[3,4]])print(x*y)# 这才是真正的矩阵的乘法print(x.dot(y))# 对应元素相减print(x-y)</code></pre><pre><code>[[ 1  4] [ 9 16]][[ 7 10] [15 22]][[0 0] [0 0]]</code></pre><h4 id="2-2-2-实现"><a href="#2-2-2-实现" class="headerlink" title="2.2.2 实现"></a>2.2.2 实现</h4><p>新加一列x，用于更新theta,并且将theta初始化为0，学习率初始化为0.01，迭代次数为1500次</p><pre><code class="lang-python"># 在第0列新增一列索引为Ones的全部为1的数据data.insert(0,&#39;Ones&#39;,1)# 删除某一列 要axis=1，因为默认是行# 并且要inplace=True,才是对原数据进行操作data.head(100)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Ones</th>      <th>Population</th>      <th>Profit</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>6.1101</td>      <td>17.59200</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>5.5277</td>      <td>9.13020</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>8.5186</td>      <td>13.66200</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>7.0032</td>      <td>11.85400</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>5.8598</td>      <td>6.82330</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>92</th>      <td>1</td>      <td>5.8707</td>      <td>7.20290</td>    </tr>    <tr>      <th>93</th>      <td>1</td>      <td>5.3054</td>      <td>1.98690</td>    </tr>    <tr>      <th>94</th>      <td>1</td>      <td>8.2934</td>      <td>0.14454</td>    </tr>    <tr>      <th>95</th>      <td>1</td>      <td>13.3940</td>      <td>9.05510</td>    </tr>    <tr>      <th>96</th>      <td>1</td>      <td>5.4369</td>      <td>0.61705</td>    </tr>  </tbody></table><p>97 rows × 3 columns</p></div><pre><code class="lang-python"># 初始化# 获得data的列数，0为行数cols=data.shape[1]print(cols)# [,]先行后列,获取对应行列对应区域的数据X = data.iloc[:,:-1]Y = data.iloc[:,cols-1:cols]# X训练集 Y目标集print(type(X))print(type(Y))</code></pre><pre><code>3&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</code></pre><pre><code class="lang-python"># 因为代价函数使用的是numpy矩阵，所以要转换X和Y，并且初始化theta# X.values:获取X的值，没有索引了# print(type(X.values))# print(Y.values)print(type(X))# 将X，Y转换为对应的矩阵X=np.matrix(X)# print(X)# print(X)print(type(Y))y=np.matrix(Y.values)print(type(y))theta = np.asmatrix(np.array([0,0]))print(theta)</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&lt;class &#39;numpy.matrix&#39;&gt;[[0 0]]</code></pre><pre><code class="lang-python"># 查看对应维度X.shape,theta.shape,y.shapeprint(theta.size)</code></pre><pre><code>2</code></pre><h4 id="2-2-3-计算代价函数"><a href="#2-2-3-计算代价函数" class="headerlink" title="2.2.3 计算代价函数"></a>2.2.3 计算代价函数</h4><p>theta初始为0<br>computeCost(X,y,theta)</p><pre><code class="lang-python">computeCost(X,y,theta)</code></pre><pre><code>32.072733877455676</code></pre><h4 id="2-2-4-梯度下降算法"><a href="#2-2-4-梯度下降算法" class="headerlink" title="2.2.4 梯度下降算法"></a>2.2.4 梯度下降算法</h4><p>目标是最小化代价函数J(theta)，变量是theta不是X和y,通过变换theta来变化代价函数，进而使代价函数最小。<br>检查梯度下降算法是否正确运行，可以打印J(theta)的值来判断是否在不断减小，并且最后收敛到一个稳定的值。</p><pre><code class="lang-python">def gradientDescent(X,y,theta,alpha,iters):    # 初始化参数矩阵    temp=np.matrix(np.zeros(theta.shape))    # ravel()将矩阵扁平化    # 获取参数theta的个数    parameters = int(theta.ravel().shape[1])    # 用来存储代价    cost = np.zeros(iters)    thetax = np.zeros((iters,theta.size))    # print(thetax)    for i in range(iters):        # 计算代价误差        # h_theta(x)-y        error = (X*theta.T)-y        for j in range(parameters):            # np.multiply()对应元素相乘            # 计算J(theta)的导数            term = np.multiply(error,X[:,j])            # 进行梯度下降            temp[0,j]=theta[0,j]-((alpha/len(X)))*np.sum(term)            thetax[i][j]=temp[0,j]        theta = temp        cost[i]=computeCost(X,y,theta)    return theta,cost,thetax</code></pre><pre><code class="lang-python"># 初始化alpha 和 itersalpha = 0.01iters = 1500# 运行梯度下降算法来找到适合训练集的thetag,cost,thetax = gradientDescent(X,y,theta,alpha,iters)g</code></pre><pre><code>matrix([[-3.63029144,  1.16636235]])</code></pre><pre><code class="lang-python"># 预测35000和70000城市规模的小吃利润predict1 = [1,3.5]*g.Tprint(&quot;predict1:&quot;,predict1)predict2=[1,7]*g.Tprint(&quot;predict2:&quot;,predict2)</code></pre><pre><code>predict1: [[0.45197679]]predict2: [[4.53424501]]</code></pre><pre><code class="lang-python"># 显示原始数据以及拟合的线性回归方程# numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 在[start,stop]返回num均匀分布的样本x = np.linspace(data.Population.min(),data.Population.max(),100)# print(x)f = g[0,0]+(g[0,1]*x)# plt.subplots(1,3,figsize=(12,8))设置一个1行3个12*8大小的子图# 返回一个figure图像和一个子图ax的列表fig ,ax =plt.subplots(figsize=(12,8))# ax.plot()绘制一条线ax.plot(x,f,&#39;r&#39;,label=&#39;Prediction&#39;)# ax.scatter()绘制一个散点图ax.scatter(data.Population,data.Profit,label=&#39;Training Data&#39;)# ax.legend(loc=1)显示图中的标签在第一象限ax.legend(loc=1)ax.set_xlabel(&quot;Population&quot;)ax.set_ylabel(&#39;Profit&#39;)ax.set_title(&quot;Predicted Profit vs. Population Size&quot;)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex1_2.png" srcset="/img/loading.gif" alt="png"></p><h3 id="2-3可视化J-theta-未完待续"><a href="#2-3可视化J-theta-未完待续" class="headerlink" title="2.3可视化J(theta)(未完待续)"></a>2.3可视化J(theta)(未完待续)</h3><p>希望能够画出J(theta)与theta0,theta1之间的对应关系，应该是一个三维图像</p><pre><code class="lang-python">print(thetax.shape)print(cost.shape)print(X.shape)print(y.shape)print(cost)</code></pre><pre><code>(1500, 2)(1500,)(97, 2)(97, 1)[6.73719046 5.93159357 5.90115471 ... 4.48343473 4.48341145 4.48338826]</code></pre><pre><code class="lang-python"># 绘制3d图像# 直接根据theta0,theta1,costfunction对应的点来绘制出的散点图from mpl_toolkits.mplot3d import Axes3Dfrom matplotlib import cmfig=plt.figure()ax=fig.add_subplot(111,projection=&#39;3d&#39;)x=thetax[:,0]y1=thetax[:,1]ax.plot_trisurf(x,y1,cost,)plt.show()</code></pre><p><img src="/img/ML_Andrew/pex1_3.png" srcset="/img/loading.gif" alt="png"></p><h2 id="3-多变量线性回归"><a href="#3-多变量线性回归" class="headerlink" title="3.多变量线性回归"></a>3.多变量线性回归</h2><p>数据集:ex1data2.txt：<br>第一列：房屋大小<br>第二列：卧室数量<br>第三列：房屋售价<br>根据已有数据建立模型，预测房屋的售价</p><pre><code class="lang-python"># 读入数据并且显示path = &#39;./andrew_ml_ex14179/ex1data2.txt&#39;# header=1：以第一行数据作为列索引(列名)# names = [...]:给定列名# 返回DataFrame类型,Population：人口(万)data2 = pd.read_csv(path,header=None,names=[&#39;Size&#39;,&#39;Bedrooms&#39;,&#39;Price&#39;])# DataFrame.head([N]):返回前N行print(data2.head())print(data2.shape)</code></pre><pre><code>   Size  Bedrooms   Price0  2104         3  3999001  1600         3  3299002  2400         3  3690003  1416         2  2320004  3000         4  539900(47, 3)</code></pre><h3 id="3-1-特征缩放-Feature-Scaling"><a href="#3-1-特征缩放-Feature-Scaling" class="headerlink" title="3.1 特征缩放(Feature Scaling)"></a>3.1 特征缩放(Feature Scaling)</h3><p>根据数据得知，size变量的大小是bedrooms的1000倍，所以最好统一量级，可以使梯度下降收敛的更快</p><h4 id="3-1-1Mean-Normalization-均值归一化"><a href="#3-1-1Mean-Normalization-均值归一化" class="headerlink" title="3.1.1Mean Normalization(均值归一化)"></a>3.1.1Mean Normalization(均值归一化)</h4><p>特征减去平均值再除以标准差</p><pre><code class="lang-python">data2 = (data2-data2.mean())/data2.std()data2.head()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Size</th>      <th>Bedrooms</th>      <th>Price</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.130010</td>      <td>-0.223675</td>      <td>0.475747</td>    </tr>    <tr>      <th>1</th>      <td>-0.504190</td>      <td>-0.223675</td>      <td>-0.084074</td>    </tr>    <tr>      <th>2</th>      <td>0.502476</td>      <td>-0.223675</td>      <td>0.228626</td>    </tr>    <tr>      <th>3</th>      <td>-0.735723</td>      <td>-1.537767</td>      <td>-0.867025</td>    </tr>    <tr>      <th>4</th>      <td>1.257476</td>      <td>1.090417</td>      <td>1.595389</td>    </tr>  </tbody></table></div><h3 id="3-2-梯度下降算法"><a href="#3-2-梯度下降算法" class="headerlink" title="3.2 梯度下降算法"></a>3.2 梯度下降算法</h3><pre><code class="lang-python"># 为了能够根据矩阵运算，添加一列常数项# data2.drop(&#39;Ones&#39;,axis=1,inplace=True)data2.insert(0,&#39;Ones&#39;,1)# 初始化x,ycols = data2.shape[1]X2=data2.iloc[:,0:cols-1]y2=data2.iloc[:,cols-1:cols]# 转换为matrix格式并且初始化thetax2=np.matrix(X2)y2=np.matrix(y2)theta2 = np.matrix(np.array([0,0,0]))# 运行梯度下降算法print(&quot;开始运行梯度下降算法&quot;)g2,cost2,thetax=gradientDescent(x2,y2,theta2,alpha,iters)g2</code></pre><pre><code>开始运行梯度下降算法matrix([[-1.10898288e-16,  8.84042349e-01, -5.24551809e-02]])</code></pre><h3 id="3-3-Normal-Equation-正规方程算法"><a href="#3-3-Normal-Equation-正规方程算法" class="headerlink" title="3.3 Normal Equation(正规方程算法)"></a>3.3 Normal Equation(正规方程算法)</h3><p>正规方程是直接以theta为变量求解J(theta)的最小值，也即是直接求每个theta的偏导并且令其为0，求解方程即可<br>则利用正规方程解出向量：</p><script type="math/tex; mode=display">\theta = (X^TX)^{-1}X^Ty</script><p>梯度下降 VS 正规方程<br>梯度下降：需要选择学习率α，需要多次迭代，当特征数量n大时也能较好适用，适用于各种类型的模型<br>正规方程：不需要选择学习率α，一次计算得出，需要计算$(X^TX)^{-1}$，如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为O($n^3$)，通常来说当小于10000 时还是可以接受的，只适用于线性模型，不适合逻辑回归模型等其他模型</p><pre><code class="lang-python"># 正规方程def normalEqn(X,y):# numpy.linalg模块包含线性代数的函数。# 使用这个模块，可以计算逆矩阵、求特征值、解线性方程组以及求解行列式等# inv()求解矩阵的逆# pinv()求解矩阵的伪逆    theta = np.linalg.inv(X.T.dot(X))    theta = theta.dot(X.T)    theta = theta.dot(y)    return theta</code></pre><pre><code class="lang-python"># 使用data1数据进行验证final_theta2=normalEqn(X,y)final_theta2</code></pre><pre><code>matrix([[-3.89578088],        [ 1.19303364]])</code></pre><pre><code class="lang-python"># 使用梯度下降算法# 初始化alpha 和 itersalpha = 0.01iters = 1500# 运行梯度下降算法来找到适合训练集的thetag,cost,thetax = gradientDescent(X,y,theta,alpha,iters)g</code></pre><pre><code>matrix([[-3.63029144,  1.16636235]])</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>ML</category>
      
      <category>Programming Exercise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>ML</tag>
      
      <tag>Programming Exercise</tag>
      
      <tag>Andrew Ng</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T18</title>
    <link href="/2020/05/11/CprogrammingT18/"/>
    <url>/2020/05/11/CprogrammingT18/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T18"><a href="#C语言编程T18" class="headerlink" title="C语言编程T18"></a>C语言编程T18</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>空格处理要全面！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/211.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 80int CountWords(char str[]);int main(){    char str[N+1];    printf(&quot;Input a string:&quot;);    gets(str);    printf(&quot;Numbers of words = %d\n&quot;,CountWords(str));    return 0;}int CountWords(char str[]){    int i,j=0,k=0,count=0;    for(i=0;str[i]==&#39; &#39;;i++);    j=i-1;    for(i=0;str[i]!=&#39;\0&#39;;i++)    {        if(str[i]==&#39; &#39;)        {            for(k=i;str[k]==&#39; &#39;;k++);            i=k-1;            //printf(&quot;%c\n&quot;,str[i]);            if(i&gt;j)            {                count++;                j=i;            }        }    }    if(i&gt;j&amp;&amp;str[i-1]!=&#39; &#39;)    {        count++;        j=i;    }    return count;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T17</title>
    <link href="/2020/05/11/CprogrammingT17/"/>
    <url>/2020/05/11/CprogrammingT17/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T17"><a href="#C语言编程T17" class="headerlink" title="C语言编程T17"></a>C语言编程T17</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>注意边界</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/210.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int a[20]={2,4,6,8,10,12,14,16};    int i,j,x,len=8;    printf(&quot;Enter n:&quot;);    scanf(&quot;%d&quot;,&amp;x);    for(i=0;i&lt;len;i++)    {        if(a[0]&gt;x)        {            i=0;            break;        }        else if(a[i]&lt;x&amp;&amp;a[i+1]&gt;x)        {            i++;            break;        }        else if(a[len-1]&lt;x)        {            i=len-1;        }    }    for(j=len+1;j&gt;=i;j--)    {        a[j+1]=a[j];    }    a[i]=x;    for(i=0;i&lt;len+1;i++)    {        printf(&quot;%d &quot;,a[i]);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T7</title>
    <link href="/2020/04/27/CorrectionT7/"/>
    <url>/2020/04/27/CorrectionT7/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T7"><a href="#C语言改错T7" class="headerlink" title="C语言改错T7"></a>C语言改错T7</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p><strong>注意返回的是-1还是+1，是谁到谁的距离！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/171.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;int MyStrcmp(char s[], char t[], char bigger[]);int main(){    char  str1[20], str2[20], str3[20];    int diff;    printf(&quot;Input string:&quot;);    gets(str1);    printf(&quot;Input another string:&quot;);    gets(str2);    diff = MyStrcmp(str1, str2, str3);    printf(&quot;The bigger string is:%s\n&quot;, str3);    printf(&quot;The differ of the strings is:%d\n&quot;, diff);    return 0;}int MyStrcmp(char s[], char t[], char bigger[]){    int i, result = 0;    int len1 = 0, len2 = 0;    while (s[len1++] != &#39;\0&#39;);    while (t[len2++] != &#39;\0&#39;);    for (i = 0; s[i] == t[i]; i++);    if (i==0 || s[i - 1] != &#39;\0&#39; )    {        result = t[i] - s[i];        //printf(&quot;rst=%d\n&quot;,result);    }    if (result &gt;= 0)    {        for (i = 0; i &lt; len2; i++)            bigger[i] = t[i];        bigger[i]=&#39;\0&#39;;    }    else    {        for (i = 0; i &lt; len1; i++)            bigger[i] = s[i];        bigger[i]=&#39;\0&#39;;    }    return -result;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T16</title>
    <link href="/2020/04/27/CprogrammingT16/"/>
    <url>/2020/04/27/CprogrammingT16/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T16"><a href="#C语言编程T16" class="headerlink" title="C语言编程T16"></a>C语言编程T16</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>根据过程自己找规律</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/169.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//分酒int i;main(){    int a,y,z;    //共有a,分成i    printf(&quot;Input Full a,Empty b,c,Get i:&quot;);    scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;y,&amp;z,&amp;i);    getti(a,y,z);    getti(a,z,y);}getti(a,y,z)  int a,y,z;  {int b=0,c=0;  //a、b、c表示现在容器已装的容量大小  //a、y、z表示的是容器的最大容量    printf(&quot;  a%d  b%d  c%d\n%4d%4d%4d\n&quot;,a,y,z,a,b,c);    while((a!=i||b!=i)&amp;&amp;c!=i)    {        //b为空,即将a倒满b        if(!b)        {            a-=y;            b=y;        }        //c已满,将c全部倒入a        else if(c==z)        {           a+=z;           c=0;        }        //b的容量大于c中还可以装入的容量        //将b倒入c直到装满        else if(b&gt;z-c)        {            b-=(z-c);            c=z;        }        //倒空b        else        {            c+=b;            b=0;        }        printf(&quot;%4d%4d%4d\n&quot;,a,b,c);    }  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T15</title>
    <link href="/2020/04/26/CprogrammingT15/"/>
    <url>/2020/04/26/CprogrammingT15/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T15"><a href="#C语言编程T15" class="headerlink" title="C语言编程T15"></a>C语言编程T15</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>字符串遇到 多空格、结尾空格、开头空格如何解决</strong><br>if判断要全面！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/165.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 80//多空格和结尾如何解决int CountWords(char str[]);int main(){    char str[N+1];   printf(&quot;Input a string:\n&quot;);   gets(str);   printf(&quot;Number of words=%d\n&quot;,CountWords(str));    return 0;}int CountWords(char str[]){    int i,k,count=0;    for(i=0;str[i]!=&#39;\0&#39;;i++)    {        if(str[i]==&#39; &#39;)        {            for(k=i;str[k]==&#39; &#39;;k++);            i=k;            if(str[i]!=&#39;\0&#39;)            {                count++;            }        }    }    return count+1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T14</title>
    <link href="/2020/04/26/CprogrammingT14/"/>
    <url>/2020/04/26/CprogrammingT14/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T14"><a href="#C语言编程T14" class="headerlink" title="C语言编程T14"></a>C语言编程T14</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>相等情况？？？每行情况？？？</strong><br>所以要有两个标记量</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/163.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define M 2#define N 6int main(){    int i,j,a[M][N],flag=0,flagz=0,max,min,row,col,k;    for(i=0;i&lt;M;i++)    {        for(j=0;j&lt;N;j++)        {            scanf(&quot;%d&quot;,&amp;a[i][j]);        }    }    for(i=0;i&lt;M;i++)    {        flag=1;        max=a[i][0];        for(j=0;j&lt;N;j++)        {            if(max&lt;a[i][j])            {                row=i;                col=j;                max=a[i][j];            }        }        //printf(&quot;max=%d\n&quot;,max);        for(k=0;k&lt;M;k++)        {            if(max&gt;=a[k][col]&amp;&amp;k!=row)            {                flag=0;                break;            }        }         //printf(&quot;min=%d\n&quot;,min);        if(flag)        {            flagz=1;            printf(&quot;%d\n&quot;,max);        }    }    if(!flagz)    {        printf(&quot;no saddle point\n&quot;);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T13</title>
    <link href="/2020/04/26/CprogrammingT13/"/>
    <url>/2020/04/26/CprogrammingT13/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T13"><a href="#C语言编程T13" class="headerlink" title="C语言编程T13"></a>C语言编程T13</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>四舍五入的函数是round()<br>向下取整的函数是floor()</strong><br>注意 : 题目要求</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/161.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define N 100int main(){    int saraly,houres,t,t1,i=0,g[N]={0};    float sh=0;    scanf(&quot;%d %d&quot;,&amp;saraly,&amp;houres);    sh=(float)saraly/houres;    printf(&quot;%.2f\n&quot;,sh);    t=round(sh);    printf( &quot;%d\n&quot;,t);    t1=t*t;    while(t1&gt;0)    {        g[i]=t1%10;        i++;        t1=t1/10;    }    printf(&quot;%d\n&quot;,i);    printf(&quot;%d %d %d\n&quot;,g[2],g[1],g[0]);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T12</title>
    <link href="/2020/04/25/CprogrammingT12/"/>
    <url>/2020/04/25/CprogrammingT12/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T12"><a href="#C语言编程T12" class="headerlink" title="C语言编程T12"></a>C语言编程T12</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><strong>约束条件很重要，不要越界！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/149.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int Isprime(long x);int main(){    long int c,d,total=0,i;    printf(&quot;please input c,d(c&gt;2):\n&quot;);    scanf( &quot;%ld,%ld&quot;,&amp;c,&amp;d);    //这里可以约束    for(i=c;i&lt;=d-2;i++)    {        //这里也可以约束        if(Isprime(i)&amp;&amp;Isprime(i+2))        {            printf(&quot;(%ld,%ld)\n&quot;,i,i+2);            total++;            i=i+2;        }    }    printf(&quot;total=%d\n&quot;,total);    return 0;}int Isprime(long x){    int i=2;    for(i=2;i&lt;x;i++)    {        if(x%i==0)        {            return 0;        }    }    return 1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T11</title>
    <link href="/2020/04/24/CprogrammingT11/"/>
    <url>/2020/04/24/CprogrammingT11/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T11"><a href="#C语言编程T11" class="headerlink" title="C语言编程T11"></a>C语言编程T11</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><img src="/img/c_correction/141.1.png" srcset="/img/loading.gif" alt=""><br>定积分的几何意义！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/141.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;float Integral(float (*f)(float), float a, float b);float y1(float x);float y2(float x);int main(){    printf(&quot;y1=%f\ny2=%f\n&quot;,Integral(y1,0,1),Integral(y2,0,3));    return 0;}float y1(float x){    //printf(&quot;y1=%f\n&quot;,1+x*x);    return 1+x*x;}float y2(float x){    return x/(1+x*x);}float Integral(float (*f)(float), float a, float b){    int n=100;    int i=1;    double s=0;    for(i=1;i&lt;=100;i++)    {        s+=((b-a)/n)*f(i*(b-a)/n);        //printf(&quot;s=%f\n&quot;,s);    }    return s;}*/#include &lt;stdio.h&gt;float Fun1(float x);float Fun2(float x);float Integral(float (*f)(float), float a, float b);int main(){    float y1, y2;    y1 = Integral(Fun1, 0.0, 1.0);    y2 = Integral(Fun2, 0.0, 3.0);    printf(&quot;y1=%f\ny2=%f\n&quot;, y1, y2);    return 0;}/*  函数功能：计算函数1+x*x的函数值 */float Fun1(float x){    return  1 + x * x;}/*  函数功能：计算函数x/(1+x*x)的函数值 */float Fun2(float x){    return x / (1 + x * x);}/*    函数功能：用梯形法计算函数的定积分 */float Integral(float (*f)(float), float a, float b){    float s, h;    int n = 100, i;    s = ((*f)(a) + (*f)(b)) / 2;    h = (b - a) / n;    for (i = 1; i &lt; n; i++)    {        s += (*f)(a + i * h);    }    return s * h;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T10</title>
    <link href="/2020/04/23/CprogrammingT10/"/>
    <url>/2020/04/23/CprogrammingT10/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T10"><a href="#C语言编程T10" class="headerlink" title="C语言编程T10"></a>C语言编程T10</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>floor()函数的应用:向下取整函数！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/129.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;float a[5] = {2.33, 2.56, 2.65, 2.66, 2.30};float t(float x, int n);float t(float x, int n){    float x1, x2;    int i;    for (x1 = x, i = 0; i &lt; n - 1; i++)        x1 *= 10.0;    printf(&quot;x1=%f\n&quot;,x1);    x2 = floor((double)x1);     printf(&quot;x2=%f\n&quot;,x2);    x1 = floor((double)(x1 - x2) * 10);    if (x1 &gt;= 5)        x2 += 1;    for (i = 0; i &lt; n - 1; i++)        x2 /= 10.0;    return x2;}int main(){    int i;    printf(&quot;Old array:\n&quot;);    for (i = 0; i &lt; 5; i++)        printf(&quot;a[%d]=%.3f\t&quot;, i, a[i]);    printf(&quot;\nnew array:\n&quot;);    for (i = 0; i &lt; 5; i++)        printf(&quot;a[%d]=%.2f\t&quot;, i, t(a[i], 2));    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T9</title>
    <link href="/2020/04/21/CprogrammingT9/"/>
    <url>/2020/04/21/CprogrammingT9/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T9"><a href="#C语言编程T9" class="headerlink" title="C语言编程T9"></a>C语言编程T9</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>注意英语的语法规范，i have a apple….太难了，注意名称前可能有冠词！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/108.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>##include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int Length(char p[]);int IsAllDigit(char p[]);int main(){    char str[N];    int is;    printf(&quot;Please input a string:&quot;);    gets(str);    printf(&quot;The string has %d characters.\n&quot;,Length(str));    is=IsAllDigit(str);    if(is)    {        printf(&quot;The string is a digit string.&quot;);    }    else    {        printf(&quot;The string is not a digit string.&quot;);    }    return 0;}int Length(char p[]){    int i;    for(i=0;p[i]!=&#39;\0&#39;;i++);    return i;}int IsAllDigit(char p[]){    int i;    for(i=0;p[i]!=&#39;\0&#39;;i++)    {        if(p[i]&lt;&#39;0&#39;||p[i]&gt;&#39;9&#39;)        {            return 0;        }    }    return 1;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T6</title>
    <link href="/2020/04/19/CorrectionT6/"/>
    <url>/2020/04/19/CorrectionT6/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T6"><a href="#C语言改错T6" class="headerlink" title="C语言改错T6"></a>C语言改错T6</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>字符串赋值:<strong>‘\0’也占字符数组一个字节</strong><br>char str[6]={‘C’\,’h’\,’i’\,’n’\,’a’\,’\0’};<br>char str[]={‘C’\,’h’\,’i’\,’n’\,’a’\,’\0’};<br>char str[]=”China”;<br>char *ptr=”China”;</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/92.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>strcpy()也可以用来字符串赋值</p><pre><code>#include &lt;stdio.h&gt;main(){    int i = 0;    char str[6] = {&#39;C&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;\0&#39;}, str1[6] , *ptr, *ptr1, *ptr2 ;    while (str[i] != &#39;\0&#39;)    {        putchar(str[i]);        i++;    }    ptr=str;    scanf(&quot;%s&quot;, ptr);    puts(ptr);    ptr1 = str;    puts(ptr1);    ptr2 = &quot;China&quot;;    puts(ptr2);    char str2[] = &quot;China&quot;;    printf(&quot;%s&quot;, str2);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T8</title>
    <link href="/2020/04/18/CprogrammingT8/"/>
    <url>/2020/04/18/CprogrammingT8/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T8"><a href="#C语言编程T8" class="headerlink" title="C语言编程T8"></a>C语言编程T8</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>注意英语的语法规范，1st,11th,21st…</strong><br>判断错误输入最好判断<strong>全面</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/87.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/87.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char month[13][20]={  &quot;none&quot;,&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,  &quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;};int main(){    int year,day,mon;    printf(&quot;Enter date (mm/dd/yy):&quot;);    scanf(&quot;%d/%d/%d&quot;,&amp;mon,&amp;day,&amp;year);    if(day&gt;31||day&lt;1||mon&gt;12||mon&lt;1)    {        printf(&quot;Input error!\n&quot;);    }    else    {        printf(&quot;Dated this %d&quot;,day);        switch(day)        {            case 1:            case 21:            case 31:                printf( &quot;st&quot;);                break;            case 2:            case 22:                printf( &quot;nd&quot;);                break;            case 3:            case 23:                printf( &quot;rd&quot;);                break;            default:                printf( &quot;th&quot;);        }        printf(&quot; day of %s&quot;,month[mon]);        printf(&quot;, 19%.2d.\n&quot;,year);    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T7</title>
    <link href="/2020/04/18/CprogrammingT7/"/>
    <url>/2020/04/18/CprogrammingT7/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T7"><a href="#C语言编程T7" class="headerlink" title="C语言编程T7"></a>C语言编程T7</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>认真审题、<strong>看清题目要求和计算公式</strong><br>求对角线之和,注意可能会重叠</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/82.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5int main(){    int a[N][N],i,j,s=0,t;    printf(&quot;Input a 5*5 matrix\n&quot;);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            scanf(&quot;%d&quot;,&amp;a[i][j]);        }        s+=a[i][i]+a[i][N-i-1];    }    /*for(i=0;i&lt;N;i++)    {    }*/    printf(&quot;sum=%5d\n&quot;,s-a[2][2]);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T5</title>
    <link href="/2020/04/17/CorrectionT5/"/>
    <url>/2020/04/17/CorrectionT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T5"><a href="#C语言改错T5" class="headerlink" title="C语言改错T5"></a>C语言改错T5</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>分清:<br>dstStr是目的，即要输出的<br>srcStr是源<br>故字符串是dstStr+srcStr,即srcStr在dstStr后面<br><strong>指针地址的变化与指针指向值的变化！！！</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/79.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 80void MyStrcat(char *dstStr, char *srcStr);main() {    char s[N], t[N];    printf(&quot;Input a string:\n&quot;);    gets(s);    printf(&quot;Input another string:\n&quot;);    gets(t);    MyStrcat(s, t);    printf(&quot;Concatenate results:%s\n&quot;, s);}void MyStrcat(char *dstStr, char *srcStr) {    while (*dstStr != &#39;\0&#39;)    {        dstStr++;    }    while (*srcStr != &#39;\0&#39;)    {        *dstStr = *srcStr;        srcStr++;        dstStr++;    }    //分清楚指针改变地址和改变其指向的值    *dstStr=&#39;\0&#39;;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T6</title>
    <link href="/2020/04/17/CprogrammingT6/"/>
    <url>/2020/04/17/CprogrammingT6/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T6"><a href="#C语言编程T6" class="headerlink" title="C语言编程T6"></a>C语言编程T6</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>变量迭代，阶乘计算int型可能会溢出，最好使用double。<br><strong>注:考虑到各种情况，包括:取0、-1等边界测试时，其余输出是否会有矛盾!!!</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/77.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;//考虑为0的情况int main(){    double x,t,t1=1,sum=0,t2,esp;    int n=3,count=1;    printf(&quot;Enter x &amp; eps:&quot;);    scanf(&quot;%lf%lf&quot;,&amp;x,&amp;esp);    if(x!=0)    {        t2=sum=x;        do        {            t1=-t1*n*(n-1);            n+=2;            t2=t2*x*x;            t=t2/t1;            sum+=t;            count++;        }while(fabs(t)&gt;=esp);    }    printf(&quot;sin(%f)=%f\n&quot;,x,sin(x));    printf(&quot;%d,sin(%f)=%f\n&quot;,count,x,sum);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inspiration1.0</title>
    <link href="/2020/04/15/Whimsy1/"/>
    <url>/2020/04/15/Whimsy1/</url>
    
    <content type="html"><![CDATA[<h1 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h1><p><strong>This is my idea,I hope one day i can fulfil it.</strong></p><hr><h2 id="Project-And-Description"><a href="#Project-And-Description" class="headerlink" title="Project And Description"></a>Project And Description</h2><p>过年前后金价会上升 : 可建立对应信息库+求解最大子序列<br>背诵提醒 : 根据记忆曲线(艾宾浩斯遗忘曲线)提醒用户背诵对应内容<br>云网盘 : 通过云服务器构建一个类似属于自己的网盘<br>高校图表 : 面对高考生的高校报考信息推荐，Python爬虫+大数据(高校分数线+报录比)+Python可视化(生成对应的报表+不同维度)<br>彩虹屁生成器 : 花式夸人+英语夸人，自然语言处理</p>]]></content>
    
    
    <categories>
      
      <category>Whimsy</category>
      
      <category>Procject</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Project</tag>
      
      <tag>Inspiration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T5</title>
    <link href="/2020/04/15/CprogrammingT5/"/>
    <url>/2020/04/15/CprogrammingT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T5"><a href="#C语言编程T5" class="headerlink" title="C语言编程T5"></a>C语言编程T5</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>找规律，一一列举即可<br><strong>注:是否满足所有情况!!!</strong><br>要从最小值开始列举<br>不然有可能运算不了全部解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/60.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找最小、才能求解全部情况</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100//要从最小的开始计算int IsInArray(int a[],int n,int x);void ClearArray(int a[],int n,int x);int GetMinArray(int a[],int n);int main(){    int i,n,a[N]={-1},change=0,j,m=0;    printf(&quot;Input n:&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;Input card numbers:&quot;);    for(i=0;i&lt;n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);    }    for(i=0;i&lt;n;i++)    {        m=GetMinArray(a,n);        //printf(&quot;a[m]=%d\n&quot;,m);        if(m!=-1&amp;&amp;IsInArray(a,n,m+1)&amp;&amp;IsInArray(a,n,m+2))        {            ClearArray(a,n,m+2);            ClearArray(a,n,m+1);            ClearArray(a,n,m);            /*for(j=0;j&lt;n;j++)            {                printf(&quot;%d &quot;,a[j]);            }            printf(&quot;\n&quot;);*/            change++;        }    }    printf(&quot;Exchanged:%d\n&quot;,change);    return 0;}int IsInArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            return 1;        }    }    return 0;}void ClearArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            a[i]=-1;            break;        }    }}int GetMinArray(int a[],int n){    int i,j,min=-1;    for(i=0;i&lt;n;i++)    {        if(a[i]!=-1)        {            min=a[i];           // printf(&quot;min=%d\n&quot;,min);            for(j=0;j&lt;n;j++)            {                if(a[j]!=-1&amp;&amp;min&gt;a[j])                {                    min=a[j];                }            }        }        else        {            i++;        }    }    return min;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T4</title>
    <link href="/2020/04/13/CorrectionT4/"/>
    <url>/2020/04/13/CorrectionT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T4"><a href="#C语言改错T4" class="headerlink" title="C语言改错T4"></a>C语言改错T4</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>指针数组要初始化<br><strong>指针都要初始化</strong><br>认真检查代码正确性:for(里面),数组交换位置,while();</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/39.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include  &lt;stdio.h&gt;#include &lt;string.h&gt;#define   MAX_LEN  10#define   N         150void SortString(char *ptr[], int n);main(){    int    i, n;    char   str[N][MAX_LEN],*pStr[N];    printf(&quot;How many countries?\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    getchar();    printf(&quot;Input their names:\n&quot;);    for (i=0; i&lt;n; i++)    {        pStr[i]=str[i];        gets(pStr[i]);        //printf(&quot;sr=%s\n&quot;,pStr[i]);    }    SortString(pStr,n);    printf(&quot;Sorted results:\n&quot;);    for (i=0; i&lt;n; i++)    {        puts(pStr[i]);    }}void SortString(char *ptr[], int n){    int    i, j;    char  *temp;    for (i=0; i&lt;n-1; i++)    {        for (j = i+1; j&lt;n; j++)        {            if (strcmp(ptr[i],ptr[j])&gt;0)            {                temp = ptr[i];                ptr[i] = ptr[j];                ptr[j] = temp;            }        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T4(妙)</title>
    <link href="/2020/04/13/CprogrammingT4/"/>
    <url>/2020/04/13/CprogrammingT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T4-妙"><a href="#C语言编程T4-妙" class="headerlink" title="C语言编程T4(妙)"></a>C语言编程T4(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>知规律，且有限，可迭代暴力破解</p><h3 id="思路一-回溯"><a href="#思路一-回溯" class="headerlink" title="思路一:回溯"></a>思路一:回溯</h3><p>只要将2、3、4、5放在不同位置,满足约束条件即可<br>又因2,3,4,5有规律,可递增尝试，递减回溯<br>所以找到回溯判定条件以及相应操作即可<br>此法较复杂</p><h3 id="思路二-穷举-正向思维"><a href="#思路二-穷举-正向思维" class="headerlink" title="思路二:穷举(正向思维)"></a>思路二:穷举(正向思维)</h3><p>因为只要将2、3、4、5放在四个不同位置，且其有规律<br>故采用四层或者三层for循环即可遍历所有可能解<br>所有只要输出满足约束条件的解即可<br><img src="/img/c_correction/45.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>何时回溯、何时穷举！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//强行穷举!!!#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6int main(){    int i, j, k, m, n, num;    int a[N];    a[0] = 1;    a[5] = 6;    num = 0;    printf(&quot;The possible table satisfied above conditions are:\n&quot;);    for (i = 2; i &lt;= 5; i++)        for (j = 2; j &lt;= 5; j++)            for (n = 2; n &lt;= 5; n++)                for (m = 2; m &lt;= 5; m++)                {                    a[1] = i;                    a[2] = j;                    a[3] = n;                    a[4] = m;                    if (a[2] &gt; a[1] &amp;&amp; a[4] &gt; a[3] &amp;&amp; a[4] &gt; a[1] &amp;&amp; a[1] != a[3] &amp;&amp; a[2] != a[3] &amp;&amp; a[2] != a[4])                    {                        num++;                        printf(&quot;\nNo.:%d&quot;, num);                        for (k = 0; k &lt; 6; k++)                        {                            if (k % 3 == 0)                                printf(&quot;\n&quot;);                            printf(&quot;%3d&quot;, a[k]);                        }                    }                }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T3(妙)</title>
    <link href="/2020/04/13/CprogrammingT3/"/>
    <url>/2020/04/13/CprogrammingT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T3-妙"><a href="#C语言编程T3-妙" class="headerlink" title="C语言编程T3(妙)"></a>C语言编程T3(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一-暴力破解-正向思维"><a href="#思路一-暴力破解-正向思维" class="headerlink" title="思路一:暴力破解(正向思维)"></a>思路一:暴力破解(正向思维)</h3><p>不断尝试各种数字,逐一尝试<br>但是由于n不确定,所以不知道要嵌套多少for和准备多少临时变量<br>故不可使用穷举法</p><h3 id="思路二-回溯-逆向思维"><a href="#思路二-回溯-逆向思维" class="headerlink" title="思路二:回溯(逆向思维)"></a>思路二:回溯(逆向思维)</h3><p><strong>从后往前观察思考，找到其规律</strong><br>采用数组,从后往前,逐一尝试,不符或者满足则采用不同的回溯，直至得出所有解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/42.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找规律 : 正向、逆向、解中有规律</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 10int main(){    int i[N];    int sum,n,total,k,flag=0,count=0;    printf(&quot;Please enter requried terms (&lt;=10):&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf( &quot;                             their sum:&quot;);    scanf(&quot;%d&quot;,&amp;total);    sum=0;    k=n;    //从后往前推导    i[n]=1;    printf(&quot;There are following possible series:\n&quot;);    while(1)    {        if(sum+i[k]&lt;total)        {            if(k&lt;=1)            {                i[1]=total-sum;                flag=1;            }            else            {                sum+=i[k];                k--;                //从最小值开始往前赋值                i[k]=i[k+1];                continue;                //继续while循环判断            }        }        //sum在中间已经大于可total        else if(sum+i[k]&gt;total||k!=1)        {            //想办法回溯            //减去上一个sum加的i[k]            sum-=i[++k];            flag=0;        }        else//sum+i[k]==total&amp;&amp;k==1        {            flag=1;        }        if(flag)        {             printf(&quot;[%d]:&quot;,++count);            for(flag=1;flag&lt;=n;++flag)                printf(&quot;%d&quot;,i[flag]);            printf(&quot;\n&quot;);        }        //判断i[n]是否已经变化到极致        if(++k&gt;n)        {            break;        }        //往后回溯        sum-=i[k];        //不断试探        i[k]++;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T2</title>
    <link href="/2020/04/12/CprogrammingT2/"/>
    <url>/2020/04/12/CprogrammingT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T2"><a href="#C语言编程T2" class="headerlink" title="C语言编程T2"></a>C语言编程T2</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="判断素数可以通过sqrt-或者x-2来降低循环次数"><a href="#判断素数可以通过sqrt-或者x-2来降低循环次数" class="headerlink" title="判断素数可以通过sqrt()或者x/2来降低循环次数"></a>判断素数可以通过sqrt()或者x/2来降低循环次数</h3><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用long long或者unsigned long 来存储2的i次幂<br>计算2的i次幂可以迭代计算,节省时间</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用double来存储2的i次幂<br>注 :</p><ol><li><p>pow()返回的double型，所以将其转换为int型时容易有精度误差，容易出错！！！<br>所以常使用while循环迭代计算<br>2.浮点型(float,double)不可以进行取余运算<br>故判断是否整除可以通过整型的除法特性计算(1/2==0)<br>即:x/i == (long long)(x/i)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/33.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>切记 : pow()的精度误差，一般在int型中不用！！！<br>``` </p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdlib.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <math.h></h1><p>int IsPrime(double x);<br>int main()<br>{<br> int i,count=0,n;<br> double s=0;<br> printf(“Input n:\n”);<br> scanf(“%d”,&amp;n);<br> for(i=2;i&lt;=n;i++)<br> {</p><pre><code> s=pow(2,i)-1; if(IsPrime(s)==1) {     printf(&quot;2^%d-1=%.0f\n&quot;,i,s);     count++; }</code></pre><p> }</p><p> printf(“count=%d\n”,count);<br> return 0;<br>}<br>int IsPrime(double x)<br>{<br> int i;<br> for(i=2;i&lt;sqrt(x);i++)<br> {</p><pre><code> if(x/i == (long long)(x/i)) {     return 0; }</code></pre><p> }<br> return 1;<br>}</p></li></ol><p>```</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T3</title>
    <link href="/2020/04/11/CorrectionT3/"/>
    <url>/2020/04/11/CorrectionT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T3"><a href="#C语言改错T3" class="headerlink" title="C语言改错T3"></a>C语言改错T3</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><h3 id="分清"><a href="#分清" class="headerlink" title="分清:"></a>分清:</h3><p>1.指针数组:  int *p[4]<br><strong>常用于字符串交换,因为相比strcpy()更加节省时间和空间</strong><br><strong>故使用指针数组进行交换效率更高索引技术、索引排序</strong></p><blockquote><p>函数中使用:<br>void Fun(int *p[M]);<br>Fun(p);</p></blockquote><p>2.二维数组的 行指针 :  int (*p)[4] </p><blockquote><p>p[i]==*(p+i):也就是p[i]的地址！！！<br>p[i][j] == *(p[i]+j) == *(*(p+i)+j) == (*(a+i))[j]<br>&amp;p[i][j] == p[i]+j == *(p+i)+j<br>函数中使用:<br>void Fun(int (*p)[M]);<br>Fun(p);//p == p[0] == p[0]的地址</p></blockquote><p>3.二维数组的列指针 :  int *p; p=*a</p><blockquote><p>p=*a &lt;==&gt; p=a[0] &lt;==&gt; p=&amp;a[0][0]<br>a[i][j]=*(p+i*n+j)<br>&amp;a[i][j]=p+i*n+j<br>函数中使用:<br>void Fun(int *p);<br>Fun(*p);</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/28.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:指针数组的妙用！！！</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;void Input(char *p[], int n);void Sort(char *p[], int n);void Print(char *p[], int n);int main(){                    char str[20][40];    char *pstr[20];    int i, n;    printf(&quot;Input n(n&lt;=20):\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    //注意要清空缓冲区里的空格    getchar();    for (i = 0; i &lt; n; i++)    {                  //指针数组要初始化        pstr[i] = str[i];           //2    }    Input(pstr, n);    Sort(pstr, n);    printf(&quot;Results:\n&quot;);    Print(pstr, n);    return 0;}                void Input(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        gets(p[i]);    }}                void Sort(char *p[], int n){                    char *t;                              //1    int i, j;    for (i = 0; i &lt; n - 1; i++)    {                        //注:j=i+1而不是1        for (j = i + 1; j &lt; n; j++)        {                            if (strcmp(p[j], p[i]) &lt; 0)    //2            {                       //直接用指针数组来简化strcpy()                t = p[i];                p[i] = p[j];                p[j] = t;            }        }    }}                void Print(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        printf(&quot;%s\n&quot;, p[i]);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T2</title>
    <link href="/2020/04/11/CorrectionT2/"/>
    <url>/2020/04/11/CorrectionT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T2"><a href="#C语言改错T2" class="headerlink" title="C语言改错T2"></a>C语言改错T2</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br><strong>换行、空格到底要不要???</strong>(没有特殊提示应该不用吧~now)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/27.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>多了一个换行~</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int mon[][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},    {0,31,29,31,30,31,30,31,31,30,31,30,31},};int  DayofYear(int year, int month, int day);void  MonthDay(int year, int yearDay, int *pMonth, int *pDay);int main(){    int choice,year,month,day,yearday,pmonth,pday;    printf(&quot;1. year/month/day -&gt; yearDay\n&quot;);    printf(&quot;2. yearDay -&gt; year/month/day\n&quot;);    printf(&quot;3. Exit\n&quot;);    //这里不用换行了！！！    printf(&quot;Please enter your choice:&quot;);    scanf(&quot;%d&quot;,&amp;choice);    switch(choice)    {    case 1:        printf(&quot;Please enter year, month, day:&quot;);        scanf(&quot;%d,%d,%d&quot;,&amp;year,&amp;month,&amp;day);        yearday=DayofYear(year,month,day);        printf(&quot;yearDay = %d\n&quot;,yearday);        break;    case 2:        printf(&quot;Please enter year, yearDay:&quot;);        scanf(&quot;%d,%d&quot;,&amp;year,&amp;yearday);        MonthDay(year,yearday,&amp;pmonth,&amp;pday);        printf(&quot;month = %d,day = %d\n&quot;,pmonth,pday);        break;    case 3:        return 0;    }    return 0;}int  DayofYear(int year, int month, int day){    int i,leap,d=day;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    for(i=0;i&lt;month;i++)    {        d+=mon[leap][i];    }    return d;}void  MonthDay(int year, int yearDay, int *pMonth, int *pDay){    int i=0,leap;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    while(1)    {        yearDay-=mon[leap][i];        i++;        if(yearDay&lt;mon[leap][i])        {            break;        }    }    *pMonth=i;    *pDay=yearDay;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T1</title>
    <link href="/2020/04/11/CprogrammingT1/"/>
    <url>/2020/04/11/CprogrammingT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T1"><a href="#C语言编程T1" class="headerlink" title="C语言编程T1"></a>C语言编程T1</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用gets()/scanf()直接输入字符串<br>1.考虑符号和数字的分离、判断输入是否正确<br>2.采用栈或者队列来进行运算<br>综上所述:较为复杂！！！</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用getchar()直接输入字符<br>1.一个一个字符输入，故要进行分类计算(if),判断何时计算、何时停止<br>2.通过代码顺序实现类似栈的操作<br>可以一试！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/24.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心 : 在得到第二个运算符时，计算前一个运算符!!!</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    int num, num1, op;    char ch;    //用来计算最先输入的数    num = 0;//第一个数    num1 = 0;//第二个数    op = &#39;+&#39;;    do    {        ch = getchar();        if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        {        //将输入的字符12转换成数字12            num1 = num1 * 10 + (ch - &#39;0&#39;);        }        else        {        //计算前一个运算符!!!            if (op == &#39;+&#39;)            {                num = num + num1;            }            else if (op == &#39;-&#39;)            {                num = num - num1;            }            else if (op == &#39;*&#39;)            {                num = num * num1;            }            else if (op == &#39;/&#39;)            {                num = num / num1;            }            else            {                printf(&quot;错误的运算符：%c&quot;, op);                exit(0);            }         //不得不说...神奇         op = ch;         //初始化         num1 = 0;        }    }while (ch != &#39;=&#39;);    printf(&quot;%d&quot;, num);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T1</title>
    <link href="/2020/04/10/CorrectionT1/"/>
    <url>/2020/04/10/CorrectionT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T1"><a href="#C语言改错T1" class="headerlink" title="C语言改错T1"></a>C语言改错T1</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br>2.严格根据题目约束条件、<strong>理论结合实际</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/23.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/23.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int main(){    char str1[N],str2[N];    int i,j;    printf(&quot;\n输入字符串：&quot;  );    gets(str1);    i=j=0;    for(i=0;str1[i]!=&#39;\0&#39;;i++)    {    //什么叫元音字母！！！        if(str1[i]==&#39;e&#39;||str1[i]==&#39;o&#39;||str1[i]==&#39;a&#39;||str1[i]==&#39;i&#39;||str1[i]==&#39;u&#39;)        {            str2[j]=str1[i];            j++;        }    }    str2[j]=&#39;\0&#39;;    //还要输出这个！！！    printf(&quot;%s&quot;,str1);    printf(&quot;\n字符串中的元音字母是%s&quot;,str2);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用网站</title>
    <link href="/2020/04/10/web1.0/"/>
    <url>/2020/04/10/web1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Practical-websites"><a href="#Practical-websites" class="headerlink" title="Practical websites"></a>Practical websites</h1><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="图片海报"><a href="#图片海报" class="headerlink" title="图片海报 :"></a>图片海报 :</h4><p>创客贴 : <a href="https://www.chuangkit.com/templatecenter" target="_blank" rel="noopener">https://www.chuangkit.com/templatecenter</a></p><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩 :"></a>图片压缩 :</h4><p>Recompressor : <a href="https://recompressor.com/" target="_blank" rel="noopener">https://recompressor.com/</a><br>Squoosh : <a href="https://squoosh.app/" target="_blank" rel="noopener">https://squoosh.app/</a><br>Tingpng : <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><h4 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历 :"></a>个人简历 :</h4><p>超级简历 :  <a href="https://www.wondercv.com/" target="_blank" rel="noopener">https://www.wondercv.com/</a></p><h4 id="写作"><a href="#写作" class="headerlink" title="写作 :"></a>写作 :</h4><p>Get写作 : <a href="https://getgetai.com/" target="_blank" rel="noopener">https://getgetai.com/</a><br>Markdown编辑器 : <a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a><br>英语写作 : <a href="http://www.1checker.com/" target="_blank" rel="noopener">http://www.1checker.com/</a></p><h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图 :"></a>绘图 :</h4><p>Processon 支持流程图、思维导图\UML、网络拓扑图、组织结构图等 : <a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></p><h3 id="Study"><a href="#Study" class="headerlink" title="Study"></a>Study</h3><h4 id="论文"><a href="#论文" class="headerlink" title="论文 :"></a>论文 :</h4><p>Communications of the ACM : <a href="https://cacm.acm.org/" target="_blank" rel="noopener">https://cacm.acm.org/</a><br>中国知网 : <a href="https://www.cnki.net/" target="_blank" rel="noopener">https://www.cnki.net/</a><br>笔杆查重 : <a href="https://www.bigan.net/" target="_blank" rel="noopener">https://www.bigan.net/</a><br>Paperpass : <a href="https://www.paperpass.com/" target="_blank" rel="noopener">https://www.paperpass.com/</a></p><h4 id="视频"><a href="#视频" class="headerlink" title="视频 :"></a>视频 :</h4><p>中国大学MOOC : <a href="https://www.icourse163.org/" target="_blank" rel="noopener">https://www.icourse163.org/</a><br>慕课网-程序员 :  <a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com/</a><br>网易云课堂 : <a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a><br>网易公开课 : <a href="https://open.163.com/" target="_blank" rel="noopener">https://open.163.com/</a><br>爱课程 : <a href="https://sso.icourses.cn" target="_blank" rel="noopener">https://sso.icourses.cn</a><br>Coursera : <a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org/</a><br>盗盗盗 : <a href="https://ctokey.com/" target="_blank" rel="noopener">https://ctokey.com/</a></p><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网:"></a>科学上网:</h4><p>DogCould : <a href="https://www.ggjs.xyz/" target="_blank" rel="noopener">https://www.ggjs.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>Gadgets</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马3.0</title>
    <link href="/2020/04/10/Chess3.0/"/>
    <url>/2020/04/10/Chess3.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马3-0"><a href="#跳跳马3-0" class="headerlink" title="跳跳马3.0"></a>跳跳马3.0</h1><hr><p>进一步对跳跳马2.0程序输入和输出界面的优化:<br>1.添加了一些界面提示语句<br>2.进行了代码局部优化</p><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现:"></a>1.代码实现:</h2><hr><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 64int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col,n;    printf(&quot;输入顶点数目:\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;n=%d\n&quot;,n);    for(i=0;i&lt;n;i++)    {        b[i]=-1;        c[i]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            a[i][j]=0;        }    }    do    {        printf(&quot;请输入对应的边(x y 1)(输入一半即可,-1表示结束):\n&quot;);        scanf(&quot;%d%d&quot;,&amp;i,&amp;j);        scanf(&quot;%d&quot;,&amp;a[i][j]);        //printf(&quot;(%d,%d)=%d\n&quot;,i,j,a[i][j]);        //printf(&quot;res=%d\n&quot;,res);        a[j][i]=a[i][j];    }while(i!=-1);    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;n)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,n))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;n-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=n);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;n;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>只是完成了最基本的可视化界面。<br>查询理论上可以继续优化:<br>主要思路:<br>1.可以尝试使用邻接表来存储，节约存储空间，但是回溯是一个问题。<br>2.可以尝试使用动态规划，理论上应该满足优化子结构和重叠子问题。<br>3.可以进一步优化输入输出，目标:上传图片，使其自动化处理棋盘和生成对应的图:</p><blockquote><p>Think:<br>图像处理、模式识别、数据可视化</p><h4 id="未完待续-2020-4-10—-gt"><a href="#未完待续-2020-4-10—-gt" class="headerlink" title="未完待续(2020.4.10—&gt;)"></a>未完待续(2020.4.10—&gt;)</h4></blockquote>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马2.0</title>
    <link href="/2020/04/09/Chess2.0/"/>
    <url>/2020/04/09/Chess2.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马2-0"><a href="#跳跳马2-0" class="headerlink" title="跳跳马2.0"></a>跳跳马2.0</h1><hr><p>依旧是采用跳跳马1.0的思想；将棋盘中的马与小兵抽象成结点，结点的可达关系作为对应结点的边。</p><h2 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1.解决方法:"></a>1.解决方法:</h2><hr><h3 id="1-1-主要思想"><a href="#1-1-主要思想" class="headerlink" title="1.1 主要思想:"></a>1.1 主要思想:</h3><p>2.0用邻接矩阵来存储图，使用BFS(Breadth First Search)策略，并且采用数组来存储上一步经过的结点，故只要不满足约束条件时，利用此数组即可回溯到上一结点</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现:"></a>2.代码实现:</h2><hr><p>可以正确执行！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 14int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col;    for(i=0;i&lt;N;i++)    {        b[i]=-1;        c[N]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            a[i][j]=0;        }    }    do    {        scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;a[i][j]);    }while(i!=-1);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;N)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,N))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;N-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=N);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;N;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>对应的界面还未完善，只是实现了最核心的功能<br>代码的时间复杂度和空间复杂度应该可以进一步优化。</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马1.0</title>
    <link href="/2020/04/08/Chess1.0/"/>
    <url>/2020/04/08/Chess1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马1-0"><a href="#跳跳马1-0" class="headerlink" title="跳跳马1.0"></a>跳跳马1.0</h1><h2 id="1-游戏介绍"><a href="#1-游戏介绍" class="headerlink" title="1.游戏介绍:"></a>1.游戏介绍:</h2><hr><p>根据国际象棋的规则和棋盘大小，并且遵守马的行走规则，使用马将棋盘中的所有小兵都吃完，即通关计分。<br>具体游戏界面如下图:<br><img src="/img/Chessimg/chess1.jpg" srcset="/img/loading.gif" alt=""></p><center>游戏界面 </center><h2 id="2-实际问题"><a href="#2-实际问题" class="headerlink" title="2.实际问题:"></a>2.实际问题:</h2><hr><p>随着通过的关卡越多，小兵的数量也越多，而马只要走错一步就直接结束游戏，因此在每一步都必须十分正确，所以有必要使用程序来辅助玩家选择最恰当的路径，进而通关</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法:"></a>3.解决方法:</h2><hr><h3 id="3-1使用到的相关知识"><a href="#3-1使用到的相关知识" class="headerlink" title="3.1使用到的相关知识:"></a>3.1使用到的相关知识:</h3><p>关键词 : 抽象、图、DFS、BFS、栈、回溯、哈密顿图</p><blockquote><p>《离散数学引论》:<br>哈密顿图 : 存在一条哈密顿圈<br>哈密顿路 : 图中存在一条经过所有节点并且不重复的路</p><h3 id="3-2-主要思想"><a href="#3-2-主要思想" class="headerlink" title="3.2 主要思想:"></a>3.2 主要思想:</h3><p>将马和小兵抽象成图上的结点，如果小兵与小兵之间或者小兵与马之间满足马的行走规则,则将其连线，从而形成一张图，进而转换成求图上的哈密顿路问题。<br>如下图:<br><img src="/img/Chessimg/chess2.jpg" srcset="/img/loading.gif" alt=""><br>寻找一条哈密顿路:<br><img src="/img/Chessimg/chess3.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现:"></a>4.代码实现:</h2><p>使用邻接矩阵来存储图，采用BFS策略来进行路径的选择，通过节点间的度的关系来进行回溯约束，并且采用栈来存储之前遍历过的结点。<br>``` </p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<stdlib.h></h1><p>//邻接矩阵结构<br>typedef int VertexType;<br>typedef int EdgeType;</p></blockquote><h1 id="define-MAX-20"><a href="#define-MAX-20" class="headerlink" title="define MAX 20"></a>define MAX 20</h1><h1 id="define-INFINITY-65535"><a href="#define-INFINITY-65535" class="headerlink" title="define INFINITY 65535"></a>define INFINITY 65535</h1><h1 id="define-TRUE-1"><a href="#define-TRUE-1" class="headerlink" title="define TRUE 1"></a>define TRUE 1</h1><h1 id="define-FALSE-0"><a href="#define-FALSE-0" class="headerlink" title="define FALSE 0"></a>define FALSE 0</h1><p>typedef int Boole;  //布尔类型 存储TRUE FALSE<br>Boole visited[MAX];    //访问标志数组<br>Boole Svisited[MAX];   //已经入栈标志<br>int Stack[MAX];//用来存放图的顶点<br>    int top=0;//栈顶<br>typedef struct<br>{<br>    VertexType vexs[MAX];   //顶点表<br>    EdgeType arc[MAX][MAX];   //邻接矩阵 可看作边表<br>    int numVertexes,numEdges;<br>    //int GraphType;  //图的类型  无向0,有向1<br>}MGraph;<br>//循环队列<br>typedef struct{<br>int data[10];<br>int rear,front;<br>}Quene,*pQueue;</p><p>void init(pQueue q){<br>    q-&gt;front=0;<br>    q-&gt;rear=0;<br>}</p><p>void destroyQueue(pQueue q){<br>    free(q);<br>    q=NULL;<br>}<br>void add(pQueue q,int x){<br>    if((q-&gt;rear+1)%10==q-&gt;front){<br>        printf(“overflow”);<br>        return ;<br>    }else{<br>        q-&gt;rear=(q-&gt;rear+1)%10;<br>        q-&gt;data[q-&gt;rear]=x;<br>        printf(“入队成功\n”);<br>    }<br>}<br>int  DeQueue(pQueue q){<br>    int e=0;<br>    if(q-&gt;front==q-&gt;rear){<br>        printf(“null”);<br>        return e;<br>    }else{<br>        q-&gt;front=(q-&gt;front+1)%10;<br>       // printf(“q-&gt;front=%d\n”,q-&gt;front);<br>        printf(“删除的元素是:%d\n”,q-&gt;data[q-&gt;front]);<br>        e=q-&gt;data[q-&gt;front];</p><pre><code>}return e;</code></pre><p>}</p><p>void traverseQuene(pQueue q){<br>    int i=q-&gt;front;<br>    while(i!=q-&gt;rear){<br>        i=(i+1)%10;<br>        printf(“%d “,q-&gt;data[i]);<br>    }<br>    printf(“\n”);<br>}</p><p>//队长度<br>int QueueLength(pQueue q){<br>    return (q-&gt;rear)-(q-&gt;front)+10%10;<br>}<br>//构造图   有向图和无向图<br>void create(MGraph *G)<br>{<br>    int i,j,k,w;<br>    printf(“请输入顶点数,边数:\n”);<br>    scanf(“%d,%d”,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<br>    fflush(stdin);<br>    for(i=0;i<G->numVertexes;i++)     //建立顶点表<br>    {<br>        //printf(“\n第%d个顶点”,i);<br>        //scanf(“%c”,&amp;G-&gt;vexs[i]);<br>        //getchar();<br>        G-&gt;vexs[i]=i;<br>    }</p><pre><code>for(i=0;i&lt;G-&gt;numVertexes;i++)   //矩阵初始化    for(j=0;j&lt;G-&gt;numVertexes;j++)        G-&gt;arc[i][j]=INFINITY;for(k=0;k&lt;G-&gt;numEdges;k++){    printf(&quot;输入边（Vi,Vj）的上下标i,j：&quot;);    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    G-&gt;arc[i][j]=1;    //if(G-&gt;GraphType==0)      //此时为无向图   有向图与无向的区别就只是这一行代码的有无    G-&gt;arc[j][i]=G-&gt;arc[i][j];}</code></pre><p>}</p><p>void Output(MGraph *G)     //输出邻接矩阵<br>{<br>    int i,j,count=0;<br>    for(i=0;i<G->numVertexes;i++)<br>        printf(“\t%d”,G-&gt;vexs[i]);<br>    printf(“\n”);<br>    for(i=0;i<G->numVertexes;i++)<br>    {<br>        printf(“%4d”,G-&gt;vexs[i]);<br>        for(j=0;j<G->numVertexes;j++)<br>        {</p><pre><code>            printf(&quot;\t%d&quot;,G-&gt;arc[i][j]);            count++;            if(count%G-&gt;numVertexes==0)            printf(&quot;\n&quot;);    }}</code></pre><p> }</p><p>/*<br>//一次遍历全部顶点<br>void OneS(MGraph G){<br>    int i,j;<br>    //所有点标记为新点<br>    for(i=0;i&lt;G.numVertexes;i++){<br>        visited[i]=FALSE;<br>        Svisited[i]=FALSE;<br>        Stack[i]=-1;<br>    }<br>    Stack[0]=G.vexs[0];<br>    visited[0]=TRUE;//已经在栈中<br>    top=0;<br>    while(top!=G.numVertexes-1){<br>        for(i=1;i&lt;G.numVertexes;i++){<br>            printf(“i=%d G.arc[Stack[top]][i]=%d !visited[i]=%d !Svisited[i]=%d\n “,i,G.arc[Stack[top]][i],!visited[i],!Svisited[i]);<br>            if(G.arc[Stack[top]][i]!=INFINITY&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){//找邻接点<br>                PrintStack();<br>                top++;<br>                Stack[top]=G.vexs[i];<br>                visited[i]=TRUE;//此点已经入栈<br>            }<br>        }</p><pre><code>    if(i==G.numVertexes){        //退栈,表示此点不可达        Svisited[Stack[top]]=TRUE;        visited[Stack[top]]=FALSE;        Queue[rear]=Stack[top];//入队        rear++;        Stack[top]=-1;        top--;    }    printf(&quot;top=%d,G.numVertexes-1=%d\n&quot;,top,G.numVertexes-1);    if(rear-front==2){//出队        Svisited[Queue[front]]=FALSE;        front++;    }    printf(&quot;rear=%d\n&quot;,rear);}</code></pre><p>}*/</p><p>//打印栈<br>void PrintStack(){<br>    for(int i=0;i&lt;=top;i++){<br>        printf(“%d-&gt;”,Stack[i]);<br>    }<br>    printf(“&lt;\n”);<br>}</p><p>void PrintQueue(Queue Q){<br>    for(int i=0;i&lt;=top;i++){<br>            printf(“%d-&gt;”,Q-&gt;data[i]);<br>        }<br>        printf(“&lt;\n”);<br>}</p><p>//返回结点n的度<br>int NodeDu(MGraph G,int n){<br>    int count=0;<br>    for(int i=0;i&lt;G.numVertexes;i++){<br>        if(G.arc[n][i]==1){<br>            count ++;<br>        }<br>    }<br>    return count;<br>}<br>void PrintNodeDu(MGraph G){<br>    for(int i=0;i&lt;G.numVertexes;i++){<br>        printf(“顶点%d的度:%d”,i,NodeDu(G,i));<br>    }<br>}<br>void OnceSearch(MGraph G){<br>    int i,e;<br>    pQueue q=(pQueue)malloc(sizeof(Quene));//用来存放已经出栈的顶点<br>    //打印顶点<br>    for(i=0;i&lt;G.numVertexes;i++){<br>        printf(“顶点:%d\n”,G.vexs[i]);<br>        visited[i]=FALSE;//标记所有顶点都未被访问<br>        Svisited[i]=FALSE;//标记所有顶点都未被退栈<br>    }<br>    //栈,队初始化<br>    init(q);<br>    Stack[top]=G.vexs[0];<br>    //如果栈里元素=顶点数,则找到路径<br>    int Stop=0;//判断栈顶第二元素是否变化<br>    while((top+1)!=G.numVertexes){<br>        //找相邻结点<br>        for(i=1;i&lt;G.numVertexes;i++){<br>            if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){<br>                //记录栈顶第二元素</p><pre><code>            top++;            Stack[top]=G.vexs[i];            visited[i]=TRUE;        }    }     Stop=Stack[top-1];    printf(&quot;second STop=%d\n&quot;,Stop);     PrintStack();    //如果遍历所有相邻结点都没有找到合适结点,则退栈入队重新再找    if(0&lt;(top)&amp;&amp;(top+1)!=G.numVertexes){        //如果栈顶第二元素变化,说明已经退出第二层,则需要出队        add(q,Stack[top]);        Svisited[Stack[top]]=TRUE;        visited[Stack[top]]=FALSE;        printf(&quot;退栈结点:%d\n&quot;,Stack[top]);        top--;        traverseQuene(q);//打印队列        printf(&quot;此时队列元素个数为:%d\n&quot;,QueueLength(q));        printf(&quot;此时栈顶元素Stack[%d]=%d的度为:%d\n&quot;,top,Stack[top],NodeDu(G,Stack[top]));        if(QueueLength(q)==NodeDu(G,Stack[top])){            printf(&quot;进入删除队列:&quot;);            for(i=0;i&lt;NodeDu(G,Stack[top])-1;i++){                e=DeQueue(q);                Svisited[e]=FALSE;                visited[e]=FALSE;            }            /*add(q,Stack[top]);            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            printf(&quot;退栈结点:%d\n&quot;,Stack[top]);            top--;*/        }        printf(&quot;打印队列:&quot;);            traverseQuene(q);//打印队列            printf(&quot;此时可入栈结点:&quot;);            for(i=0;i&lt;G.numVertexes;i++){                if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                    printf(&quot; %d &quot;,G.vexs[i]);                }            }        printf(&quot;\ntop=%d\n&quot;,top);    }}</code></pre><p>}</p><p>int main()<br>{<br>    MGraph G;<br>    int i,j;<br>    //printf(“输入生成图的类型(无向图0/有向图1)：”);<br>    //scanf(“%d”,&amp;G.GraphType);<br>    create(&amp;G);<br>    printf(“邻接矩阵数据如下：\n”);<br>    Output(&amp;G);<br>    printf(“\n”);<br>    //PrintNodeDu(G);<br>    OnceSearch(G);<br>    printf(“\n图遍历完毕\n”);<br>    PrintStack();<br>    return 0;<br>}</p><p>```</p><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>代码功能没有实现，应该是回溯栈的选择和约束条件的问题，以后有机会在实现~</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TestMarkdown</title>
    <link href="/2020/04/07/first/"/>
    <url>/2020/04/07/first/</url>
    
    <content type="html"><![CDATA[<h1 id="这是H1标题"><a href="#这是H1标题" class="headerlink" title="这是H1标题"></a>这是H1标题</h1><p>&nbsp;&nbsp;如何缩进,这是空格….<br>以下可写内容<br>分割线</p><hr><h2 id="这是H2标题"><a href="#这是H2标题" class="headerlink" title="这是H2标题"></a>这是H2标题</h2><p>直接写？？？</p><h3 id="这是H3标题-故标题以此类推"><a href="#这是H3标题-故标题以此类推" class="headerlink" title="这是H3标题(故标题以此类推)"></a>这是H3标题(故标题以此类推)</h3><pre><code>$ hexo new &quot;My New Post&quot;代码部分这样写?</code></pre><p>添加链接<br>More info: <a href="https://github.com/YinGuoX" target="_blank" rel="noopener">MyGitHub</a><br>添加图片<br><img src="/img/avatar.png" srcset="/img/loading.gif" alt=""></p><center>如何居中</center><p>记得&lt;/center&gt;后要空一行</p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
      <category>Markdown基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
