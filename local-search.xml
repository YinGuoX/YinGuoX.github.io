<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Inspiration1.0</title>
    <link href="/2020/04/15/Whimsy1/"/>
    <url>/2020/04/15/Whimsy1/</url>
    
    <content type="html"><![CDATA[<h1 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h1><p><strong>This is my idea,I hope one day i can fulfil it.</strong></p><hr><h2 id="Project-And-Description"><a href="#Project-And-Description" class="headerlink" title="Project And Description"></a>Project And Description</h2><p>过年前后金价会上升 : 可建立对应信息库+求解最大子序列<br>背诵提醒 : 根据记忆曲线(艾宾浩斯遗忘曲线)提醒用户背诵对应内容<br>云网盘 : 通过云服务器构建一个类似属于自己的网盘<br>高校图表 : 面对高考生的高校报考信息推荐，Python爬虫+大数据(高校分数线+报录比)+Python可视化(生成对应的报表+不同维度)<br>彩虹屁生成器 : 花式夸人+英语夸人，自然语言处理</p>]]></content>
    
    
    <categories>
      
      <category>Whimsy</category>
      
      <category>Procject</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Project</tag>
      
      <tag>Inspiration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T5</title>
    <link href="/2020/04/15/CprogrammingT5/"/>
    <url>/2020/04/15/CprogrammingT5/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T5"><a href="#C语言编程T5" class="headerlink" title="C语言编程T5"></a>C语言编程T5</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>找规律，一一列举即可<br><strong>注:是否满足所有情况!!!</strong><br>要从最小值开始列举<br>不然有可能运算不了全部解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/60.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找最小、才能求解全部情况</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100//要从最小的开始计算int IsInArray(int a[],int n,int x);void ClearArray(int a[],int n,int x);int GetMinArray(int a[],int n);int main(){    int i,n,a[N]={-1},change=0,j,m=0;    printf(&quot;Input n:&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;Input card numbers:&quot;);    for(i=0;i&lt;n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);    }    for(i=0;i&lt;n;i++)    {        m=GetMinArray(a,n);        //printf(&quot;a[m]=%d\n&quot;,m);        if(m!=-1&amp;&amp;IsInArray(a,n,m+1)&amp;&amp;IsInArray(a,n,m+2))        {            ClearArray(a,n,m+2);            ClearArray(a,n,m+1);            ClearArray(a,n,m);            /*for(j=0;j&lt;n;j++)            {                printf(&quot;%d &quot;,a[j]);            }            printf(&quot;\n&quot;);*/            change++;        }    }    printf(&quot;Exchanged:%d\n&quot;,change);    return 0;}int IsInArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            return 1;        }    }    return 0;}void ClearArray(int a[],int n,int x){    int i;    for(i=0;i&lt;n;i++)    {        if(a[i]==x)        {            a[i]=-1;            break;        }    }}int GetMinArray(int a[],int n){    int i,j,min=-1;    for(i=0;i&lt;n;i++)    {        if(a[i]!=-1)        {            min=a[i];           // printf(&quot;min=%d\n&quot;,min);            for(j=0;j&lt;n;j++)            {                if(a[j]!=-1&amp;&amp;min&gt;a[j])                {                    min=a[j];                }            }        }        else        {            i++;        }    }    return min;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T4(妙)</title>
    <link href="/2020/04/13/CprogrammingT4/"/>
    <url>/2020/04/13/CprogrammingT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T4-妙"><a href="#C语言编程T4-妙" class="headerlink" title="C语言编程T4(妙)"></a>C语言编程T4(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>知规律，且有限，可迭代暴力破解</p><h3 id="思路一-回溯"><a href="#思路一-回溯" class="headerlink" title="思路一:回溯"></a>思路一:回溯</h3><p>只要将2、3、4、5放在不同位置,满足约束条件即可<br>又因2,3,4,5有规律,可递增尝试，递减回溯<br>所以找到回溯判定条件以及相应操作即可<br>此法较复杂</p><h3 id="思路二-穷举-正向思维"><a href="#思路二-穷举-正向思维" class="headerlink" title="思路二:穷举(正向思维)"></a>思路二:穷举(正向思维)</h3><p>因为只要将2、3、4、5放在四个不同位置，且其有规律<br>故采用四层或者三层for循环即可遍历所有可能解<br>所有只要输出满足约束条件的解即可<br><img src="/img/c_correction/45.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>何时回溯、何时穷举！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//强行穷举!!!#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6int main(){    int i, j, k, m, n, num;    int a[N];    a[0] = 1;    a[5] = 6;    num = 0;    printf(&quot;The possible table satisfied above conditions are:\n&quot;);    for (i = 2; i &lt;= 5; i++)        for (j = 2; j &lt;= 5; j++)            for (n = 2; n &lt;= 5; n++)                for (m = 2; m &lt;= 5; m++)                {                    a[1] = i;                    a[2] = j;                    a[3] = n;                    a[4] = m;                    if (a[2] &gt; a[1] &amp;&amp; a[4] &gt; a[3] &amp;&amp; a[4] &gt; a[1] &amp;&amp; a[1] != a[3] &amp;&amp; a[2] != a[3] &amp;&amp; a[2] != a[4])                    {                        num++;                        printf(&quot;\nNo.:%d&quot;, num);                        for (k = 0; k &lt; 6; k++)                        {                            if (k % 3 == 0)                                printf(&quot;\n&quot;);                            printf(&quot;%3d&quot;, a[k]);                        }                    }                }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T3(妙)</title>
    <link href="/2020/04/13/CprogrammingT3/"/>
    <url>/2020/04/13/CprogrammingT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T3-妙"><a href="#C语言编程T3-妙" class="headerlink" title="C语言编程T3(妙)"></a>C语言编程T3(妙)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一-暴力破解-正向思维"><a href="#思路一-暴力破解-正向思维" class="headerlink" title="思路一:暴力破解(正向思维)"></a>思路一:暴力破解(正向思维)</h3><p>不断尝试各种数字,逐一尝试<br>但是由于n不确定,所以不知道要嵌套多少for和准备多少临时变量<br>故不可使用穷举法</p><h3 id="思路二-回溯-逆向思维"><a href="#思路二-回溯-逆向思维" class="headerlink" title="思路二:回溯(逆向思维)"></a>思路二:回溯(逆向思维)</h3><p><strong>从后往前观察思考，找到其规律</strong><br>采用数组,从后往前,逐一尝试,不符或者满足则采用不同的回溯，直至得出所有解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/42.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:<br>找规律 : 正向、逆向、解中有规律</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 10int main(){    int i[N];    int sum,n,total,k,flag=0,count=0;    printf(&quot;Please enter requried terms (&lt;=10):&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf( &quot;                             their sum:&quot;);    scanf(&quot;%d&quot;,&amp;total);    sum=0;    k=n;    //从后往前推导    i[n]=1;    printf(&quot;There are following possible series:\n&quot;);    while(1)    {        if(sum+i[k]&lt;total)        {            if(k&lt;=1)            {                i[1]=total-sum;                flag=1;            }            else            {                sum+=i[k];                k--;                //从最小值开始往前赋值                i[k]=i[k+1];                continue;                //继续while循环判断            }        }        //sum在中间已经大于可total        else if(sum+i[k]&gt;total||k!=1)        {            //想办法回溯            //减去上一个sum加的i[k]            sum-=i[++k];            flag=0;        }        else//sum+i[k]==total&amp;&amp;k==1        {            flag=1;        }        if(flag)        {             printf(&quot;[%d]:&quot;,++count);            for(flag=1;flag&lt;=n;++flag)                printf(&quot;%d&quot;,i[flag]);            printf(&quot;\n&quot;);        }        //判断i[n]是否已经变化到极致        if(++k&gt;n)        {            break;        }        //往后回溯        sum-=i[k];        //不断试探        i[k]++;    }    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T4</title>
    <link href="/2020/04/13/CorrectionT4/"/>
    <url>/2020/04/13/CorrectionT4/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T4"><a href="#C语言改错T4" class="headerlink" title="C语言改错T4"></a>C语言改错T4</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>指针数组要初始化<br><strong>指针都要初始化</strong><br>认真检查代码正确性:for(里面),数组交换位置,while();</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/39.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include  &lt;stdio.h&gt;#include &lt;string.h&gt;#define   MAX_LEN  10#define   N         150void SortString(char *ptr[], int n);main(){    int    i, n;    char   str[N][MAX_LEN],*pStr[N];    printf(&quot;How many countries?\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    getchar();    printf(&quot;Input their names:\n&quot;);    for (i=0; i&lt;n; i++)    {        pStr[i]=str[i];        gets(pStr[i]);        //printf(&quot;sr=%s\n&quot;,pStr[i]);    }    SortString(pStr,n);    printf(&quot;Sorted results:\n&quot;);    for (i=0; i&lt;n; i++)    {        puts(pStr[i]);    }}void SortString(char *ptr[], int n){    int    i, j;    char  *temp;    for (i=0; i&lt;n-1; i++)    {        for (j = i+1; j&lt;n; j++)        {            if (strcmp(ptr[i],ptr[j])&gt;0)            {                temp = ptr[i];                ptr[i] = ptr[j];                ptr[j] = temp;            }        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T2</title>
    <link href="/2020/04/12/CprogrammingT2/"/>
    <url>/2020/04/12/CprogrammingT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T2"><a href="#C语言编程T2" class="headerlink" title="C语言编程T2"></a>C语言编程T2</h1><p>##思路:</p><h3 id="判断素数可以通过sqrt-或者x-2来降低循环次数"><a href="#判断素数可以通过sqrt-或者x-2来降低循环次数" class="headerlink" title="判断素数可以通过sqrt()或者x/2来降低循环次数"></a>判断素数可以通过sqrt()或者x/2来降低循环次数</h3><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用long long或者unsigned long 来存储2的i次幂<br>计算2的i次幂可以迭代计算,节省时间</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用double来存储2的i次幂<br>注 :</p><ol><li><p>pow()返回的double型，所以将其转换为int型时容易有精度误差，容易出错！！！<br>所以常使用while循环迭代计算</p></li><li><p>浮点型(float,double)不可以进行取余运算<br>故判断是否整除可以通过整型的除法特性计算(1/2==0)<br>即:x/i == (long long)(x/i)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/33.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>切记 : pow()的精度误差，一般在int型中不用！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int IsPrime(double x);int main(){  int i,count=0,n;  double s=0;  printf(&quot;Input n:\n&quot;);  scanf(&quot;%d&quot;,&amp;n);  for(i=2;i&lt;=n;i++)  {      s=pow(2,i)-1;      if(IsPrime(s)==1)      {          printf(&quot;2^%d-1=%.0f\n&quot;,i,s);          count++;      }  }  printf(&quot;count=%d\n&quot;,count);  return 0;}int IsPrime(double x){  int i;  for(i=2;i&lt;sqrt(x);i++)  {      if(x/i == (long long)(x/i))      {          return 0;      }  }  return 1;}</code></pre></li></ol><p>```</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T3</title>
    <link href="/2020/04/11/CorrectionT3/"/>
    <url>/2020/04/11/CorrectionT3/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T3"><a href="#C语言改错T3" class="headerlink" title="C语言改错T3"></a>C语言改错T3</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><h3 id="分清"><a href="#分清" class="headerlink" title="分清:"></a>分清:</h3><p>1.指针数组:  int *p[4]<br><strong>常用于字符串交换,因为相比strcpy()更加节省时间和空间</strong><br><strong>故使用指针数组进行交换效率更高索引技术、索引排序</strong></p><blockquote><p>函数中使用:<br>void Fun(int *p[M]);<br>Fun(p);</p></blockquote><p>2.二维数组的 行指针 :  int (*p)[4] </p><blockquote><p>p[i]==*(p+i):也就是p[i]的地址！！！<br>p[i][j] == *(p[i]+j) == *(*(p+i)+j) == (*(a+i))[j]<br>&amp;p[i][j] == p[i]+j == *(p+i)+j<br>函数中使用:<br>void Fun(int (*p)[M]);<br>Fun(p);//p == p[0] == p[0]的地址</p></blockquote><p>3.二维数组的列指针 :  int *p; p=*a</p><blockquote><p>p=*a &lt;==&gt; p=a[0] &lt;==&gt; p=&amp;a[0][0]<br>a[i][j]=*(p+i*n+j)<br>&amp;a[i][j]=p+i*n+j<br>函数中使用:<br>void Fun(int *p);<br>Fun(*p);</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/28.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心:指针数组的妙用！！！</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;void Input(char *p[], int n);void Sort(char *p[], int n);void Print(char *p[], int n);int main(){                    char str[20][40];    char *pstr[20];    int i, n;    printf(&quot;Input n(n&lt;=20):\n&quot;);    scanf(&quot;%d&quot;, &amp;n);    //注意要清空缓冲区里的空格    getchar();    for (i = 0; i &lt; n; i++)    {                  //指针数组要初始化        pstr[i] = str[i];           //2    }    Input(pstr, n);    Sort(pstr, n);    printf(&quot;Results:\n&quot;);    Print(pstr, n);    return 0;}                void Input(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        gets(p[i]);    }}                void Sort(char *p[], int n){                    char *t;                              //1    int i, j;    for (i = 0; i &lt; n - 1; i++)    {                        //注:j=i+1而不是1        for (j = i + 1; j &lt; n; j++)        {                            if (strcmp(p[j], p[i]) &lt; 0)    //2            {                       //直接用指针数组来简化strcpy()                t = p[i];                p[i] = p[j];                p[j] = t;            }        }    }}                void Print(char *p[], int n){                    int i;    for (i = 0; i &lt; n; i++)    {                        printf(&quot;%s\n&quot;, p[i]);    }}               </code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T2</title>
    <link href="/2020/04/11/CorrectionT2/"/>
    <url>/2020/04/11/CorrectionT2/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T2"><a href="#C语言改错T2" class="headerlink" title="C语言改错T2"></a>C语言改错T2</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br><strong>换行、空格到底要不要???</strong>(没有特殊提示应该不用吧~now)</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/27.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>多了一个换行~</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int mon[][13]={    {0,31,28,31,30,31,30,31,31,30,31,30,31},    {0,31,29,31,30,31,30,31,31,30,31,30,31},};int  DayofYear(int year, int month, int day);void  MonthDay(int year, int yearDay, int *pMonth, int *pDay);int main(){    int choice,year,month,day,yearday,pmonth,pday;    printf(&quot;1. year/month/day -&gt; yearDay\n&quot;);    printf(&quot;2. yearDay -&gt; year/month/day\n&quot;);    printf(&quot;3. Exit\n&quot;);    //这里不用换行了！！！    printf(&quot;Please enter your choice:&quot;);    scanf(&quot;%d&quot;,&amp;choice);    switch(choice)    {    case 1:        printf(&quot;Please enter year, month, day:&quot;);        scanf(&quot;%d,%d,%d&quot;,&amp;year,&amp;month,&amp;day);        yearday=DayofYear(year,month,day);        printf(&quot;yearDay = %d\n&quot;,yearday);        break;    case 2:        printf(&quot;Please enter year, yearDay:&quot;);        scanf(&quot;%d,%d&quot;,&amp;year,&amp;yearday);        MonthDay(year,yearday,&amp;pmonth,&amp;pday);        printf(&quot;month = %d,day = %d\n&quot;,pmonth,pday);        break;    case 3:        return 0;    }    return 0;}int  DayofYear(int year, int month, int day){    int i,leap,d=day;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    for(i=0;i&lt;month;i++)    {        d+=mon[leap][i];    }    return d;}void  MonthDay(int year, int yearDay, int *pMonth, int *pDay){    int i=0,leap;    leap=year%100!=0&amp;&amp;year%4==0||year%400==0;    while(1)    {        yearDay-=mon[leap][i];        i++;        if(yearDay&lt;mon[leap][i])        {            break;        }    }    *pMonth=i;    *pDay=yearDay;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言编程T1</title>
    <link href="/2020/04/11/CprogrammingT1/"/>
    <url>/2020/04/11/CprogrammingT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言编程T1"><a href="#C语言编程T1" class="headerlink" title="C语言编程T1"></a>C语言编程T1</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><p>采用gets()/scanf()直接输入字符串<br>1.考虑符号和数字的分离、判断输入是否正确<br>2.采用栈或者队列来进行运算<br>综上所述:较为复杂！！！</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>采用getchar()直接输入字符<br>1.一个一个字符输入，故要进行分类计算(if),判断何时计算、何时停止<br>2.通过代码顺序实现类似栈的操作<br>可以一试！！！</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/24.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><p>核心 : 在得到第二个运算符时，计算前一个运算符!!!</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    int num, num1, op;    char ch;    //用来计算最先输入的数    num = 0;//第一个数    num1 = 0;//第二个数    op = &#39;+&#39;;    do    {        ch = getchar();        if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        {        //将输入的字符12转换成数字12            num1 = num1 * 10 + (ch - &#39;0&#39;);        }        else        {        //计算前一个运算符!!!            if (op == &#39;+&#39;)            {                num = num + num1;            }            else if (op == &#39;-&#39;)            {                num = num - num1;            }            else if (op == &#39;*&#39;)            {                num = num * num1;            }            else if (op == &#39;/&#39;)            {                num = num / num1;            }            else            {                printf(&quot;错误的运算符：%c&quot;, op);                exit(0);            }         //不得不说...神奇         op = ch;         //初始化         num1 = 0;        }    }while (ch != &#39;=&#39;);    printf(&quot;%d&quot;, num);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Cprogramming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
      <tag>Cprogramming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言改错T1</title>
    <link href="/2020/04/10/CorrectionT1/"/>
    <url>/2020/04/10/CorrectionT1/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言改错T1"><a href="#C语言改错T1" class="headerlink" title="C语言改错T1"></a>C语言改错T1</h1><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点:"></a>易错点:</h2><p>1.认真核对<strong>输入</strong>、<strong>输出</strong>格式<br>2.严格根据题目约束条件、<strong>理论结合实际</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><img src="/img/c_correction/23.1.png" srcset="/img/loading.gif" alt=""><br><img src="/img/c_correction/23.png" srcset="/img/loading.gif" alt=""></p><h2 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int main(){    char str1[N],str2[N];    int i,j;    printf(&quot;\n输入字符串：&quot;  );    gets(str1);    i=j=0;    for(i=0;str1[i]!=&#39;\0&#39;;i++)    {    //什么叫元音字母！！！        if(str1[i]==&#39;e&#39;||str1[i]==&#39;o&#39;||str1[i]==&#39;a&#39;||str1[i]==&#39;i&#39;||str1[i]==&#39;u&#39;)        {            str2[j]=str1[i];            j++;        }    }    str2[j]=&#39;\0&#39;;    //还要输出这个！！！    printf(&quot;%s&quot;,str1);    printf(&quot;\n字符串中的元音字母是%s&quot;,str2);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>C</category>
      
      <category>Correction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correction</tag>
      
      <tag>C</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用网站</title>
    <link href="/2020/04/10/web1.0/"/>
    <url>/2020/04/10/web1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Practical-websites"><a href="#Practical-websites" class="headerlink" title="Practical websites"></a>Practical websites</h1><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="图片海报"><a href="#图片海报" class="headerlink" title="图片海报 :"></a>图片海报 :</h4><p>创客贴 : <a href="https://www.chuangkit.com/templatecenter" target="_blank" rel="noopener">https://www.chuangkit.com/templatecenter</a></p><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩 :"></a>图片压缩 :</h4><p>Recompressor : <a href="https://recompressor.com/" target="_blank" rel="noopener">https://recompressor.com/</a><br>Squoosh : <a href="https://squoosh.app/" target="_blank" rel="noopener">https://squoosh.app/</a><br>Tingpng : <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><h4 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历 :"></a>个人简历 :</h4><p>超级简历 :  <a href="https://www.wondercv.com/" target="_blank" rel="noopener">https://www.wondercv.com/</a></p><h4 id="写作"><a href="#写作" class="headerlink" title="写作 :"></a>写作 :</h4><p>Get写作 : <a href="https://getgetai.com/" target="_blank" rel="noopener">https://getgetai.com/</a><br>Markdown编辑器 : <a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a><br>英语写作 : <a href="http://www.1checker.com/" target="_blank" rel="noopener">http://www.1checker.com/</a></p><h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图 :"></a>绘图 :</h4><p>Processon 支持流程图、思维导图\UML、网络拓扑图、组织结构图等 : <a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></p><h3 id="Study"><a href="#Study" class="headerlink" title="Study"></a>Study</h3><h4 id="论文"><a href="#论文" class="headerlink" title="论文 :"></a>论文 :</h4><p>Communications of the ACM : <a href="https://cacm.acm.org/" target="_blank" rel="noopener">https://cacm.acm.org/</a><br>中国知网 : <a href="https://www.cnki.net/" target="_blank" rel="noopener">https://www.cnki.net/</a><br>笔杆查重 : <a href="https://www.bigan.net/" target="_blank" rel="noopener">https://www.bigan.net/</a><br>Paperpass : <a href="https://www.paperpass.com/" target="_blank" rel="noopener">https://www.paperpass.com/</a></p><h4 id="视频"><a href="#视频" class="headerlink" title="视频 :"></a>视频 :</h4><p>中国大学MOOC : <a href="https://www.icourse163.org/" target="_blank" rel="noopener">https://www.icourse163.org/</a><br>慕课网-程序员 :  <a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com/</a><br>网易云课堂 : <a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a><br>网易公开课 : <a href="https://open.163.com/" target="_blank" rel="noopener">https://open.163.com/</a><br>爱课程 : <a href="https://sso.icourses.cn" target="_blank" rel="noopener">https://sso.icourses.cn</a><br>Coursera : <a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org/</a><br>盗盗盗 : <a href="https://ctokey.com/" target="_blank" rel="noopener">https://ctokey.com/</a></p><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网:"></a>科学上网:</h4><p>DogCould : <a href="https://www.ggjs.xyz/" target="_blank" rel="noopener">https://www.ggjs.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>Gadgets</category>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马3.0</title>
    <link href="/2020/04/10/Chess3.0/"/>
    <url>/2020/04/10/Chess3.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马3-0"><a href="#跳跳马3-0" class="headerlink" title="跳跳马3.0"></a>跳跳马3.0</h1><hr><p>进一步对跳跳马2.0程序输入和输出界面的优化:<br>1.添加了一些界面提示语句<br>2.进行了代码局部优化</p><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现:"></a>1.代码实现:</h2><hr><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 64int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col,n;    printf(&quot;输入顶点数目:\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;n=%d\n&quot;,n);    for(i=0;i&lt;n;i++)    {        b[i]=-1;        c[i]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            a[i][j]=0;        }    }    do    {        printf(&quot;请输入对应的边(x y 1)(输入一半即可,-1表示结束):\n&quot;);        scanf(&quot;%d%d&quot;,&amp;i,&amp;j);        scanf(&quot;%d&quot;,&amp;a[i][j]);        //printf(&quot;(%d,%d)=%d\n&quot;,i,j,a[i][j]);        //printf(&quot;res=%d\n&quot;,res);        a[j][i]=a[i][j];    }while(i!=-1);    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;n;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;n)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,n))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;n-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=n);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;n;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>只是完成了最基本的可视化界面。<br>查询理论上可以继续优化:<br>主要思路:<br>1.可以尝试使用邻接表来存储，节约存储空间，但是回溯是一个问题。<br>2.可以尝试使用动态规划，理论上应该满足优化子结构和重叠子问题。<br>3.可以进一步优化输入输出，目标:上传图片，使其自动化处理棋盘和生成对应的图:</p><blockquote><p>Think:<br>图像处理、模式识别、数据可视化</p></blockquote><h4 id="未完待续-2020-4-10–-gt"><a href="#未完待续-2020-4-10–-gt" class="headerlink" title="未完待续(2020.4.10–&gt;)"></a>未完待续(2020.4.10–&gt;)</h4>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马2.0</title>
    <link href="/2020/04/09/Chess2.0/"/>
    <url>/2020/04/09/Chess2.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马2-0"><a href="#跳跳马2-0" class="headerlink" title="跳跳马2.0"></a>跳跳马2.0</h1><hr><p>依旧是采用跳跳马1.0的思想；将棋盘中的马与小兵抽象成结点，结点的可达关系作为对应结点的边。</p><h2 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1.解决方法:"></a>1.解决方法:</h2><hr><h3 id="1-1-主要思想"><a href="#1-1-主要思想" class="headerlink" title="1.1 主要思想:"></a>1.1 主要思想:</h3><p>2.0用邻接矩阵来存储图，使用BFS(Breadth First Search)策略，并且采用数组来存储上一步经过的结点，故只要不满足约束条件时，利用此数组即可回溯到上一结点</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现:"></a>2.代码实现:</h2><hr><p>可以正确执行！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 14int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col;    for(i=0;i&lt;N;i++)    {        b[i]=-1;        c[N]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            a[i][j]=0;        }    }    do    {        scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;a[i][j]);    }while(i!=-1);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;N)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,N))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;N-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=N);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;N;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>对应的界面还未完善，只是实现了最核心的功能<br>代码的时间复杂度和空间复杂度应该可以进一步优化。</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马1.0</title>
    <link href="/2020/04/08/Chess1.0/"/>
    <url>/2020/04/08/Chess1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马1-0"><a href="#跳跳马1-0" class="headerlink" title="跳跳马1.0"></a>跳跳马1.0</h1><h2 id="1-游戏介绍"><a href="#1-游戏介绍" class="headerlink" title="1.游戏介绍:"></a>1.游戏介绍:</h2><hr><p>根据国际象棋的规则和棋盘大小，并且遵守马的行走规则，使用马将棋盘中的所有小兵都吃完，即通关计分。<br>具体游戏界面如下图:<br><img src="/img/Chessimg/chess1.jpg" srcset="/img/loading.gif" alt=""></p><center>游戏界面 </center><h2 id="2-实际问题"><a href="#2-实际问题" class="headerlink" title="2.实际问题:"></a>2.实际问题:</h2><hr><p>随着通过的关卡越多，小兵的数量也越多，而马只要走错一步就直接结束游戏，因此在每一步都必须十分正确，所以有必要使用程序来辅助玩家选择最恰当的路径，进而通关</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法:"></a>3.解决方法:</h2><hr><h3 id="3-1使用到的相关知识"><a href="#3-1使用到的相关知识" class="headerlink" title="3.1使用到的相关知识:"></a>3.1使用到的相关知识:</h3><p>关键词 : 抽象、图、DFS、BFS、栈、回溯、哈密顿图</p><blockquote><p>《离散数学引论》:<br>哈密顿图 : 存在一条哈密顿圈<br>哈密顿路 : 图中存在一条经过所有节点并且不重复的路</p></blockquote><h3 id="3-2-主要思想"><a href="#3-2-主要思想" class="headerlink" title="3.2 主要思想:"></a>3.2 主要思想:</h3><p>将马和小兵抽象成图上的结点，如果小兵与小兵之间或者小兵与马之间满足马的行走规则,则将其连线，从而形成一张图，进而转换成求图上的哈密顿路问题。<br>如下图:<br><img src="/img/Chessimg/chess2.jpg" srcset="/img/loading.gif" alt=""><br>寻找一条哈密顿路:<br><img src="/img/Chessimg/chess3.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现:"></a>4.代码实现:</h2><p>使用邻接矩阵来存储图，采用BFS策略来进行路径的选择，通过节点间的度的关系来进行回溯约束，并且采用栈来存储之前遍历过的结点。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//邻接矩阵结构typedef int VertexType;typedef int EdgeType;#define MAX 20#define INFINITY 65535#define TRUE 1#define FALSE 0typedef int Boole;  //布尔类型 存储TRUE FALSEBoole visited[MAX];    //访问标志数组Boole Svisited[MAX];   //已经入栈标志int Stack[MAX];//用来存放图的顶点    int top=0;//栈顶typedef struct{    VertexType vexs[MAX];   //顶点表    EdgeType arc[MAX][MAX];   //邻接矩阵 可看作边表    int numVertexes,numEdges;    //int GraphType;  //图的类型  无向0,有向1}MGraph;//循环队列typedef struct{int data[10];int rear,front;}Quene,*pQueue;void init(pQueue q){    q-&gt;front=0;    q-&gt;rear=0;}void destroyQueue(pQueue q){    free(q);    q=NULL;}void add(pQueue q,int x){    if((q-&gt;rear+1)%10==q-&gt;front){        printf(&quot;overflow&quot;);        return ;    }else{        q-&gt;rear=(q-&gt;rear+1)%10;        q-&gt;data[q-&gt;rear]=x;        printf(&quot;入队成功\n&quot;);    }}int  DeQueue(pQueue q){    int e=0;    if(q-&gt;front==q-&gt;rear){        printf(&quot;null&quot;);        return e;    }else{        q-&gt;front=(q-&gt;front+1)%10;       // printf(&quot;q-&gt;front=%d\n&quot;,q-&gt;front);        printf(&quot;删除的元素是:%d\n&quot;,q-&gt;data[q-&gt;front]);        e=q-&gt;data[q-&gt;front];    }    return e;}void traverseQuene(pQueue q){    int i=q-&gt;front;    while(i!=q-&gt;rear){        i=(i+1)%10;        printf(&quot;%d &quot;,q-&gt;data[i]);    }    printf(&quot;\n&quot;);}//队长度int QueueLength(pQueue q){    return (q-&gt;rear)-(q-&gt;front)+10%10;}//构造图   有向图和无向图void create(MGraph *G){    int i,j,k,w;    printf(&quot;请输入顶点数,边数:\n&quot;);    scanf(&quot;%d,%d&quot;,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);    fflush(stdin);    for(i=0;i&lt;G-&gt;numVertexes;i++)     //建立顶点表    {        //printf(&quot;\n第%d个顶点&quot;,i);        //scanf(&quot;%c&quot;,&amp;G-&gt;vexs[i]);        //getchar();        G-&gt;vexs[i]=i;    }    for(i=0;i&lt;G-&gt;numVertexes;i++)   //矩阵初始化        for(j=0;j&lt;G-&gt;numVertexes;j++)            G-&gt;arc[i][j]=INFINITY;    for(k=0;k&lt;G-&gt;numEdges;k++)    {        printf(&quot;输入边（Vi,Vj）的上下标i,j：&quot;);        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);        G-&gt;arc[i][j]=1;        //if(G-&gt;GraphType==0)      //此时为无向图   有向图与无向的区别就只是这一行代码的有无        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}void Output(MGraph *G)     //输出邻接矩阵{    int i,j,count=0;    for(i=0;i&lt;G-&gt;numVertexes;i++)        printf(&quot;\t%d&quot;,G-&gt;vexs[i]);    printf(&quot;\n&quot;);    for(i=0;i&lt;G-&gt;numVertexes;i++)    {        printf(&quot;%4d&quot;,G-&gt;vexs[i]);        for(j=0;j&lt;G-&gt;numVertexes;j++)        {                printf(&quot;\t%d&quot;,G-&gt;arc[i][j]);                count++;                if(count%G-&gt;numVertexes==0)                printf(&quot;\n&quot;);        }    } }/*//一次遍历全部顶点void OneS(MGraph G){    int i,j;    //所有点标记为新点    for(i=0;i&lt;G.numVertexes;i++){        visited[i]=FALSE;        Svisited[i]=FALSE;        Stack[i]=-1;    }    Stack[0]=G.vexs[0];    visited[0]=TRUE;//已经在栈中    top=0;    while(top!=G.numVertexes-1){        for(i=1;i&lt;G.numVertexes;i++){            printf(&quot;i=%d G.arc[Stack[top]][i]=%d !visited[i]=%d !Svisited[i]=%d\n &quot;,i,G.arc[Stack[top]][i],!visited[i],!Svisited[i]);            if(G.arc[Stack[top]][i]!=INFINITY&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){//找邻接点                PrintStack();                top++;                Stack[top]=G.vexs[i];                visited[i]=TRUE;//此点已经入栈            }        }        if(i==G.numVertexes){            //退栈,表示此点不可达            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            Queue[rear]=Stack[top];//入队            rear++;            Stack[top]=-1;            top--;        }        printf(&quot;top=%d,G.numVertexes-1=%d\n&quot;,top,G.numVertexes-1);        if(rear-front==2){//出队            Svisited[Queue[front]]=FALSE;            front++;        }        printf(&quot;rear=%d\n&quot;,rear);    }}*///打印栈void PrintStack(){    for(int i=0;i&lt;=top;i++){        printf(&quot;%d-&gt;&quot;,Stack[i]);    }    printf(&quot;&lt;\n&quot;);}/*void PrintQueue(Queue Q){    printf(&quot;Queue:&quot;);    for(int i=0;i&lt;10;i++){        printf(&quot; %d &quot;,Q-&gt;data[i]);    }    printf(&quot;\n&quot;);}*///返回结点n的度int NodeDu(MGraph G,int n){    int count=0;    for(int i=0;i&lt;G.numVertexes;i++){        if(G.arc[n][i]==1){            count ++;        }    }    return count;}void PrintNodeDu(MGraph G){    for(int i=0;i&lt;G.numVertexes;i++){        printf(&quot;顶点%d的度:%d&quot;,i,NodeDu(G,i));    }}void OnceSearch(MGraph G){    int i,e;    pQueue q=(pQueue)malloc(sizeof(Quene));//用来存放已经出栈的顶点    //打印顶点    for(i=0;i&lt;G.numVertexes;i++){        printf(&quot;顶点:%d\n&quot;,G.vexs[i]);        visited[i]=FALSE;//标记所有顶点都未被访问        Svisited[i]=FALSE;//标记所有顶点都未被退栈    }    //栈,队初始化    init(q);    Stack[top]=G.vexs[0];    //如果栈里元素=顶点数,则找到路径    int Stop=0;//判断栈顶第二元素是否变化    while((top+1)!=G.numVertexes){        //找相邻结点        for(i=1;i&lt;G.numVertexes;i++){            if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                //记录栈顶第二元素                top++;                Stack[top]=G.vexs[i];                visited[i]=TRUE;            }        }         Stop=Stack[top-1];        printf(&quot;second STop=%d\n&quot;,Stop);         PrintStack();        //如果遍历所有相邻结点都没有找到合适结点,则退栈入队重新再找        if(0&lt;(top)&amp;&amp;(top+1)!=G.numVertexes){            //如果栈顶第二元素变化,说明已经退出第二层,则需要出队            add(q,Stack[top]);            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            printf(&quot;退栈结点:%d\n&quot;,Stack[top]);            top--;            traverseQuene(q);//打印队列            printf(&quot;此时队列元素个数为:%d\n&quot;,QueueLength(q));            printf(&quot;此时栈顶元素Stack[%d]=%d的度为:%d\n&quot;,top,Stack[top],NodeDu(G,Stack[top]));            if(QueueLength(q)==NodeDu(G,Stack[top])){                printf(&quot;进入删除队列:&quot;);                for(i=0;i&lt;NodeDu(G,Stack[top])-1;i++){                    e=DeQueue(q);                    Svisited[e]=FALSE;                    visited[e]=FALSE;                }                /*add(q,Stack[top]);                Svisited[Stack[top]]=TRUE;                visited[Stack[top]]=FALSE;                printf(&quot;退栈结点:%d\n&quot;,Stack[top]);                top--;*/            }            printf(&quot;打印队列:&quot;);                traverseQuene(q);//打印队列                printf(&quot;此时可入栈结点:&quot;);                for(i=0;i&lt;G.numVertexes;i++){                    if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                        printf(&quot; %d &quot;,G.vexs[i]);                    }                }            printf(&quot;\ntop=%d\n&quot;,top);        }    }}int main(){    MGraph G;    int i,j;    //printf(&quot;输入生成图的类型(无向图0/有向图1)：&quot;);    //scanf(&quot;%d&quot;,&amp;G.GraphType);    create(&amp;G);    printf(&quot;邻接矩阵数据如下：\n&quot;);    Output(&amp;G);    printf(&quot;\n&quot;);    //PrintNodeDu(G);    OnceSearch(G);    printf(&quot;\n图遍历完毕\n&quot;);    PrintStack();    return 0;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>代码功能没有实现，应该是回溯栈的选择和约束条件的问题，以后有机会在实现~</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TestMarkdown</title>
    <link href="/2020/04/07/first/"/>
    <url>/2020/04/07/first/</url>
    
    <content type="html"><![CDATA[<h1 id="这是H1标题"><a href="#这是H1标题" class="headerlink" title="这是H1标题"></a>这是H1标题</h1><p>&nbsp;&nbsp;如何缩进,这是空格….<br>以下可写内容<br>分割线</p><hr><h2 id="这是H2标题"><a href="#这是H2标题" class="headerlink" title="这是H2标题"></a>这是H2标题</h2><p>直接写？？？</p><h3 id="这是H3标题-故标题以此类推"><a href="#这是H3标题-故标题以此类推" class="headerlink" title="这是H3标题(故标题以此类推)"></a>这是H3标题(故标题以此类推)</h3><pre><code>$ hexo new &quot;My New Post&quot;代码部分这样写?</code></pre><p>添加链接<br>More info: <a href="https://github.com/YinGuoX" target="_blank" rel="noopener">MyGitHub</a><br>添加图片<br><img src="/img/avatar.png" srcset="/img/loading.gif" alt=""></p><center>如何居中</center><p>记得</center>后要空一行</p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
      <category>Markdown基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
