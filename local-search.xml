<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跳跳马2.0</title>
    <link href="/2020/04/09/Chess2.0/"/>
    <url>/2020/04/09/Chess2.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马2-0"><a href="#跳跳马2-0" class="headerlink" title="跳跳马2.0"></a>跳跳马2.0</h1><hr><p>依旧是采用跳跳马1.0的思想；将棋盘中的马与小兵抽象成结点，结点的可达关系作为对应结点的边。</p><h2 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1.解决方法:"></a>1.解决方法:</h2><hr><h3 id="1-1-主要思想"><a href="#1-1-主要思想" class="headerlink" title="1.1 主要思想:"></a>1.1 主要思想:</h3><p>2.0用邻接矩阵来存储图，使用BFS(Breadth First Search)策略，并且采用数组来存储上一步经过的结点，故只要不满足约束条件时，利用此数组即可回溯到上一结点</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现:"></a>2.代码实现:</h2><hr><p>可以正确执行！！！</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 14int IsSamePoint(int x,int b[],int n);int main(){    int a[N][N];    int b[N];//用来存储已经经过的点    int c[N];//记录上一个顶点的列号    int i,j,count=1,row,col;    for(i=0;i&lt;N;i++)    {        b[i]=-1;        c[N]=-1;    }    b[0]=0;    c[0]=0;    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            a[i][j]=0;        }    }    do    {        scanf(&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;a[i][j]);    }while(i!=-1);    for(i=0;i&lt;N;i++)    {        for(j=0;j&lt;N;j++)        {            printf(&quot;%4d&quot;,a[i][j]);        }        printf(&quot;\n&quot;);    }    row=0;    col=1;    while(count&lt;N)    {        if(a[row][col]!=0&amp;&amp;IsSamePoint(col,b,N))        {            printf(&quot;(%d,%d)--&gt;(%d,0)\n&quot;,row,col,col);            b[count]=col;            count++;            row=col;            col=0;        }else        {            if(col&lt;N-1)            {                col++;            }else            {                //回溯                do{                    row=b[count-2];                    col=b[count-1]+1;                    printf(&quot;col=%d\n&quot;,col);                    b[count-1]=-1;                    count--;                }while(col&gt;=N);                printf(&quot;回溯到:(%d,%d)\n&quot;,row,col-1);                //printf(&quot;越界了\n&quot;);            }        }    }    for(i=0;i&lt;N;i++)    {        printf(&quot;%d  &quot;,b[i]);    }    return 0;}//在b中判断是否有与x相同的元素//有相同就返回0int IsSamePoint(int x,int b[],int n){    int i,flag=1;    for(i=0;i&lt;n;i++)    {        //printf(&quot;b=%d,x=%d\n&quot;,b[i],x);        if(b[i]==x)        {            flag=0;            return flag;        }    }    return flag;}</code></pre><p>代码不足:对应的界面还未完善，只是实现了最核心的功能<br>代码的时间复杂度和空间复杂度应该可以进一步优化。</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跳马1.0</title>
    <link href="/2020/04/08/Chess1.0/"/>
    <url>/2020/04/08/Chess1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跳马1-0"><a href="#跳跳马1-0" class="headerlink" title="跳跳马1.0"></a>跳跳马1.0</h1><h2 id="1-游戏介绍"><a href="#1-游戏介绍" class="headerlink" title="1.游戏介绍:"></a>1.游戏介绍:</h2><hr><p>根据国际象棋的规则和棋盘大小，并且遵守马的行走规则，使用马将棋盘中的所有小兵都吃完，即通关计分。<br>具体游戏界面如下图:<br><img src="/img/Chessimg/chess1.jpg" srcset="/img/loading.gif" alt=""></p><center>游戏界面 </center><h2 id="2-实际问题"><a href="#2-实际问题" class="headerlink" title="2.实际问题:"></a>2.实际问题:</h2><hr><p>随着通过的关卡越多，小兵的数量也越多，而马只要走错一步就直接结束游戏，因此在每一步都必须十分正确，所以有必要使用程序来辅助玩家选择最恰当的路径，进而通关</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法:"></a>3.解决方法:</h2><hr><h3 id="3-1使用到的相关知识"><a href="#3-1使用到的相关知识" class="headerlink" title="3.1使用到的相关知识:"></a>3.1使用到的相关知识:</h3><p>关键词 : 抽象、图、DFS、BFS、栈、回溯、哈密顿图</p><blockquote><p>《离散数学引论》:<br>哈密顿图 : 存在一条哈密顿圈<br>哈密顿路 : 图中存在一条经过所有节点并且不重复的路</p></blockquote><h3 id="3-2-主要思想"><a href="#3-2-主要思想" class="headerlink" title="3.2 主要思想:"></a>3.2 主要思想:</h3><p>将马和小兵抽象成图上的结点，如果小兵与小兵之间或者小兵与马之间满足马的行走规则,则将其连线，从而形成一张图，进而转换成求图上的哈密顿路问题。<br>如下图:<br><img src="/img/Chessimg/chess2.jpg" srcset="/img/loading.gif" alt=""><br>寻找一条哈密顿路:<br><img src="/img/Chessimg/chess3.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现:"></a>4.代码实现:</h2><p>使用邻接矩阵来存储图，采用BFS策略来进行路径的选择，通过节点间的度的关系来进行回溯约束，并且采用栈来存储之前遍历过的结点。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//邻接矩阵结构typedef int VertexType;typedef int EdgeType;#define MAX 20#define INFINITY 65535#define TRUE 1#define FALSE 0typedef int Boole;  //布尔类型 存储TRUE FALSEBoole visited[MAX];    //访问标志数组Boole Svisited[MAX];   //已经入栈标志int Stack[MAX];//用来存放图的顶点    int top=0;//栈顶typedef struct{    VertexType vexs[MAX];   //顶点表    EdgeType arc[MAX][MAX];   //邻接矩阵 可看作边表    int numVertexes,numEdges;    //int GraphType;  //图的类型  无向0,有向1}MGraph;//循环队列typedef struct{int data[10];int rear,front;}Quene,*pQueue;void init(pQueue q){    q-&gt;front=0;    q-&gt;rear=0;}void destroyQueue(pQueue q){    free(q);    q=NULL;}void add(pQueue q,int x){    if((q-&gt;rear+1)%10==q-&gt;front){        printf(&quot;overflow&quot;);        return ;    }else{        q-&gt;rear=(q-&gt;rear+1)%10;        q-&gt;data[q-&gt;rear]=x;        printf(&quot;入队成功\n&quot;);    }}int  DeQueue(pQueue q){    int e=0;    if(q-&gt;front==q-&gt;rear){        printf(&quot;null&quot;);        return e;    }else{        q-&gt;front=(q-&gt;front+1)%10;       // printf(&quot;q-&gt;front=%d\n&quot;,q-&gt;front);        printf(&quot;删除的元素是:%d\n&quot;,q-&gt;data[q-&gt;front]);        e=q-&gt;data[q-&gt;front];    }    return e;}void traverseQuene(pQueue q){    int i=q-&gt;front;    while(i!=q-&gt;rear){        i=(i+1)%10;        printf(&quot;%d &quot;,q-&gt;data[i]);    }    printf(&quot;\n&quot;);}//队长度int QueueLength(pQueue q){    return (q-&gt;rear)-(q-&gt;front)+10%10;}//构造图   有向图和无向图void create(MGraph *G){    int i,j,k,w;    printf(&quot;请输入顶点数,边数:\n&quot;);    scanf(&quot;%d,%d&quot;,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);    fflush(stdin);    for(i=0;i&lt;G-&gt;numVertexes;i++)     //建立顶点表    {        //printf(&quot;\n第%d个顶点&quot;,i);        //scanf(&quot;%c&quot;,&amp;G-&gt;vexs[i]);        //getchar();        G-&gt;vexs[i]=i;    }    for(i=0;i&lt;G-&gt;numVertexes;i++)   //矩阵初始化        for(j=0;j&lt;G-&gt;numVertexes;j++)            G-&gt;arc[i][j]=INFINITY;    for(k=0;k&lt;G-&gt;numEdges;k++)    {        printf(&quot;输入边（Vi,Vj）的上下标i,j：&quot;);        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);        G-&gt;arc[i][j]=1;        //if(G-&gt;GraphType==0)      //此时为无向图   有向图与无向的区别就只是这一行代码的有无        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}void Output(MGraph *G)     //输出邻接矩阵{    int i,j,count=0;    for(i=0;i&lt;G-&gt;numVertexes;i++)        printf(&quot;\t%d&quot;,G-&gt;vexs[i]);    printf(&quot;\n&quot;);    for(i=0;i&lt;G-&gt;numVertexes;i++)    {        printf(&quot;%4d&quot;,G-&gt;vexs[i]);        for(j=0;j&lt;G-&gt;numVertexes;j++)        {                printf(&quot;\t%d&quot;,G-&gt;arc[i][j]);                count++;                if(count%G-&gt;numVertexes==0)                printf(&quot;\n&quot;);        }    } }/*//一次遍历全部顶点void OneS(MGraph G){    int i,j;    //所有点标记为新点    for(i=0;i&lt;G.numVertexes;i++){        visited[i]=FALSE;        Svisited[i]=FALSE;        Stack[i]=-1;    }    Stack[0]=G.vexs[0];    visited[0]=TRUE;//已经在栈中    top=0;    while(top!=G.numVertexes-1){        for(i=1;i&lt;G.numVertexes;i++){            printf(&quot;i=%d G.arc[Stack[top]][i]=%d !visited[i]=%d !Svisited[i]=%d\n &quot;,i,G.arc[Stack[top]][i],!visited[i],!Svisited[i]);            if(G.arc[Stack[top]][i]!=INFINITY&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){//找邻接点                PrintStack();                top++;                Stack[top]=G.vexs[i];                visited[i]=TRUE;//此点已经入栈            }        }        if(i==G.numVertexes){            //退栈,表示此点不可达            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            Queue[rear]=Stack[top];//入队            rear++;            Stack[top]=-1;            top--;        }        printf(&quot;top=%d,G.numVertexes-1=%d\n&quot;,top,G.numVertexes-1);        if(rear-front==2){//出队            Svisited[Queue[front]]=FALSE;            front++;        }        printf(&quot;rear=%d\n&quot;,rear);    }}*///打印栈void PrintStack(){    for(int i=0;i&lt;=top;i++){        printf(&quot;%d-&gt;&quot;,Stack[i]);    }    printf(&quot;&lt;\n&quot;);}/*void PrintQueue(Queue Q){    printf(&quot;Queue:&quot;);    for(int i=0;i&lt;10;i++){        printf(&quot; %d &quot;,Q-&gt;data[i]);    }    printf(&quot;\n&quot;);}*///返回结点n的度int NodeDu(MGraph G,int n){    int count=0;    for(int i=0;i&lt;G.numVertexes;i++){        if(G.arc[n][i]==1){            count ++;        }    }    return count;}void PrintNodeDu(MGraph G){    for(int i=0;i&lt;G.numVertexes;i++){        printf(&quot;顶点%d的度:%d&quot;,i,NodeDu(G,i));    }}void OnceSearch(MGraph G){    int i,e;    pQueue q=(pQueue)malloc(sizeof(Quene));//用来存放已经出栈的顶点    //打印顶点    for(i=0;i&lt;G.numVertexes;i++){        printf(&quot;顶点:%d\n&quot;,G.vexs[i]);        visited[i]=FALSE;//标记所有顶点都未被访问        Svisited[i]=FALSE;//标记所有顶点都未被退栈    }    //栈,队初始化    init(q);    Stack[top]=G.vexs[0];    //如果栈里元素=顶点数,则找到路径    int Stop=0;//判断栈顶第二元素是否变化    while((top+1)!=G.numVertexes){        //找相邻结点        for(i=1;i&lt;G.numVertexes;i++){            if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                //记录栈顶第二元素                top++;                Stack[top]=G.vexs[i];                visited[i]=TRUE;            }        }         Stop=Stack[top-1];        printf(&quot;second STop=%d\n&quot;,Stop);         PrintStack();        //如果遍历所有相邻结点都没有找到合适结点,则退栈入队重新再找        if(0&lt;(top)&amp;&amp;(top+1)!=G.numVertexes){            //如果栈顶第二元素变化,说明已经退出第二层,则需要出队            add(q,Stack[top]);            Svisited[Stack[top]]=TRUE;            visited[Stack[top]]=FALSE;            printf(&quot;退栈结点:%d\n&quot;,Stack[top]);            top--;            traverseQuene(q);//打印队列            printf(&quot;此时队列元素个数为:%d\n&quot;,QueueLength(q));            printf(&quot;此时栈顶元素Stack[%d]=%d的度为:%d\n&quot;,top,Stack[top],NodeDu(G,Stack[top]));            if(QueueLength(q)==NodeDu(G,Stack[top])){                printf(&quot;进入删除队列:&quot;);                for(i=0;i&lt;NodeDu(G,Stack[top])-1;i++){                    e=DeQueue(q);                    Svisited[e]=FALSE;                    visited[e]=FALSE;                }                /*add(q,Stack[top]);                Svisited[Stack[top]]=TRUE;                visited[Stack[top]]=FALSE;                printf(&quot;退栈结点:%d\n&quot;,Stack[top]);                top--;*/            }            printf(&quot;打印队列:&quot;);                traverseQuene(q);//打印队列                printf(&quot;此时可入栈结点:&quot;);                for(i=0;i&lt;G.numVertexes;i++){                    if(G.arc[Stack[top]][i]==1&amp;&amp;!visited[i]&amp;&amp;!Svisited[i]){                        printf(&quot; %d &quot;,G.vexs[i]);                    }                }            printf(&quot;\ntop=%d\n&quot;,top);        }    }}int main(){    MGraph G;    int i,j;    //printf(&quot;输入生成图的类型(无向图0/有向图1)：&quot;);    //scanf(&quot;%d&quot;,&amp;G.GraphType);    create(&amp;G);    printf(&quot;邻接矩阵数据如下：\n&quot;);    Output(&amp;G);    printf(&quot;\n&quot;);    //PrintNodeDu(G);    OnceSearch(G);    printf(&quot;\n图遍历完毕\n&quot;);    PrintStack();    return 0;}</code></pre><h4 id="代码不足"><a href="#代码不足" class="headerlink" title="代码不足:"></a>代码不足:</h4><p>代码功能没有实现，应该是回溯栈的选择和约束条件的问题，以后有机会在实现~</p>]]></content>
    
    
    <categories>
      
      <category>Practice</category>
      
      <category>Chess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TestMarkdown</title>
    <link href="/2020/04/07/first/"/>
    <url>/2020/04/07/first/</url>
    
    <content type="html"><![CDATA[<h1 id="这是H1标题"><a href="#这是H1标题" class="headerlink" title="这是H1标题"></a>这是H1标题</h1><p>&nbsp;&nbsp;如何缩进,这是空格….<br>以下可写内容<br>分割线</p><hr><h2 id="这是H2标题"><a href="#这是H2标题" class="headerlink" title="这是H2标题"></a>这是H2标题</h2><p>直接写？？？</p><h3 id="这是H3标题-故标题以此类推"><a href="#这是H3标题-故标题以此类推" class="headerlink" title="这是H3标题(故标题以此类推)"></a>这是H3标题(故标题以此类推)</h3><pre><code>$ hexo new &quot;My New Post&quot;代码部分这样写?</code></pre><p>添加链接<br>More info: <a href="https://github.com/YinGuoX" target="_blank" rel="noopener">MyGitHub</a><br>添加图片<br><img src="/img/avatar.png" srcset="/img/loading.gif" alt=""></p><center>如何居中</center><p>记得</center>后要空一行</p>]]></content>
    
    
    <categories>
      
      <category>Test</category>
      
      <category>Markdown基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
